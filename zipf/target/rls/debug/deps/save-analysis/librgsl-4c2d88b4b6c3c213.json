{"config":{"output_file":null,"full_docs":false,"pub_only":true,"reachable_only":true,"distro_crate":false,"signatures":false,"borrow_data":false},"version":"0.19.0","compilation":{"directory":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0","program":"/Users/wjs/.rustup/toolchains/stable-x86_64-apple-darwin/bin/rls","arguments":["--crate-name","rgsl","/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","--json=diagnostic-rendered-ansi","--crate-type","dylib","--crate-type","rlib","--emit=dep-info,metadata","-C","prefer-dynamic","-C","debuginfo=2","-C","metadata=4c2d88b4b6c3c213","-C","extra-filename=-4c2d88b4b6c3c213","--out-dir","/Users/wjs/Documents/zipf-model/zipf/target/rls/debug/deps","-L","dependency=/Users/wjs/Documents/zipf-model/zipf/target/rls/debug/deps","--extern","c_vec=/Users/wjs/Documents/zipf-model/zipf/target/rls/debug/deps/libc_vec-6b24eadc5a6ee747.rmeta","--extern","libc=/Users/wjs/Documents/zipf-model/zipf/target/rls/debug/deps/liblibc-1d4c9baea2036a82.rmeta","--cap-lints","allow","-L","native=/usr/local/Cellar/gsl/2.6/lib","--cfg","feature=\"v2\"","-l","gsl","-l","gslcblas","-l","m","--error-format=json","--sysroot","/Users/wjs/.rustup/toolchains/stable-x86_64-apple-darwin"],"output":"/Users/wjs/Documents/zipf-model/zipf/target/rls/debug/deps/librgsl-4c2d88b4b6c3c213.rmeta"},"prelude":{"crate_id":{"name":"rgsl","disambiguator":[5643848805246862829,2618854152426748055]},"crate_root":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src","external_crates":[{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","num":1,"id":{"name":"std","disambiguator":[5808000563841838002,6875932327897409807]}},{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","num":2,"id":{"name":"core","disambiguator":[5459908120384850477,15760959269387734159]}},{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","num":3,"id":{"name":"compiler_builtins","disambiguator":[11826469219384905814,12486183027959381912]}},{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","num":4,"id":{"name":"rustc_std_workspace_core","disambiguator":[5497990426549684121,15109235050116755313]}},{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","num":5,"id":{"name":"alloc","disambiguator":[9495953968349266340,8510226981626586408]}},{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","num":6,"id":{"name":"libc","disambiguator":[423181384897816611,2293857470463835221]}},{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","num":7,"id":{"name":"unwind","disambiguator":[5608331764705855408,15392280463108098182]}},{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","num":8,"id":{"name":"cfg_if","disambiguator":[14701876030349379005,4369912422515260820]}},{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","num":9,"id":{"name":"backtrace","disambiguator":[8984243875435576741,4446548522921354]}},{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","num":10,"id":{"name":"rustc_demangle","disambiguator":[4101421024496600006,15821692231896539213]}},{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","num":11,"id":{"name":"backtrace_sys","disambiguator":[3079379191059796654,13101802771042696873]}},{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","num":12,"id":{"name":"hashbrown","disambiguator":[7173097494859913114,11426318732171342333]}},{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","num":13,"id":{"name":"rustc_std_workspace_alloc","disambiguator":[12351377766094969309,8390201886823579403]}},{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","num":14,"id":{"name":"panic_unwind","disambiguator":[2739304812783641882,6504751215723634061]}},{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","num":15,"id":{"name":"libc","disambiguator":[14542157799492976951,15619345094937603287]}},{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","num":16,"id":{"name":"c_vec","disambiguator":[3898925008224167231,15796138571893237318]}}],"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":93,"byte_end":6677,"line_start":5,"line_end":263,"column_start":1,"column_end":51}},"imports":[{"kind":"Use","ref_id":{"krate":0,"index":7005},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1424,"byte_end":1434,"line_start":60,"line_end":60,"column_start":5,"column_end":15},"alias_span":null,"name":"ComplexF32","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":6997},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1440,"byte_end":1450,"line_start":61,"line_end":61,"column_start":5,"column_end":15},"alias_span":null,"name":"ComplexF64","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":7052},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1456,"byte_end":1462,"line_start":62,"line_end":62,"column_start":5,"column_end":11},"alias_span":null,"name":"Result","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":7058},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1468,"byte_end":1477,"line_start":63,"line_end":63,"column_start":5,"column_end":14},"alias_span":null,"name":"ResultE10","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":3995},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1483,"byte_end":1492,"line_start":64,"line_end":64,"column_start":5,"column_end":14},"alias_span":null,"name":"MatrixF64","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4046},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1498,"byte_end":1507,"line_start":65,"line_end":65,"column_start":5,"column_end":14},"alias_span":null,"name":"MatrixF32","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":3986},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1513,"byte_end":1523,"line_start":66,"line_end":66,"column_start":5,"column_end":15},"alias_span":null,"name":"MatrixView","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4108},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1529,"byte_end":1545,"line_start":67,"line_end":67,"column_start":5,"column_end":21},"alias_span":null,"name":"MatrixComplexF64","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4150},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1551,"byte_end":1567,"line_start":68,"line_end":68,"column_start":5,"column_end":21},"alias_span":null,"name":"MatrixComplexF32","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4987},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1573,"byte_end":1582,"line_start":69,"line_end":69,"column_start":5,"column_end":14},"alias_span":null,"name":"VectorF64","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4943},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1588,"byte_end":1597,"line_start":70,"line_end":70,"column_start":5,"column_end":14},"alias_span":null,"name":"VectorF32","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4935},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1603,"byte_end":1613,"line_start":71,"line_end":71,"column_start":5,"column_end":15},"alias_span":null,"name":"VectorView","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":5041},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1619,"byte_end":1635,"line_start":72,"line_end":72,"column_start":5,"column_end":21},"alias_span":null,"name":"VectorComplexF64","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":5079},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1641,"byte_end":1657,"line_start":73,"line_end":73,"column_start":5,"column_end":21},"alias_span":null,"name":"VectorComplexF32","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4724},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1663,"byte_end":1666,"line_start":74,"line_end":74,"column_start":5,"column_end":8},"alias_span":null,"name":"Rng","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":7065},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1672,"byte_end":1679,"line_start":75,"line_end":75,"column_start":5,"column_end":12},"alias_span":null,"name":"RngType","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4606},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1685,"byte_end":1696,"line_start":76,"line_end":76,"column_start":5,"column_end":16},"alias_span":null,"name":"Permutation","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":3130},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1702,"byte_end":1712,"line_start":77,"line_end":77,"column_start":5,"column_end":15},"alias_span":null,"name":"ChebSeries","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":3164},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1718,"byte_end":1729,"line_start":78,"line_end":78,"column_start":5,"column_end":16},"alias_span":null,"name":"Combination","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4646},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1735,"byte_end":1746,"line_start":79,"line_end":79,"column_start":5,"column_end":16},"alias_span":null,"name":"PolyComplex","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":3360},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1752,"byte_end":1766,"line_start":80,"line_end":80,"column_start":5,"column_end":19},"alias_span":null,"name":"DiscreteHankel","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":3384},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1772,"byte_end":1795,"line_start":81,"line_end":81,"column_start":5,"column_end":28},"alias_span":null,"name":"EigenSymmetricWorkspace","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":3396},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1801,"byte_end":1825,"line_start":82,"line_end":82,"column_start":5,"column_end":29},"alias_span":null,"name":"EigenSymmetricVWorkspace","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":3408},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1831,"byte_end":1854,"line_start":83,"line_end":83,"column_start":5,"column_end":28},"alias_span":null,"name":"EigenHermitianWorkspace","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":3420},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1860,"byte_end":1884,"line_start":84,"line_end":84,"column_start":5,"column_end":29},"alias_span":null,"name":"EigenHermitianVWorkspace","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":3432},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1890,"byte_end":1911,"line_start":85,"line_end":85,"column_start":5,"column_end":26},"alias_span":null,"name":"EigenNonSymmWorkspace","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":3447},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1917,"byte_end":1939,"line_start":86,"line_end":86,"column_start":5,"column_end":27},"alias_span":null,"name":"EigenNonSymmVWorkspace","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":3461},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1945,"byte_end":1966,"line_start":87,"line_end":87,"column_start":5,"column_end":26},"alias_span":null,"name":"EigenGenSymmWorkspace","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":3473},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1972,"byte_end":1994,"line_start":88,"line_end":88,"column_start":5,"column_end":27},"alias_span":null,"name":"EigenGenSymmVWorkspace","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":3485},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2000,"byte_end":2021,"line_start":89,"line_end":89,"column_start":5,"column_end":26},"alias_span":null,"name":"EigenGenHermWorkspace","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":3497},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2027,"byte_end":2049,"line_start":90,"line_end":90,"column_start":5,"column_end":27},"alias_span":null,"name":"EigenGenHermVWorkspace","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":3509},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2055,"byte_end":2072,"line_start":91,"line_end":91,"column_start":5,"column_end":22},"alias_span":null,"name":"EigenGenWorkspace","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":3523},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2078,"byte_end":2096,"line_start":92,"line_end":92,"column_start":5,"column_end":23},"alias_span":null,"name":"EigenGenVWorkspace","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":3539},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2102,"byte_end":2121,"line_start":93,"line_end":93,"column_start":5,"column_end":24},"alias_span":null,"name":"FftComplexWaveTable","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":3553},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2127,"byte_end":2146,"line_start":94,"line_end":94,"column_start":5,"column_end":24},"alias_span":null,"name":"FftComplexWorkspace","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":3568},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2152,"byte_end":2161,"line_start":95,"line_end":95,"column_start":5,"column_end":14},"alias_span":null,"name":"Histogram","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":3607},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2167,"byte_end":2179,"line_start":96,"line_end":96,"column_start":5,"column_end":17},"alias_span":null,"name":"HistogramPdf","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":3620},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2185,"byte_end":2196,"line_start":97,"line_end":97,"column_start":5,"column_end":16},"alias_span":null,"name":"Histogram2D","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":3665},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2202,"byte_end":2216,"line_start":98,"line_end":98,"column_start":5,"column_end":19},"alias_span":null,"name":"Histogram2DPdf","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":3702},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2222,"byte_end":2242,"line_start":99,"line_end":99,"column_start":5,"column_end":25},"alias_span":null,"name":"IntegrationWorkspace","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":3743},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2248,"byte_end":2268,"line_start":100,"line_end":100,"column_start":5,"column_end":25},"alias_span":null,"name":"IntegrationQawsTable","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":3757},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2274,"byte_end":2294,"line_start":101,"line_end":101,"column_start":5,"column_end":25},"alias_span":null,"name":"IntegrationQawoTable","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":3772},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2300,"byte_end":2314,"line_start":102,"line_end":102,"column_start":5,"column_end":19},"alias_span":null,"name":"CquadWorkspace","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":3793},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2320,"byte_end":2332,"line_start":103,"line_end":103,"column_start":5,"column_end":17},"alias_span":null,"name":"GLFixedTable","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":7013},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2338,"byte_end":2349,"line_start":104,"line_end":104,"column_start":5,"column_end":16},"alias_span":null,"name":"InterpAccel","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":3900},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2355,"byte_end":2361,"line_start":105,"line_end":105,"column_start":5,"column_end":11},"alias_span":null,"name":"Interp","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":7020},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2367,"byte_end":2377,"line_start":106,"line_end":106,"column_start":5,"column_end":15},"alias_span":null,"name":"InterpType","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":3927},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2383,"byte_end":2389,"line_start":107,"line_end":107,"column_start":5,"column_end":11},"alias_span":null,"name":"Spline","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4205},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2395,"byte_end":2404,"line_start":108,"line_end":108,"column_start":5,"column_end":14},"alias_span":null,"name":"Minimizer","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4233},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2410,"byte_end":2423,"line_start":109,"line_end":109,"column_start":5,"column_end":18},"alias_span":null,"name":"MinimizerType","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4286},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2429,"byte_end":2444,"line_start":110,"line_end":110,"column_start":5,"column_end":20},"alias_span":null,"name":"PlainMonteCarlo","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4300},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2450,"byte_end":2465,"line_start":111,"line_end":111,"column_start":5,"column_end":20},"alias_span":null,"name":"MiserMonteCarlo","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4316},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2471,"byte_end":2482,"line_start":112,"line_end":112,"column_start":5,"column_end":16},"alias_span":null,"name":"MiserParams","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4322},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2488,"byte_end":2503,"line_start":113,"line_end":113,"column_start":5,"column_end":20},"alias_span":null,"name":"VegasMonteCarlo","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4333},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2509,"byte_end":2520,"line_start":114,"line_end":114,"column_start":5,"column_end":16},"alias_span":null,"name":"VegasParams","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4458},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2526,"byte_end":2533,"line_start":115,"line_end":115,"column_start":5,"column_end":12},"alias_span":null,"name":"NTuples","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4424},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2539,"byte_end":2547,"line_start":116,"line_end":116,"column_start":5,"column_end":13},"alias_span":null,"name":"MultiSet","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4487},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2553,"byte_end":2565,"line_start":117,"line_end":117,"column_start":5,"column_end":17},"alias_span":null,"name":"ODEiv2System","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4499},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2571,"byte_end":2581,"line_start":118,"line_end":118,"column_start":5,"column_end":15},"alias_span":null,"name":"ODEiv2Step","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":7037},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2587,"byte_end":2601,"line_start":119,"line_end":119,"column_start":5,"column_end":19},"alias_span":null,"name":"ODEiv2StepType","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4532},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2607,"byte_end":2620,"line_start":120,"line_end":120,"column_start":5,"column_end":18},"alias_span":null,"name":"ODEiv2Control","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4560},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2626,"byte_end":2638,"line_start":121,"line_end":121,"column_start":5,"column_end":17},"alias_span":null,"name":"ODEiv2Evolve","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4575},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2644,"byte_end":2656,"line_start":122,"line_end":122,"column_start":5,"column_end":17},"alias_span":null,"name":"ODEiv2Driver","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4663},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2662,"byte_end":2666,"line_start":123,"line_end":123,"column_start":5,"column_end":9},"alias_span":null,"name":"QRng","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":7047},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2672,"byte_end":2680,"line_start":124,"line_end":124,"column_start":5,"column_end":13},"alias_span":null,"name":"QRngType","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4864},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2686,"byte_end":2701,"line_start":125,"line_end":125,"column_start":5,"column_end":20},"alias_span":null,"name":"LevinUWorkspace","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4879},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2707,"byte_end":2727,"line_start":126,"line_end":126,"column_start":5,"column_end":25},"alias_span":null,"name":"LevinUTruncWorkspace","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":5119},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2733,"byte_end":2740,"line_start":127,"line_end":127,"column_start":5,"column_end":12},"alias_span":null,"name":"Wavelet","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":7070},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2746,"byte_end":2757,"line_start":128,"line_end":128,"column_start":5,"column_end":16},"alias_span":null,"name":"WaveletType","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":5138},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2763,"byte_end":2779,"line_start":129,"line_end":129,"column_start":5,"column_end":21},"alias_span":null,"name":"WaveletWorkspace","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4385},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2785,"byte_end":2802,"line_start":130,"line_end":130,"column_start":5,"column_end":22},"alias_span":null,"name":"MultiFitFdfSolver","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4380},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2808,"byte_end":2824,"line_start":131,"line_end":131,"column_start":5,"column_end":21},"alias_span":null,"name":"MultiFitFunction","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4400},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2830,"byte_end":2851,"line_start":132,"line_end":132,"column_start":5,"column_end":26},"alias_span":null,"name":"MultiFitFdfSolverType","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4405},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2857,"byte_end":2876,"line_start":133,"line_end":133,"column_start":5,"column_end":24},"alias_span":null,"name":"MultiFitFunctionFdf","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4851},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2882,"byte_end":2895,"line_start":134,"line_end":134,"column_start":5,"column_end":18},"alias_span":null,"name":"RootFdfSolver","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4839},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2901,"byte_end":2918,"line_start":135,"line_end":135,"column_start":5,"column_end":22},"alias_span":null,"name":"RootFdfSolverType","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4827},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2924,"byte_end":2935,"line_start":136,"line_end":136,"column_start":5,"column_end":16},"alias_span":null,"name":"RootFSolver","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4815},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2941,"byte_end":2956,"line_start":137,"line_end":137,"column_start":5,"column_end":20},"alias_span":null,"name":"RootFSolverType","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":1303},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2962,"byte_end":2974,"line_start":138,"line_end":138,"column_start":5,"column_end":17},"alias_span":null,"name":"RootFunction","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":1318},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":2980,"byte_end":2995,"line_start":139,"line_end":139,"column_start":5,"column_end":20},"alias_span":null,"name":"RootFunctionFdf","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4896},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3001,"byte_end":3013,"line_start":140,"line_end":140,"column_start":5,"column_end":17},"alias_span":null,"name":"SimAnnealing","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4918},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3019,"byte_end":3037,"line_start":141,"line_end":141,"column_start":5,"column_end":23},"alias_span":null,"name":"SimAnnealingParams","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":5696},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3064,"byte_end":3074,"line_start":144,"line_end":144,"column_start":21,"column_end":31},"alias_span":null,"name":"Elementary","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":6447},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3089,"byte_end":3092,"line_start":145,"line_end":145,"column_start":14,"column_end":17},"alias_span":null,"name":"Pow","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":6608},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3117,"byte_end":3130,"line_start":146,"line_end":146,"column_start":24,"column_end":37},"alias_span":null,"name":"Trigonometric","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":4720},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3147,"byte_end":3150,"line_start":147,"line_end":147,"column_start":16,"column_end":19},"alias_span":null,"name":"rng","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":2698},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3171,"byte_end":3179,"line_start":148,"line_end":148,"column_start":20,"column_end":28},"alias_span":null,"name":"IOStream","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":6751},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3223,"byte_end":3227,"line_start":152,"line_end":152,"column_start":5,"column_end":9},"alias_span":null,"name":"Mode","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":6768},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3233,"byte_end":3238,"line_start":153,"line_end":153,"column_start":5,"column_end":10},"alias_span":null,"name":"Value","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":2649},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3244,"byte_end":3253,"line_start":154,"line_end":154,"column_start":5,"column_end":14},"alias_span":null,"name":"GSLResult","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":6857},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3259,"byte_end":3268,"line_start":155,"line_end":155,"column_start":5,"column_end":14},"alias_span":null,"name":"EigenSort","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":6876},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3274,"byte_end":3286,"line_start":156,"line_end":156,"column_start":5,"column_end":17},"alias_span":null,"name":"FftDirection","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":6891},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3292,"byte_end":3307,"line_start":157,"line_end":157,"column_start":5,"column_end":20},"alias_span":null,"name":"GaussKonrodRule","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":6914},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3313,"byte_end":3328,"line_start":158,"line_end":158,"column_start":5,"column_end":20},"alias_span":null,"name":"IntegrationQawo","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":6929},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3334,"byte_end":3343,"line_start":159,"line_end":159,"column_start":5,"column_end":14},"alias_span":null,"name":"VegasMode","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":6946},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3349,"byte_end":3354,"line_start":160,"line_end":160,"column_start":5,"column_end":10},"alias_span":null,"name":"ODEiv","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":6963},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3360,"byte_end":3376,"line_start":161,"line_end":161,"column_start":5,"column_end":21},"alias_span":null,"name":"WaveletDirection","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":6978},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3382,"byte_end":3396,"line_start":162,"line_end":162,"column_start":5,"column_end":19},"alias_span":null,"name":"SfLegendreNorm","value":"","parent":{"krate":0,"index":0}},{"kind":"Use","ref_id":{"krate":0,"index":3108},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":430417,"byte_end":430433,"line_start":8,"line_end":8,"column_start":29,"column_end":45},"alias_span":null,"name":"BSpLineWorkspace","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":3130},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":430461,"byte_end":430471,"line_start":10,"line_end":10,"column_start":26,"column_end":36},"alias_span":null,"name":"ChebSeries","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":3164},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":430500,"byte_end":430511,"line_start":11,"line_end":11,"column_start":28,"column_end":39},"alias_span":null,"name":"Combination","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":7005},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":430537,"byte_end":430547,"line_start":12,"line_end":12,"column_start":25,"column_end":35},"alias_span":null,"name":"ComplexF32","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":6997},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":430549,"byte_end":430559,"line_start":12,"line_end":12,"column_start":37,"column_end":47},"alias_span":null,"name":"ComplexF64","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":3360},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":430593,"byte_end":430607,"line_start":13,"line_end":13,"column_start":32,"column_end":46},"alias_span":null,"name":"DiscreteHankel","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":3384},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":430651,"byte_end":430674,"line_start":14,"line_end":14,"column_start":43,"column_end":66},"alias_span":null,"name":"EigenSymmetricWorkspace","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":3396},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":430676,"byte_end":430700,"line_start":14,"line_end":14,"column_start":68,"column_end":92},"alias_span":null,"name":"EigenSymmetricVWorkspace","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":3408},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":430744,"byte_end":430767,"line_start":15,"line_end":15,"column_start":43,"column_end":66},"alias_span":null,"name":"EigenHermitianWorkspace","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":3420},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":430769,"byte_end":430793,"line_start":15,"line_end":15,"column_start":68,"column_end":92},"alias_span":null,"name":"EigenHermitianVWorkspace","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":3432},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":430837,"byte_end":430858,"line_start":16,"line_end":16,"column_start":43,"column_end":64},"alias_span":null,"name":"EigenNonSymmWorkspace","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":3447},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":430860,"byte_end":430882,"line_start":16,"line_end":16,"column_start":66,"column_end":88},"alias_span":null,"name":"EigenNonSymmVWorkspace","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":3461},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":430926,"byte_end":430947,"line_start":17,"line_end":17,"column_start":43,"column_end":64},"alias_span":null,"name":"EigenGenSymmWorkspace","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":3473},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":430949,"byte_end":430971,"line_start":17,"line_end":17,"column_start":66,"column_end":88},"alias_span":null,"name":"EigenGenSymmVWorkspace","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":3485},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431015,"byte_end":431036,"line_start":18,"line_end":18,"column_start":43,"column_end":64},"alias_span":null,"name":"EigenGenHermWorkspace","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":3497},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431038,"byte_end":431060,"line_start":18,"line_end":18,"column_start":66,"column_end":88},"alias_span":null,"name":"EigenGenHermVWorkspace","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":3509},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431104,"byte_end":431121,"line_start":19,"line_end":19,"column_start":43,"column_end":60},"alias_span":null,"name":"EigenGenWorkspace","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":3523},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431123,"byte_end":431141,"line_start":19,"line_end":19,"column_start":62,"column_end":80},"alias_span":null,"name":"EigenGenVWorkspace","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":3539},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431184,"byte_end":431203,"line_start":20,"line_end":20,"column_start":41,"column_end":60},"alias_span":null,"name":"FftComplexWaveTable","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":3553},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431205,"byte_end":431224,"line_start":20,"line_end":20,"column_start":62,"column_end":81},"alias_span":null,"name":"FftComplexWorkspace","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":3568},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431254,"byte_end":431263,"line_start":21,"line_end":21,"column_start":28,"column_end":37},"alias_span":null,"name":"Histogram","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":3607},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431265,"byte_end":431277,"line_start":21,"line_end":21,"column_start":39,"column_end":51},"alias_span":null,"name":"HistogramPdf","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":3620},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431279,"byte_end":431290,"line_start":21,"line_end":21,"column_start":53,"column_end":64},"alias_span":null,"name":"Histogram2D","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":3665},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431292,"byte_end":431306,"line_start":21,"line_end":21,"column_start":66,"column_end":80},"alias_span":null,"name":"Histogram2DPdf","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":3702},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431337,"byte_end":431357,"line_start":22,"line_end":22,"column_start":29,"column_end":49},"alias_span":null,"name":"IntegrationWorkspace","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":3743},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431359,"byte_end":431379,"line_start":22,"line_end":22,"column_start":51,"column_end":71},"alias_span":null,"name":"IntegrationQawsTable","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":3757},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431381,"byte_end":431401,"line_start":22,"line_end":22,"column_start":73,"column_end":93},"alias_span":null,"name":"IntegrationQawoTable","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":3772},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431431,"byte_end":431445,"line_start":23,"line_end":23,"column_start":29,"column_end":43},"alias_span":null,"name":"CquadWorkspace","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":3793},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431447,"byte_end":431459,"line_start":23,"line_end":23,"column_start":45,"column_end":57},"alias_span":null,"name":"GLFixedTable","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":7013},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431492,"byte_end":431503,"line_start":24,"line_end":24,"column_start":31,"column_end":42},"alias_span":null,"name":"InterpAccel","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":3900},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431505,"byte_end":431511,"line_start":24,"line_end":24,"column_start":44,"column_end":50},"alias_span":null,"name":"Interp","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":7020},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431513,"byte_end":431523,"line_start":24,"line_end":24,"column_start":52,"column_end":62},"alias_span":null,"name":"InterpType","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":3927},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431525,"byte_end":431531,"line_start":24,"line_end":24,"column_start":64,"column_end":70},"alias_span":null,"name":"Spline","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":3953},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431557,"byte_end":431573,"line_start":25,"line_end":25,"column_start":24,"column_end":40},"alias_span":null,"name":"MathieuWorkspace","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4046},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431598,"byte_end":431607,"line_start":26,"line_end":26,"column_start":24,"column_end":33},"alias_span":null,"name":"MatrixF32","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":3995},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431609,"byte_end":431618,"line_start":26,"line_end":26,"column_start":35,"column_end":44},"alias_span":null,"name":"MatrixF64","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":3986},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431620,"byte_end":431630,"line_start":26,"line_end":26,"column_start":46,"column_end":56},"alias_span":null,"name":"MatrixView","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4150},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431664,"byte_end":431680,"line_start":27,"line_end":27,"column_start":32,"column_end":48},"alias_span":null,"name":"MatrixComplexF32","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4108},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431682,"byte_end":431698,"line_start":27,"line_end":27,"column_start":50,"column_end":66},"alias_span":null,"name":"MatrixComplexF64","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4205},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431727,"byte_end":431736,"line_start":28,"line_end":28,"column_start":27,"column_end":36},"alias_span":null,"name":"Minimizer","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4233},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431738,"byte_end":431751,"line_start":28,"line_end":28,"column_start":38,"column_end":51},"alias_span":null,"name":"MinimizerType","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4286},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431782,"byte_end":431797,"line_start":29,"line_end":29,"column_start":29,"column_end":44},"alias_span":null,"name":"PlainMonteCarlo","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4300},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431799,"byte_end":431814,"line_start":29,"line_end":29,"column_start":46,"column_end":61},"alias_span":null,"name":"MiserMonteCarlo","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4316},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431816,"byte_end":431827,"line_start":29,"line_end":29,"column_start":63,"column_end":74},"alias_span":null,"name":"MiserParams","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4322},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431829,"byte_end":431844,"line_start":29,"line_end":29,"column_start":76,"column_end":91},"alias_span":null,"name":"VegasMonteCarlo","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4333},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431874,"byte_end":431885,"line_start":30,"line_end":30,"column_start":29,"column_end":40},"alias_span":null,"name":"VegasParams","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4385},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431920,"byte_end":431937,"line_start":31,"line_end":31,"column_start":33,"column_end":50},"alias_span":null,"name":"MultiFitFdfSolver","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4380},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431939,"byte_end":431955,"line_start":31,"line_end":31,"column_start":52,"column_end":68},"alias_span":null,"name":"MultiFitFunction","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4400},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":431957,"byte_end":431978,"line_start":31,"line_end":31,"column_start":70,"column_end":91},"alias_span":null,"name":"MultiFitFdfSolverType","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4405},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432012,"byte_end":432031,"line_start":32,"line_end":32,"column_start":33,"column_end":52},"alias_span":null,"name":"MultiFitFunctionFdf","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4424},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432058,"byte_end":432066,"line_start":33,"line_end":33,"column_start":25,"column_end":33},"alias_span":null,"name":"MultiSet","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4458},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432092,"byte_end":432099,"line_start":34,"line_end":34,"column_start":25,"column_end":32},"alias_span":null,"name":"NTuples","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4487},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432149,"byte_end":432161,"line_start":35,"line_end":35,"column_start":49,"column_end":61},"alias_span":null,"name":"ODEiv2System","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4499},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432163,"byte_end":432173,"line_start":35,"line_end":35,"column_start":63,"column_end":73},"alias_span":null,"name":"ODEiv2Step","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":7037},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432175,"byte_end":432189,"line_start":35,"line_end":35,"column_start":75,"column_end":89},"alias_span":null,"name":"ODEiv2StepType","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4532},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432239,"byte_end":432252,"line_start":36,"line_end":36,"column_start":49,"column_end":62},"alias_span":null,"name":"ODEiv2Control","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4560},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432254,"byte_end":432266,"line_start":36,"line_end":36,"column_start":64,"column_end":76},"alias_span":null,"name":"ODEiv2Evolve","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4575},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432268,"byte_end":432280,"line_start":36,"line_end":36,"column_start":78,"column_end":90},"alias_span":null,"name":"ODEiv2Driver","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4606},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432310,"byte_end":432321,"line_start":37,"line_end":37,"column_start":28,"column_end":39},"alias_span":null,"name":"Permutation","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4646},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432349,"byte_end":432360,"line_start":38,"line_end":38,"column_start":27,"column_end":38},"alias_span":null,"name":"PolyComplex","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4663},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432383,"byte_end":432387,"line_start":39,"line_end":39,"column_start":22,"column_end":26},"alias_span":null,"name":"QRng","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":7047},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432389,"byte_end":432397,"line_start":39,"line_end":39,"column_start":28,"column_end":36},"alias_span":null,"name":"QRngType","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4697},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432428,"byte_end":432439,"line_start":40,"line_end":40,"column_start":29,"column_end":40},"alias_span":null,"name":"RanDiscrete","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":7052},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432464,"byte_end":432470,"line_start":41,"line_end":41,"column_start":24,"column_end":30},"alias_span":null,"name":"Result","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":7058},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432472,"byte_end":432481,"line_start":41,"line_end":41,"column_start":32,"column_end":41},"alias_span":null,"name":"ResultE10","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4724},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432504,"byte_end":432507,"line_start":42,"line_end":42,"column_start":21,"column_end":24},"alias_span":null,"name":"Rng","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":7065},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432509,"byte_end":432516,"line_start":42,"line_end":42,"column_start":26,"column_end":33},"alias_span":null,"name":"RngType","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4827},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432541,"byte_end":432552,"line_start":43,"line_end":43,"column_start":23,"column_end":34},"alias_span":null,"name":"RootFSolver","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4851},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432554,"byte_end":432567,"line_start":43,"line_end":43,"column_start":36,"column_end":49},"alias_span":null,"name":"RootFdfSolver","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4815},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432569,"byte_end":432584,"line_start":43,"line_end":43,"column_start":51,"column_end":66},"alias_span":null,"name":"RootFSolverType","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4839},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432586,"byte_end":432603,"line_start":43,"line_end":43,"column_start":68,"column_end":85},"alias_span":null,"name":"RootFdfSolverType","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":1303},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432605,"byte_end":432617,"line_start":43,"line_end":43,"column_start":87,"column_end":99},"alias_span":null,"name":"RootFunction","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":1318},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432641,"byte_end":432656,"line_start":44,"line_end":44,"column_start":23,"column_end":38},"alias_span":null,"name":"RootFunctionFdf","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4864},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432695,"byte_end":432710,"line_start":45,"line_end":45,"column_start":37,"column_end":52},"alias_span":null,"name":"LevinUWorkspace","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4879},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432712,"byte_end":432732,"line_start":45,"line_end":45,"column_start":54,"column_end":74},"alias_span":null,"name":"LevinUTruncWorkspace","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4896},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432757,"byte_end":432769,"line_start":46,"line_end":46,"column_start":23,"column_end":35},"alias_span":null,"name":"SimAnnealing","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4918},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432771,"byte_end":432789,"line_start":46,"line_end":46,"column_start":37,"column_end":55},"alias_span":null,"name":"SimAnnealingParams","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4943},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432815,"byte_end":432824,"line_start":47,"line_end":47,"column_start":24,"column_end":33},"alias_span":null,"name":"VectorF32","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4987},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432826,"byte_end":432835,"line_start":47,"line_end":47,"column_start":35,"column_end":44},"alias_span":null,"name":"VectorF64","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":4935},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432837,"byte_end":432847,"line_start":47,"line_end":47,"column_start":46,"column_end":56},"alias_span":null,"name":"VectorView","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":5079},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432881,"byte_end":432897,"line_start":48,"line_end":48,"column_start":32,"column_end":48},"alias_span":null,"name":"VectorComplexF32","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":5041},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432899,"byte_end":432915,"line_start":48,"line_end":48,"column_start":50,"column_end":66},"alias_span":null,"name":"VectorComplexF64","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":5119},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432953,"byte_end":432960,"line_start":49,"line_end":49,"column_start":36,"column_end":43},"alias_span":null,"name":"Wavelet","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":7070},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432962,"byte_end":432973,"line_start":49,"line_end":49,"column_start":45,"column_end":56},"alias_span":null,"name":"WaveletType","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":5138},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":432975,"byte_end":432991,"line_start":49,"line_end":49,"column_start":58,"column_end":74},"alias_span":null,"name":"WaveletWorkspace","value":"","parent":{"krate":0,"index":2997}},{"kind":"Use","ref_id":{"krate":0,"index":1303},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1116189,"byte_end":1116201,"line_start":125,"line_end":125,"column_start":14,"column_end":26},"alias_span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1116205,"byte_end":1116217,"line_start":125,"line_end":125,"column_start":30,"column_end":42},"name":"RootFunction","value":"","parent":{"krate":0,"index":4813}},{"kind":"Use","ref_id":{"krate":0,"index":1318},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1121169,"byte_end":1121185,"line_start":255,"line_end":255,"column_start":14,"column_end":30},"alias_span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1121189,"byte_end":1121204,"line_start":255,"line_end":255,"column_start":34,"column_end":49},"name":"RootFunctionFdf","value":"","parent":{"krate":0,"index":4813}}],"defs":[{"kind":"Mod","id":{"krate":0,"index":0},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":93,"byte_end":6677,"line_start":5,"line_end":263,"column_start":1,"column_end":51},"name":"","qualname":"::","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","parent":null,"children":[{"krate":0,"index":1},{"krate":0,"index":2},{"krate":0,"index":3},{"krate":0,"index":4},{"krate":0,"index":5},{"krate":0,"index":88},{"krate":0,"index":89},{"krate":0,"index":90},{"krate":0,"index":91},{"krate":0,"index":92},{"krate":0,"index":93},{"krate":0,"index":105},{"krate":0,"index":2645},{"krate":0,"index":2648},{"krate":0,"index":2689},{"krate":0,"index":2713},{"krate":0,"index":2997},{"krate":0,"index":5149},{"krate":0,"index":5177},{"krate":0,"index":5281},{"krate":0,"index":5394},{"krate":0,"index":5624},{"krate":0,"index":5630},{"krate":0,"index":5645},{"krate":0,"index":5654},{"krate":0,"index":5659},{"krate":0,"index":5674},{"krate":0,"index":5680},{"krate":0,"index":5694},{"krate":0,"index":5716},{"krate":0,"index":5721},{"krate":0,"index":5757},{"krate":0,"index":5782},{"krate":0,"index":5804},{"krate":0,"index":5828},{"krate":0,"index":5855},{"krate":0,"index":5884},{"krate":0,"index":5892},{"krate":0,"index":5960},{"krate":0,"index":5973},{"krate":0,"index":5999},{"krate":0,"index":6085},{"krate":0,"index":6097},{"krate":0,"index":6100},{"krate":0,"index":6112},{"krate":0,"index":6120},{"krate":0,"index":6180},{"krate":0,"index":6265},{"krate":0,"index":6278},{"krate":0,"index":6282},{"krate":0,"index":6287},{"krate":0,"index":6300},{"krate":0,"index":6417},{"krate":0,"index":6446},{"krate":0,"index":6469},{"krate":0,"index":6475},{"krate":0,"index":6500},{"krate":0,"index":6505},{"krate":0,"index":6539},{"krate":0,"index":6585},{"krate":0,"index":6593},{"krate":0,"index":6605},{"krate":0,"index":6656},{"krate":0,"index":6658},{"krate":0,"index":6680},{"krate":0,"index":6711},{"krate":0,"index":6713},{"krate":0,"index":6715},{"krate":0,"index":6717},{"krate":0,"index":6719},{"krate":0,"index":6722},{"krate":0,"index":6725},{"krate":0,"index":6726},{"krate":0,"index":6727},{"krate":0,"index":6728},{"krate":0,"index":6729},{"krate":0,"index":6730},{"krate":0,"index":6731},{"krate":0,"index":6732},{"krate":0,"index":6733},{"krate":0,"index":6734},{"krate":0,"index":6735},{"krate":0,"index":6736},{"krate":0,"index":6737},{"krate":0,"index":6738},{"krate":0,"index":6739},{"krate":0,"index":6740},{"krate":0,"index":6741},{"krate":0,"index":6742},{"krate":0,"index":6743},{"krate":0,"index":6744},{"krate":0,"index":6745},{"krate":0,"index":6746},{"krate":0,"index":6747},{"krate":0,"index":6748},{"krate":0,"index":6749},{"krate":0,"index":6750}],"decl_id":null,"docs":" A __Rust__ binding for the [GSL library][] (the GNU Scientific Library).","sig":null,"attributes":[{"value":"crate_name = \"rgsl\"","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1205,"byte_end":1228,"line_start":48,"line_end":48,"column_start":1,"column_end":24}},{"value":"crate_type = \"rlib\"","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1229,"byte_end":1252,"line_start":49,"line_end":49,"column_start":1,"column_end":24}},{"value":"crate_type = \"dylib\"","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1253,"byte_end":1277,"line_start":50,"line_end":50,"column_start":1,"column_end":25}},{"value":"allow(non_camel_case_types)","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1279,"byte_end":1310,"line_start":52,"line_end":52,"column_start":1,"column_end":32}},{"value":"allow(non_snake_case)","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1311,"byte_end":1336,"line_start":53,"line_end":53,"column_start":1,"column_end":26}},{"value":"allow(unused_unsafe)","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":1337,"byte_end":1361,"line_start":54,"line_end":54,"column_start":1,"column_end":25}}]},{"kind":"Struct","id":{"krate":0,"index":791},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":312158,"byte_end":312168,"line_start":1017,"line_end":1017,"column_start":12,"column_end":22},"name":"gsl_vector","qualname":"::ffi::linalg::gsl_vector","value":"gsl_vector { size, stride, data, block, owner }","parent":null,"children":[{"krate":0,"index":792},{"krate":0,"index":793},{"krate":0,"index":794},{"krate":0,"index":795},{"krate":0,"index":796}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"repr(C)","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":312136,"byte_end":312146,"line_start":1016,"line_end":1016,"column_start":1,"column_end":11}}]},{"kind":"Field","id":{"krate":0,"index":792},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":312179,"byte_end":312183,"line_start":1018,"line_end":1018,"column_start":9,"column_end":13},"name":"size","qualname":"::ffi::linalg::gsl_vector::size","value":"usize","parent":{"krate":0,"index":791},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":793},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":312201,"byte_end":312207,"line_start":1019,"line_end":1019,"column_start":9,"column_end":15},"name":"stride","qualname":"::ffi::linalg::gsl_vector::stride","value":"usize","parent":{"krate":0,"index":791},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":794},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":312225,"byte_end":312229,"line_start":1020,"line_end":1020,"column_start":9,"column_end":13},"name":"data","qualname":"::ffi::linalg::gsl_vector::data","value":"*mut f64","parent":{"krate":0,"index":791},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":795},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":312254,"byte_end":312259,"line_start":1021,"line_end":1021,"column_start":9,"column_end":14},"name":"block","qualname":"::ffi::linalg::gsl_vector::block","value":"*mut ffi::linalg::gsl_block","parent":{"krate":0,"index":791},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":796},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":312285,"byte_end":312290,"line_start":1022,"line_end":1022,"column_start":9,"column_end":14},"name":"owner","qualname":"::ffi::linalg::gsl_vector::owner","value":"i32","parent":{"krate":0,"index":791},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":799},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":312396,"byte_end":312405,"line_start":1032,"line_end":1032,"column_start":12,"column_end":21},"name":"gsl_block","qualname":"::ffi::linalg::gsl_block","value":"gsl_block { size, data }","parent":null,"children":[{"krate":0,"index":800},{"krate":0,"index":801}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"repr(C)","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":312374,"byte_end":312384,"line_start":1031,"line_end":1031,"column_start":1,"column_end":11}}]},{"kind":"Field","id":{"krate":0,"index":800},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":312416,"byte_end":312420,"line_start":1033,"line_end":1033,"column_start":9,"column_end":13},"name":"size","qualname":"::ffi::linalg::gsl_block::size","value":"usize","parent":{"krate":0,"index":799},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":801},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":312438,"byte_end":312442,"line_start":1034,"line_end":1034,"column_start":9,"column_end":13},"name":"data","qualname":"::ffi::linalg::gsl_block::data","value":"*mut f64","parent":{"krate":0,"index":799},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":802},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":312484,"byte_end":312508,"line_start":1038,"line_end":1038,"column_start":12,"column_end":36},"name":"gsl_vector_complex_float","qualname":"::ffi::linalg::gsl_vector_complex_float","value":"gsl_vector_complex_float { size, stride, data, block, owner }","parent":null,"children":[{"krate":0,"index":803},{"krate":0,"index":804},{"krate":0,"index":805},{"krate":0,"index":806},{"krate":0,"index":807}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"repr(C)","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":312462,"byte_end":312472,"line_start":1037,"line_end":1037,"column_start":1,"column_end":11}}]},{"kind":"Field","id":{"krate":0,"index":803},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":312519,"byte_end":312523,"line_start":1039,"line_end":1039,"column_start":9,"column_end":13},"name":"size","qualname":"::ffi::linalg::gsl_vector_complex_float::size","value":"usize","parent":{"krate":0,"index":802},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":804},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":312541,"byte_end":312547,"line_start":1040,"line_end":1040,"column_start":9,"column_end":15},"name":"stride","qualname":"::ffi::linalg::gsl_vector_complex_float::stride","value":"usize","parent":{"krate":0,"index":802},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":805},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":312565,"byte_end":312569,"line_start":1041,"line_end":1041,"column_start":9,"column_end":13},"name":"data","qualname":"::ffi::linalg::gsl_vector_complex_float::data","value":"*mut f32","parent":{"krate":0,"index":802},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":806},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":312593,"byte_end":312598,"line_start":1042,"line_end":1042,"column_start":9,"column_end":14},"name":"block","qualname":"::ffi::linalg::gsl_vector_complex_float::block","value":"*mut ffi::linalg::gsl_block_complex_float","parent":{"krate":0,"index":802},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":807},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":312638,"byte_end":312643,"line_start":1043,"line_end":1043,"column_start":9,"column_end":14},"name":"owner","qualname":"::ffi::linalg::gsl_vector_complex_float::owner","value":"i32","parent":{"krate":0,"index":802},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":808},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":312677,"byte_end":312700,"line_start":1047,"line_end":1047,"column_start":12,"column_end":35},"name":"gsl_block_complex_float","qualname":"::ffi::linalg::gsl_block_complex_float","value":"gsl_block_complex_float { size, data }","parent":null,"children":[{"krate":0,"index":809},{"krate":0,"index":810}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"repr(C)","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":312655,"byte_end":312665,"line_start":1046,"line_end":1046,"column_start":1,"column_end":11}}]},{"kind":"Field","id":{"krate":0,"index":809},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":312711,"byte_end":312715,"line_start":1048,"line_end":1048,"column_start":9,"column_end":13},"name":"size","qualname":"::ffi::linalg::gsl_block_complex_float::size","value":"usize","parent":{"krate":0,"index":808},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":810},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":312733,"byte_end":312737,"line_start":1049,"line_end":1049,"column_start":9,"column_end":13},"name":"data","qualname":"::ffi::linalg::gsl_block_complex_float::data","value":"*mut f32","parent":{"krate":0,"index":808},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":811},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":312778,"byte_end":312796,"line_start":1053,"line_end":1053,"column_start":12,"column_end":30},"name":"gsl_vector_complex","qualname":"::ffi::linalg::gsl_vector_complex","value":"gsl_vector_complex { size, stride, data, block, owner }","parent":null,"children":[{"krate":0,"index":812},{"krate":0,"index":813},{"krate":0,"index":814},{"krate":0,"index":815},{"krate":0,"index":816}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"repr(C)","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":312756,"byte_end":312766,"line_start":1052,"line_end":1052,"column_start":1,"column_end":11}}]},{"kind":"Field","id":{"krate":0,"index":812},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":312807,"byte_end":312811,"line_start":1054,"line_end":1054,"column_start":9,"column_end":13},"name":"size","qualname":"::ffi::linalg::gsl_vector_complex::size","value":"usize","parent":{"krate":0,"index":811},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":813},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":312829,"byte_end":312835,"line_start":1055,"line_end":1055,"column_start":9,"column_end":15},"name":"stride","qualname":"::ffi::linalg::gsl_vector_complex::stride","value":"usize","parent":{"krate":0,"index":811},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":814},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":312853,"byte_end":312857,"line_start":1056,"line_end":1056,"column_start":9,"column_end":13},"name":"data","qualname":"::ffi::linalg::gsl_vector_complex::data","value":"*mut f64","parent":{"krate":0,"index":811},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":815},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":312882,"byte_end":312887,"line_start":1057,"line_end":1057,"column_start":9,"column_end":14},"name":"block","qualname":"::ffi::linalg::gsl_vector_complex::block","value":"*mut ffi::linalg::gsl_block_complex","parent":{"krate":0,"index":811},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":816},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":312921,"byte_end":312926,"line_start":1058,"line_end":1058,"column_start":9,"column_end":14},"name":"owner","qualname":"::ffi::linalg::gsl_vector_complex::owner","value":"i32","parent":{"krate":0,"index":811},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":817},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":312960,"byte_end":312977,"line_start":1062,"line_end":1062,"column_start":12,"column_end":29},"name":"gsl_block_complex","qualname":"::ffi::linalg::gsl_block_complex","value":"gsl_block_complex { size, data }","parent":null,"children":[{"krate":0,"index":818},{"krate":0,"index":819}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"repr(C)","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":312938,"byte_end":312948,"line_start":1061,"line_end":1061,"column_start":1,"column_end":11}}]},{"kind":"Field","id":{"krate":0,"index":818},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":312988,"byte_end":312992,"line_start":1063,"line_end":1063,"column_start":9,"column_end":13},"name":"size","qualname":"::ffi::linalg::gsl_block_complex::size","value":"usize","parent":{"krate":0,"index":817},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":819},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/linalg.rs","byte_start":313010,"byte_end":313014,"line_start":1064,"line_end":1064,"column_start":9,"column_end":13},"name":"data","qualname":"::ffi::linalg::gsl_block_complex::data","value":"*mut f64","parent":{"krate":0,"index":817},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":1303},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/solvers.rs","byte_start":348486,"byte_end":348498,"line_start":185,"line_end":185,"column_start":12,"column_end":24},"name":"gsl_function","qualname":"::ffi::solvers::gsl_function","value":"gsl_function { function, params }","parent":null,"children":[{"krate":0,"index":1304},{"krate":0,"index":1305}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"repr(C)","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/solvers.rs","byte_start":348464,"byte_end":348474,"line_start":184,"line_end":184,"column_start":1,"column_end":11}}]},{"kind":"Field","id":{"krate":0,"index":1304},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/solvers.rs","byte_start":348509,"byte_end":348517,"line_start":186,"line_end":186,"column_start":9,"column_end":17},"name":"function","qualname":"::ffi::solvers::gsl_function::function","value":"std::option::Option<extern \"C\" fn(f64, *mut libc::c_void) -> f64>","parent":{"krate":0,"index":1303},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":1305},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/solvers.rs","byte_start":348596,"byte_end":348602,"line_start":187,"line_end":187,"column_start":9,"column_end":15},"name":"params","qualname":"::ffi::solvers::gsl_function::params","value":"*mut libc::c_void","parent":{"krate":0,"index":1303},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":1318},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/solvers.rs","byte_start":349617,"byte_end":349633,"line_start":219,"line_end":219,"column_start":12,"column_end":28},"name":"gsl_function_fdf","qualname":"::ffi::solvers::gsl_function_fdf","value":"gsl_function_fdf { f, df, fdf, params }","parent":null,"children":[{"krate":0,"index":1319},{"krate":0,"index":1320},{"krate":0,"index":1321},{"krate":0,"index":1322}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"repr(C)","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/solvers.rs","byte_start":349595,"byte_end":349605,"line_start":218,"line_end":218,"column_start":1,"column_end":11}}]},{"kind":"Field","id":{"krate":0,"index":1319},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/solvers.rs","byte_start":349644,"byte_end":349645,"line_start":220,"line_end":220,"column_start":9,"column_end":10},"name":"f","qualname":"::ffi::solvers::gsl_function_fdf::f","value":"std::option::Option<extern \"C\" fn(f64, *mut libc::c_void) -> f64>","parent":{"krate":0,"index":1318},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":1320},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/solvers.rs","byte_start":349724,"byte_end":349726,"line_start":221,"line_end":221,"column_start":9,"column_end":11},"name":"df","qualname":"::ffi::solvers::gsl_function_fdf::df","value":"std::option::Option<extern \"C\" fn(f64, *mut libc::c_void) -> f64>","parent":{"krate":0,"index":1318},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":1321},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/solvers.rs","byte_start":349805,"byte_end":349808,"line_start":222,"line_end":222,"column_start":9,"column_end":12},"name":"fdf","qualname":"::ffi::solvers::gsl_function_fdf::fdf","value":"std::option::Option<for<'r, 's> extern \"C\" fn(f64, *mut libc::c_void, &'r mut f64, &'s mut f64)>","parent":{"krate":0,"index":1318},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":1322},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/solvers.rs","byte_start":350014,"byte_end":350020,"line_start":226,"line_end":226,"column_start":9,"column_end":15},"name":"params","qualname":"::ffi::solvers::gsl_function_fdf::params","value":"*mut libc::c_void","parent":{"krate":0,"index":1318},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":2356},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/mod.rs","byte_start":156645,"byte_end":156656,"line_start":2750,"line_end":2750,"column_start":12,"column_end":23},"name":"gsl_complex","qualname":"::ffi::gsl_complex","value":"gsl_complex { dat }","parent":null,"children":[{"krate":0,"index":2357}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"repr(C)","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/mod.rs","byte_start":156623,"byte_end":156633,"line_start":2749,"line_end":2749,"column_start":1,"column_end":11}}]},{"kind":"Field","id":{"krate":0,"index":2357},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/mod.rs","byte_start":156667,"byte_end":156670,"line_start":2751,"line_end":2751,"column_start":9,"column_end":12},"name":"dat","qualname":"::ffi::gsl_complex::dat","value":"[f64; _]","parent":{"krate":0,"index":2356},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":2359},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/mod.rs","byte_start":156712,"byte_end":156729,"line_start":2755,"line_end":2755,"column_start":12,"column_end":29},"name":"gsl_complex_float","qualname":"::ffi::gsl_complex_float","value":"gsl_complex_float { dat }","parent":null,"children":[{"krate":0,"index":2360}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"repr(C)","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/mod.rs","byte_start":156690,"byte_end":156700,"line_start":2754,"line_end":2754,"column_start":1,"column_end":11}}]},{"kind":"Field","id":{"krate":0,"index":2360},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/mod.rs","byte_start":156740,"byte_end":156743,"line_start":2756,"line_end":2756,"column_start":9,"column_end":12},"name":"dat","qualname":"::ffi::gsl_complex_float::dat","value":"[f32; _]","parent":{"krate":0,"index":2359},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":2475},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/mod.rs","byte_start":164497,"byte_end":164516,"line_start":2950,"line_end":2950,"column_start":12,"column_end":31},"name":"extrapolation_table","qualname":"::ffi::extrapolation_table","value":"extrapolation_table { n, rlist2, nres, res3la }","parent":null,"children":[{"krate":0,"index":2476},{"krate":0,"index":2477},{"krate":0,"index":2479},{"krate":0,"index":2480}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"repr(C)","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/mod.rs","byte_start":164475,"byte_end":164485,"line_start":2949,"line_end":2949,"column_start":1,"column_end":11}}]},{"kind":"Field","id":{"krate":0,"index":2476},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/mod.rs","byte_start":164527,"byte_end":164528,"line_start":2951,"line_end":2951,"column_start":9,"column_end":10},"name":"n","qualname":"::ffi::extrapolation_table::n","value":"usize","parent":{"krate":0,"index":2475},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":2477},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/mod.rs","byte_start":164546,"byte_end":164552,"line_start":2952,"line_end":2952,"column_start":9,"column_end":15},"name":"rlist2","qualname":"::ffi::extrapolation_table::rlist2","value":"[f64; _]","parent":{"krate":0,"index":2475},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":2479},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/mod.rs","byte_start":164578,"byte_end":164582,"line_start":2953,"line_end":2953,"column_start":9,"column_end":13},"name":"nres","qualname":"::ffi::extrapolation_table::nres","value":"usize","parent":{"krate":0,"index":2475},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":2480},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/ffi/mod.rs","byte_start":164600,"byte_end":164606,"line_start":2954,"line_end":2954,"column_start":9,"column_end":15},"name":"res3la","qualname":"::ffi::extrapolation_table::res3la","value":"[f64; _]","parent":{"krate":0,"index":2475},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6752},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":351568,"byte_end":351578,"line_start":8,"line_end":8,"column_start":5,"column_end":15},"name":"PrecDouble","qualname":"::enums::Mode::PrecDouble","value":"Mode::PrecDouble","parent":{"krate":0,"index":6751},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6754},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":351584,"byte_end":351594,"line_start":9,"line_end":9,"column_start":5,"column_end":15},"name":"PrecSingle","qualname":"::enums::Mode::PrecSingle","value":"Mode::PrecSingle","parent":{"krate":0,"index":6751},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6756},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":351600,"byte_end":351610,"line_start":10,"line_end":10,"column_start":5,"column_end":15},"name":"PrecApprox","qualname":"::enums::Mode::PrecApprox","value":"Mode::PrecApprox","parent":{"krate":0,"index":6751},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":6751},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":351557,"byte_end":351561,"line_start":7,"line_end":7,"column_start":10,"column_end":14},"name":"Mode","qualname":"::enums::Mode","value":"Mode::{PrecDouble, PrecSingle, PrecApprox}","parent":null,"children":[{"krate":0,"index":6752},{"krate":0,"index":6754},{"krate":0,"index":6756}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"repr(C)","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":351537,"byte_end":351547,"line_start":6,"line_end":6,"column_start":1,"column_end":11}}]},{"kind":"Type","id":{"krate":0,"index":2649},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":351705,"byte_end":351714,"line_start":14,"line_end":14,"column_start":10,"column_end":19},"name":"GSLResult","qualname":"::enums::GSLResult","value":"::std::result::Result<T, Value>","parent":null,"children":[],"decl_id":null,"docs":" A type for results generated by GSL functions where `Err` is `enums::Value`.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6769},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":352017,"byte_end":352024,"line_start":27,"line_end":27,"column_start":5,"column_end":12},"name":"Success","qualname":"::enums::Value::Success","value":"Value::Success","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6771},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":352030,"byte_end":352037,"line_start":28,"line_end":28,"column_start":5,"column_end":12},"name":"Failure","qualname":"::enums::Value::Failure","value":"Value::Failure","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6773},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":352079,"byte_end":352087,"line_start":30,"line_end":30,"column_start":5,"column_end":13},"name":"Continue","qualname":"::enums::Value::Continue","value":"Value::Continue","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" iteration has not converged\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6775},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":352134,"byte_end":352140,"line_start":32,"line_end":32,"column_start":5,"column_end":11},"name":"Domain","qualname":"::enums::Value::Domain","value":"Value::Domain","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" input domain error, e.g sqrt(-1)\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6777},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":352190,"byte_end":352195,"line_start":34,"line_end":34,"column_start":5,"column_end":10},"name":"Range","qualname":"::enums::Value::Range","value":"Value::Range","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" output range error, e.g. exp(1e100)\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6779},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":352225,"byte_end":352230,"line_start":36,"line_end":36,"column_start":5,"column_end":10},"name":"Fault","qualname":"::enums::Value::Fault","value":"Value::Fault","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" invalid pointer\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6781},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":352278,"byte_end":352285,"line_start":38,"line_end":38,"column_start":5,"column_end":12},"name":"Invalid","qualname":"::enums::Value::Invalid","value":"Value::Invalid","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" invalid argument supplied by user\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6783},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":352315,"byte_end":352321,"line_start":40,"line_end":40,"column_start":5,"column_end":11},"name":"Failed","qualname":"::enums::Value::Failed","value":"Value::Failed","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" generic failure\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6785},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":352356,"byte_end":352369,"line_start":42,"line_end":42,"column_start":5,"column_end":18},"name":"Factorization","qualname":"::enums::Value::Factorization","value":"Value::Factorization","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" factorization failed\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6787},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":352422,"byte_end":352428,"line_start":44,"line_end":44,"column_start":5,"column_end":11},"name":"Sanity","qualname":"::enums::Value::Sanity","value":"Value::Sanity","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" sanity check failed - shouldn't happen\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6789},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":352456,"byte_end":352464,"line_start":46,"line_end":46,"column_start":5,"column_end":13},"name":"NoMemory","qualname":"::enums::Value::NoMemory","value":"Value::NoMemory","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" malloc failed\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6791},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":352514,"byte_end":352525,"line_start":48,"line_end":48,"column_start":5,"column_end":16},"name":"BadFunction","qualname":"::enums::Value::BadFunction","value":"Value::BadFunction","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" problem with user-supplied function\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6793},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":352575,"byte_end":352582,"line_start":50,"line_end":50,"column_start":5,"column_end":12},"name":"RunAway","qualname":"::enums::Value::RunAway","value":"Value::RunAway","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" iterative process is out of control\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6795},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":352630,"byte_end":352642,"line_start":52,"line_end":52,"column_start":5,"column_end":17},"name":"MaxIteration","qualname":"::enums::Value::MaxIteration","value":"Value::MaxIteration","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" exceeded max number of iterations\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6797},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":352680,"byte_end":352687,"line_start":54,"line_end":54,"column_start":5,"column_end":12},"name":"ZeroDiv","qualname":"::enums::Value::ZeroDiv","value":"Value::ZeroDiv","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" tried to divide by zero\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6799},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":352737,"byte_end":352749,"line_start":56,"line_end":56,"column_start":5,"column_end":17},"name":"BadTolerance","qualname":"::enums::Value::BadTolerance","value":"Value::BadTolerance","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" user specified an invalid tolerance\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6801},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":352803,"byte_end":352812,"line_start":58,"line_end":58,"column_start":5,"column_end":14},"name":"Tolerance","qualname":"::enums::Value::Tolerance","value":"Value::Tolerance","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" failed to reach the specified tolerance\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6803},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":352836,"byte_end":352845,"line_start":60,"line_end":60,"column_start":5,"column_end":14},"name":"UnderFlow","qualname":"::enums::Value::UnderFlow","value":"Value::UnderFlow","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" underflow\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6805},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":352868,"byte_end":352876,"line_start":62,"line_end":62,"column_start":5,"column_end":13},"name":"OverFlow","qualname":"::enums::Value::OverFlow","value":"Value::OverFlow","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" overflow\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6807},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":352907,"byte_end":352911,"line_start":64,"line_end":64,"column_start":5,"column_end":9},"name":"Loss","qualname":"::enums::Value::Loss","value":"Value::Loss","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" loss of accuracy\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6809},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":352958,"byte_end":352963,"line_start":66,"line_end":66,"column_start":5,"column_end":10},"name":"Round","qualname":"::enums::Value::Round","value":"Value::Round","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" failed because of roundoff error\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6811},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":353019,"byte_end":353028,"line_start":68,"line_end":68,"column_start":5,"column_end":14},"name":"BadLength","qualname":"::enums::Value::BadLength","value":"Value::BadLength","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" matrix, vector lengths are not conformant\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6813},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":353060,"byte_end":353069,"line_start":70,"line_end":70,"column_start":5,"column_end":14},"name":"NotSquare","qualname":"::enums::Value::NotSquare","value":"Value::NotSquare","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" matrix not square\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6815},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":353113,"byte_end":353124,"line_start":72,"line_end":72,"column_start":5,"column_end":16},"name":"Singularity","qualname":"::enums::Value::Singularity","value":"Value::Singularity","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" apparent singularity detected\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6817},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":353170,"byte_end":353177,"line_start":74,"line_end":74,"column_start":5,"column_end":12},"name":"Diverge","qualname":"::enums::Value::Diverge","value":"Value::Diverge","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" integral or series is divergent\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6819},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":353242,"byte_end":353253,"line_start":76,"line_end":76,"column_start":5,"column_end":16},"name":"Unsupported","qualname":"::enums::Value::Unsupported","value":"Value::Unsupported","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" requested feature is not supported by the hardware\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6821},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":353307,"byte_end":353320,"line_start":78,"line_end":78,"column_start":5,"column_end":18},"name":"Unimplemented","qualname":"::enums::Value::Unimplemented","value":"Value::Unimplemented","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" requested feature not (yet) implemented\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6823},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":353355,"byte_end":353360,"line_start":80,"line_end":80,"column_start":5,"column_end":10},"name":"Cache","qualname":"::enums::Value::Cache","value":"Value::Cache","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" cache limit exceeded\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6825},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":353395,"byte_end":353400,"line_start":82,"line_end":82,"column_start":5,"column_end":10},"name":"Table","qualname":"::enums::Value::Table","value":"Value::Table","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" table limit exceeded\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6827},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":353464,"byte_end":353474,"line_start":84,"line_end":84,"column_start":5,"column_end":15},"name":"NoProgress","qualname":"::enums::Value::NoProgress","value":"Value::NoProgress","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" iteration is not making progress towards solution\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6829},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":353540,"byte_end":353558,"line_start":86,"line_end":86,"column_start":5,"column_end":23},"name":"NoProgressJacobian","qualname":"::enums::Value::NoProgressJacobian","value":"Value::NoProgressJacobian","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" jacobian evaluations are not improving the solution\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6831},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":353614,"byte_end":353624,"line_start":88,"line_end":88,"column_start":5,"column_end":15},"name":"ToleranceF","qualname":"::enums::Value::ToleranceF","value":"Value::ToleranceF","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" cannot reach the specified tolerance in F\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6833},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":353680,"byte_end":353690,"line_start":90,"line_end":90,"column_start":5,"column_end":15},"name":"ToleranceX","qualname":"::enums::Value::ToleranceX","value":"Value::ToleranceX","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" cannot reach the specified tolerance in X\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6835},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":353753,"byte_end":353763,"line_start":92,"line_end":92,"column_start":5,"column_end":15},"name":"ToleranceG","qualname":"::enums::Value::ToleranceG","value":"Value::ToleranceG","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" cannot reach the specified tolerance in gradient\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6837},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":353826,"byte_end":353829,"line_start":94,"line_end":94,"column_start":5,"column_end":8},"name":"EOF","qualname":"::enums::Value::EOF","value":"Value::EOF","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" cannot reach the specified tolerance in gradient\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6839},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":353858,"byte_end":353865,"line_start":96,"line_end":96,"column_start":5,"column_end":12},"name":"Unknown","qualname":"::enums::Value::Unknown","value":"Value::Unknown(i32)","parent":{"krate":0,"index":6768},"children":[],"decl_id":null,"docs":" Unknown value.\n","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":6768},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":352005,"byte_end":352010,"line_start":26,"line_end":26,"column_start":10,"column_end":15},"name":"Value","qualname":"::enums::Value","value":"Value::{Success, Failure, Continue, Domain, Range, Fault, Invalid, Failed, Factorization, Sanity, NoMemory, BadFunction, RunAway, MaxIteration, ZeroDiv, BadTolerance, Tolerance, UnderFlow, OverFlow, Loss, Round, BadLength, NotSquare, Singularity, Diverge, Unsupported, Unimplemented, Cache, Table, NoProgress, NoProgressJacobian, ToleranceF, ToleranceX, ToleranceG, EOF, Unknown}","parent":null,"children":[{"krate":0,"index":6769},{"krate":0,"index":6771},{"krate":0,"index":6773},{"krate":0,"index":6775},{"krate":0,"index":6777},{"krate":0,"index":6779},{"krate":0,"index":6781},{"krate":0,"index":6783},{"krate":0,"index":6785},{"krate":0,"index":6787},{"krate":0,"index":6789},{"krate":0,"index":6791},{"krate":0,"index":6793},{"krate":0,"index":6795},{"krate":0,"index":6797},{"krate":0,"index":6799},{"krate":0,"index":6801},{"krate":0,"index":6803},{"krate":0,"index":6805},{"krate":0,"index":6807},{"krate":0,"index":6809},{"krate":0,"index":6811},{"krate":0,"index":6813},{"krate":0,"index":6815},{"krate":0,"index":6817},{"krate":0,"index":6819},{"krate":0,"index":6821},{"krate":0,"index":6823},{"krate":0,"index":6825},{"krate":0,"index":6827},{"krate":0,"index":6829},{"krate":0,"index":6831},{"krate":0,"index":6833},{"krate":0,"index":6835},{"krate":0,"index":6837},{"krate":0,"index":6839}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6858},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":356756,"byte_end":356762,"line_start":188,"line_end":188,"column_start":5,"column_end":11},"name":"ValAsc","qualname":"::enums::EigenSort::ValAsc","value":"EigenSort::ValAsc","parent":{"krate":0,"index":6857},"children":[],"decl_id":null,"docs":" ascending order in numerical value\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6860},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":356812,"byte_end":356819,"line_start":190,"line_end":190,"column_start":5,"column_end":12},"name":"ValDesc","qualname":"::enums::EigenSort::ValDesc","value":"EigenSort::ValDesc","parent":{"krate":0,"index":6857},"children":[],"decl_id":null,"docs":" descending order in numerical value\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6862},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":356862,"byte_end":356868,"line_start":192,"line_end":192,"column_start":5,"column_end":11},"name":"AbsAsc","qualname":"::enums::EigenSort::AbsAsc","value":"EigenSort::AbsAsc","parent":{"krate":0,"index":6857},"children":[],"decl_id":null,"docs":" ascending order in magnitude\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6864},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":356912,"byte_end":356919,"line_start":194,"line_end":194,"column_start":5,"column_end":12},"name":"AbsDesc","qualname":"::enums::EigenSort::AbsDesc","value":"EigenSort::AbsDesc","parent":{"krate":0,"index":6857},"children":[],"decl_id":null,"docs":" descending order in magnitude\n","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":6857},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":356697,"byte_end":356706,"line_start":186,"line_end":186,"column_start":10,"column_end":19},"name":"EigenSort","qualname":"::enums::EigenSort","value":"EigenSort::{ValAsc, ValDesc, AbsAsc, AbsDesc}","parent":null,"children":[{"krate":0,"index":6858},{"krate":0,"index":6860},{"krate":0,"index":6862},{"krate":0,"index":6864}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6877},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":357765,"byte_end":357772,"line_start":229,"line_end":229,"column_start":5,"column_end":12},"name":"Forward","qualname":"::enums::FftDirection::Forward","value":"FftDirection::Forward","parent":{"krate":0,"index":6876},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6879},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":357778,"byte_end":357786,"line_start":230,"line_end":230,"column_start":5,"column_end":13},"name":"Backward","qualname":"::enums::FftDirection::Backward","value":"FftDirection::Backward","parent":{"krate":0,"index":6876},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":6876},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":357746,"byte_end":357758,"line_start":228,"line_end":228,"column_start":10,"column_end":22},"name":"FftDirection","qualname":"::enums::FftDirection","value":"FftDirection::{Forward, Backward}","parent":null,"children":[{"krate":0,"index":6877},{"krate":0,"index":6879}],"decl_id":null,"docs":" this gives the sign in the formula","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6892},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":358507,"byte_end":358514,"line_start":256,"line_end":256,"column_start":5,"column_end":12},"name":"Gauss15","qualname":"::enums::GaussKonrodRule::Gauss15","value":"GaussKonrodRule::Gauss15","parent":{"krate":0,"index":6891},"children":[],"decl_id":null,"docs":" 15 point Gauss-Kronrod rule\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6894},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":358556,"byte_end":358563,"line_start":258,"line_end":258,"column_start":5,"column_end":12},"name":"Gauss21","qualname":"::enums::GaussKonrodRule::Gauss21","value":"GaussKonrodRule::Gauss21","parent":{"krate":0,"index":6891},"children":[],"decl_id":null,"docs":" 21 point Gauss-Kronrod rule\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6896},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":358605,"byte_end":358612,"line_start":260,"line_end":260,"column_start":5,"column_end":12},"name":"Gauss31","qualname":"::enums::GaussKonrodRule::Gauss31","value":"GaussKonrodRule::Gauss31","parent":{"krate":0,"index":6891},"children":[],"decl_id":null,"docs":" 31 point Gauss-Kronrod rule\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6898},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":358654,"byte_end":358661,"line_start":262,"line_end":262,"column_start":5,"column_end":12},"name":"Gauss41","qualname":"::enums::GaussKonrodRule::Gauss41","value":"GaussKonrodRule::Gauss41","parent":{"krate":0,"index":6891},"children":[],"decl_id":null,"docs":" 41 point Gauss-Kronrod rule\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6900},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":358703,"byte_end":358710,"line_start":264,"line_end":264,"column_start":5,"column_end":12},"name":"Gauss51","qualname":"::enums::GaussKonrodRule::Gauss51","value":"GaussKonrodRule::Gauss51","parent":{"krate":0,"index":6891},"children":[],"decl_id":null,"docs":" 51 point Gauss-Kronrod rule\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6902},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":358752,"byte_end":358759,"line_start":266,"line_end":266,"column_start":5,"column_end":12},"name":"Gauss61","qualname":"::enums::GaussKonrodRule::Gauss61","value":"GaussKonrodRule::Gauss61","parent":{"krate":0,"index":6891},"children":[],"decl_id":null,"docs":" 61 point Gauss-Kronrod rule\n","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":6891},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":358449,"byte_end":358464,"line_start":254,"line_end":254,"column_start":10,"column_end":25},"name":"GaussKonrodRule","qualname":"::enums::GaussKonrodRule","value":"GaussKonrodRule::{Gauss15, Gauss21, Gauss31, Gauss41, Gauss51, Gauss61}","parent":null,"children":[{"krate":0,"index":6892},{"krate":0,"index":6894},{"krate":0,"index":6896},{"krate":0,"index":6898},{"krate":0,"index":6900},{"krate":0,"index":6902}],"decl_id":null,"docs":" The low-level integration rules in QUADPACK are identified by small integers (1-6). We'll use symbolic constants to refer to them.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6915},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":359715,"byte_end":359721,"line_start":299,"line_end":299,"column_start":5,"column_end":11},"name":"Cosine","qualname":"::enums::IntegrationQawo::Cosine","value":"IntegrationQawo::Cosine","parent":{"krate":0,"index":6914},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6917},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":359727,"byte_end":359731,"line_start":300,"line_end":300,"column_start":5,"column_end":9},"name":"Sine","qualname":"::enums::IntegrationQawo::Sine","value":"IntegrationQawo::Sine","parent":{"krate":0,"index":6914},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":6914},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":359693,"byte_end":359708,"line_start":298,"line_end":298,"column_start":10,"column_end":25},"name":"IntegrationQawo","qualname":"::enums::IntegrationQawo","value":"IntegrationQawo::{Cosine, Sine}","parent":null,"children":[{"krate":0,"index":6915},{"krate":0,"index":6917}],"decl_id":null,"docs":" Used by workspace for QAWO integrator\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6930},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":360720,"byte_end":360730,"line_start":331,"line_end":331,"column_start":5,"column_end":15},"name":"Importance","qualname":"::enums::VegasMode::Importance","value":"VegasMode::Importance","parent":{"krate":0,"index":6929},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6932},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":360736,"byte_end":360750,"line_start":332,"line_end":332,"column_start":5,"column_end":19},"name":"ImportanceOnly","qualname":"::enums::VegasMode::ImportanceOnly","value":"VegasMode::ImportanceOnly","parent":{"krate":0,"index":6929},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6934},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":360756,"byte_end":360766,"line_start":333,"line_end":333,"column_start":5,"column_end":15},"name":"Stratified","qualname":"::enums::VegasMode::Stratified","value":"VegasMode::Stratified","parent":{"krate":0,"index":6929},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":6929},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":360704,"byte_end":360713,"line_start":330,"line_end":330,"column_start":10,"column_end":19},"name":"VegasMode","qualname":"::enums::VegasMode","value":"VegasMode::{Importance, ImportanceOnly, Stratified}","parent":null,"children":[{"krate":0,"index":6930},{"krate":0,"index":6932},{"krate":0,"index":6934}],"decl_id":null,"docs":" Used by VegasMonteCarlo struct","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6947},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":361504,"byte_end":361507,"line_start":361,"line_end":361,"column_start":5,"column_end":8},"name":"Inc","qualname":"::enums::ODEiv::Inc","value":"ODEiv::Inc","parent":{"krate":0,"index":6946},"children":[],"decl_id":null,"docs":" step was increased\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6949},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":361536,"byte_end":361539,"line_start":363,"line_end":363,"column_start":5,"column_end":8},"name":"Nil","qualname":"::enums::ODEiv::Nil","value":"ODEiv::Nil","parent":{"krate":0,"index":6946},"children":[],"decl_id":null,"docs":" step unchanged\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6951},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":361568,"byte_end":361571,"line_start":365,"line_end":365,"column_start":5,"column_end":8},"name":"Dec","qualname":"::enums::ODEiv::Dec","value":"ODEiv::Dec","parent":{"krate":0,"index":6946},"children":[],"decl_id":null,"docs":" step decreased\n","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":6946},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":361465,"byte_end":361470,"line_start":359,"line_end":359,"column_start":10,"column_end":15},"name":"ODEiv","qualname":"::enums::ODEiv","value":"ODEiv::{Inc, Nil, Dec}","parent":null,"children":[{"krate":0,"index":6947},{"krate":0,"index":6949},{"krate":0,"index":6951}],"decl_id":null,"docs":" Possible return values for an hadjust() evolution method for ordinary differential equations\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6964},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":362106,"byte_end":362113,"line_start":391,"line_end":391,"column_start":5,"column_end":12},"name":"Forward","qualname":"::enums::WaveletDirection::Forward","value":"WaveletDirection::Forward","parent":{"krate":0,"index":6963},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6966},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":362119,"byte_end":362127,"line_start":392,"line_end":392,"column_start":5,"column_end":13},"name":"Backward","qualname":"::enums::WaveletDirection::Backward","value":"WaveletDirection::Backward","parent":{"krate":0,"index":6963},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":6963},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":362083,"byte_end":362099,"line_start":390,"line_end":390,"column_start":10,"column_end":26},"name":"WaveletDirection","qualname":"::enums::WaveletDirection","value":"WaveletDirection::{Forward, Backward}","parent":null,"children":[{"krate":0,"index":6964},{"krate":0,"index":6966}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6979},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":362708,"byte_end":362715,"line_start":416,"line_end":416,"column_start":5,"column_end":12},"name":"Schmidt","qualname":"::enums::SfLegendreNorm::Schmidt","value":"SfLegendreNorm::Schmidt","parent":{"krate":0,"index":6978},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6981},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":362721,"byte_end":362738,"line_start":417,"line_end":417,"column_start":5,"column_end":22},"name":"SphericalHarmonic","qualname":"::enums::SfLegendreNorm::SphericalHarmonic","value":"SfLegendreNorm::SphericalHarmonic","parent":{"krate":0,"index":6978},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6983},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":362744,"byte_end":362748,"line_start":418,"line_end":418,"column_start":5,"column_end":9},"name":"Full","qualname":"::enums::SfLegendreNorm::Full","value":"SfLegendreNorm::Full","parent":{"krate":0,"index":6978},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":6985},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":362754,"byte_end":362758,"line_start":419,"line_end":419,"column_start":5,"column_end":9},"name":"None","qualname":"::enums::SfLegendreNorm::None","value":"SfLegendreNorm::None","parent":{"krate":0,"index":6978},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":6978},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":362687,"byte_end":362701,"line_start":415,"line_end":415,"column_start":10,"column_end":24},"name":"SfLegendreNorm","qualname":"::enums::SfLegendreNorm","value":"SfLegendreNorm::{Schmidt, SphericalHarmonic, Full, None}","parent":null,"children":[{"krate":0,"index":6979},{"krate":0,"index":6981},{"krate":0,"index":6983},{"krate":0,"index":6985}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":2698},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/utilities.rs","byte_start":363649,"byte_end":363657,"line_start":11,"line_end":11,"column_start":12,"column_end":20},"name":"IOStream","qualname":"::utilities::IOStream","value":"IOStream {  }","parent":null,"children":[{"krate":0,"index":2699},{"krate":0,"index":2700}],"decl_id":null,"docs":" A wrapper to handle I/O operations between GSL and rust\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":2707},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/utilities.rs","byte_start":363819,"byte_end":363832,"line_start":24,"line_end":24,"column_start":12,"column_end":25},"name":"fwrite_handle","qualname":"<IOStream>::fwrite_handle","value":"fn <P> (file: &P) -> Result<IOStream, ::std::io::ErrorKind>","parent":null,"children":[],"decl_id":null,"docs":" Open a file in write mode.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":2709},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/utilities.rs","byte_start":364329,"byte_end":364339,"line_start":40,"line_end":40,"column_start":12,"column_end":22},"name":"write_mode","qualname":"<IOStream>::write_mode","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":2710},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/utilities.rs","byte_start":364496,"byte_end":364502,"line_start":48,"line_end":48,"column_start":12,"column_end":18},"name":"as_raw","qualname":"<IOStream>::as_raw","value":"fn (&mut self) -> *mut FILE","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2713},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"randist","qualname":"::randist","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","parent":null,"children":[{"krate":0,"index":2714},{"krate":0,"index":2719},{"krate":0,"index":2728},{"krate":0,"index":2735},{"krate":0,"index":2740},{"krate":0,"index":2749},{"krate":0,"index":2758},{"krate":0,"index":2764},{"krate":0,"index":2773},{"krate":0,"index":2780},{"krate":0,"index":2789},{"krate":0,"index":2798},{"krate":0,"index":2808},{"krate":0,"index":2826},{"krate":0,"index":2833},{"krate":0,"index":2840},{"krate":0,"index":2859},{"krate":0,"index":2866},{"krate":0,"index":2871},{"krate":0,"index":2880},{"krate":0,"index":2884},{"krate":0,"index":2888},{"krate":0,"index":2893},{"krate":0,"index":2902},{"krate":0,"index":2911},{"krate":0,"index":2917},{"krate":0,"index":2924},{"krate":0,"index":2933},{"krate":0,"index":2940},{"krate":0,"index":2947},{"krate":0,"index":2956},{"krate":0,"index":2961},{"krate":0,"index":2972},{"krate":0,"index":2979},{"krate":0,"index":2988}],"decl_id":null,"docs":"#Random Number Distributions","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2714},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/bernoulli.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"bernoulli","qualname":"::randist::bernoulli","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/bernoulli.rs","parent":null,"children":[{"krate":0,"index":2715},{"krate":0,"index":2716},{"krate":0,"index":2717},{"krate":0,"index":2718}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2717},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/bernoulli.rs","byte_start":368915,"byte_end":368924,"line_start":12,"line_end":12,"column_start":8,"column_end":17},"name":"bernoulli","qualname":"::randist::bernoulli::bernoulli","value":"fn (r: &mut Rng, p: f64) -> u32","parent":null,"children":[],"decl_id":null,"docs":" This function returns either 0 or 1, the result of a Bernoulli trial with probability p. The probability distribution for a Bernoulli trial is,\n \n p(0) = 1 - p\n p(1) = p\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2718},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/bernoulli.rs","byte_start":369188,"byte_end":369201,"line_start":17,"line_end":17,"column_start":8,"column_end":21},"name":"bernoulli_pdf","qualname":"::randist::bernoulli::bernoulli_pdf","value":"fn (x: u32, p: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the probability p(k) of obtaining k from a Bernoulli distribution with probability parameter p, using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2719},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/beta.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"beta","qualname":"::randist::beta","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/beta.rs","parent":null,"children":[{"krate":0,"index":2720},{"krate":0,"index":2721},{"krate":0,"index":2722},{"krate":0,"index":2723},{"krate":0,"index":2724},{"krate":0,"index":2725},{"krate":0,"index":2726},{"krate":0,"index":2727}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2722},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/beta.rs","byte_start":369608,"byte_end":369612,"line_start":13,"line_end":13,"column_start":8,"column_end":12},"name":"beta","qualname":"::randist::beta::beta","value":"fn (r: &mut Rng, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random variate from the beta distribution. The distribution function is,\n \n p(x) dx = {Gamma(a+b) over Gamma(a) Gamma(b)} x^{a-1} (1-x)^{b-1} dx\n \n for 0 <= x <= 1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2723},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/beta.rs","byte_start":369869,"byte_end":369877,"line_start":18,"line_end":18,"column_start":8,"column_end":16},"name":"beta_pdf","qualname":"::randist::beta::beta_pdf","value":"fn (x: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the probability density p(x) at x for a beta distribution with parameters a and b, using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2724},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/beta.rs","byte_start":370113,"byte_end":370119,"line_start":23,"line_end":23,"column_start":8,"column_end":14},"name":"beta_P","qualname":"::randist::beta::beta_P","value":"fn (x: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the beta distribution with parameters a and b.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2725},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/beta.rs","byte_start":370353,"byte_end":370359,"line_start":28,"line_end":28,"column_start":8,"column_end":14},"name":"beta_Q","qualname":"::randist::beta::beta_Q","value":"fn (x: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the beta distribution with parameters a and b.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2726},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/beta.rs","byte_start":370593,"byte_end":370602,"line_start":33,"line_end":33,"column_start":8,"column_end":17},"name":"beta_Pinv","qualname":"::randist::beta::beta_Pinv","value":"fn (P: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the beta distribution with parameters a and b.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2727},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/beta.rs","byte_start":370839,"byte_end":370848,"line_start":38,"line_end":38,"column_start":8,"column_end":17},"name":"beta_Qinv","qualname":"::randist::beta::beta_Qinv","value":"fn (Q: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the beta distribution with parameters a and b.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2728},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/binomial.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"binomial","qualname":"::randist::binomial","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/binomial.rs","parent":null,"children":[{"krate":0,"index":2729},{"krate":0,"index":2730},{"krate":0,"index":2731},{"krate":0,"index":2732},{"krate":0,"index":2733},{"krate":0,"index":2734}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2731},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/binomial.rs","byte_start":371335,"byte_end":371343,"line_start":13,"line_end":13,"column_start":8,"column_end":16},"name":"binomial","qualname":"::randist::binomial::binomial","value":"fn (r: &mut Rng, p: f64, n: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random integer from the binomial distribution, the number of successes in n independent trials with probability p. The probability distribution for binomial variates is,\n \n p(k) = {n! \\over k! (n-k)! } p^k (1-p)^{n-k}\n \n for 0 <= k <= n.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2732},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/binomial.rs","byte_start":371611,"byte_end":371623,"line_start":18,"line_end":18,"column_start":8,"column_end":20},"name":"binomial_pdf","qualname":"::randist::binomial::binomial_pdf","value":"fn (k: u32, p: f64, n: u32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the probability p(k) of obtaining k from a binomial distribution with parameters p and n, using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2733},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/binomial.rs","byte_start":371848,"byte_end":371858,"line_start":23,"line_end":23,"column_start":8,"column_end":18},"name":"binomial_P","qualname":"::randist::binomial::binomial_P","value":"fn (k: u32, p: f64, n: u32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(k), Q(k) for the binomial distribution with parameters p and n.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2734},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/binomial.rs","byte_start":372081,"byte_end":372091,"line_start":28,"line_end":28,"column_start":8,"column_end":18},"name":"binomial_Q","qualname":"::randist::binomial::binomial_Q","value":"fn (k: u32, p: f64, n: u32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(k), Q(k) for the binomial distribution with parameters p and n.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2735},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/bivariate_gaussian.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"bivariate_gaussian","qualname":"::randist::bivariate_gaussian","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/bivariate_gaussian.rs","parent":null,"children":[{"krate":0,"index":2736},{"krate":0,"index":2737},{"krate":0,"index":2738},{"krate":0,"index":2739}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2738},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/bivariate_gaussian.rs","byte_start":372837,"byte_end":372850,"line_start":14,"line_end":14,"column_start":8,"column_end":21},"name":"gaussian_tail","qualname":"::randist::bivariate_gaussian::gaussian_tail","value":"fn (r: &mut Rng, sigma_x: f64, sigma_y: f64, rho: f64, x: &mut f64, y: &mut f64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function generates a pair of correlated Gaussian variates, with mean zero, correlation coefficient rho and standard deviations sigma_x and sigma_y in the x and y directions.\n The probability distribution for bivariate Gaussian random variates is,\n \n p(x,y) dx dy = {1 \\over 2 \\pi \\sigma_x \\sigma_y \\sqrt{1-\\rho^2}} \\exp (-(x^2/\\sigma_x^2 + y^2/\\sigma_y^2 - 2 \\rho x y/(\\sigma_x\\sigma_y))/2(1-\\rho^2)) dx dy\n \n for x,y in the range -\\infty to +\\infty. The correlation coefficient rho should lie between 1 and -1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2739},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/bivariate_gaussian.rs","byte_start":373255,"byte_end":373272,"line_start":19,"line_end":19,"column_start":8,"column_end":25},"name":"gaussian_tail_pdf","qualname":"::randist::bivariate_gaussian::gaussian_tail_pdf","value":"fn (x: f64, y: f64, sigma_x: f64, sigma_y: f64, rho: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the probability density p(x,y) at (x,y) for a bivariate Gaussian distribution with standard deviations sigma_x, sigma_y and correlation coefficient rho, using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2740},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/cauchy.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"cauchy","qualname":"::randist::cauchy","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/cauchy.rs","parent":null,"children":[{"krate":0,"index":2741},{"krate":0,"index":2742},{"krate":0,"index":2743},{"krate":0,"index":2744},{"krate":0,"index":2745},{"krate":0,"index":2746},{"krate":0,"index":2747},{"krate":0,"index":2748}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2743},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/cauchy.rs","byte_start":373867,"byte_end":373873,"line_start":13,"line_end":13,"column_start":8,"column_end":14},"name":"cauchy","qualname":"::randist::cauchy::cauchy","value":"fn (r: &mut Rng, a: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random variate from the Cauchy distribution with scale parameter a. The probability distribution for Cauchy random variates is,\n \n p(x) dx = {1 \\over a\\pi (1 + (x/a)^2) } dx\n \n for x in the range -\\infty to +\\infty. The Cauchy distribution is also known as the Lorentz distribution.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2744},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/cauchy.rs","byte_start":374122,"byte_end":374132,"line_start":18,"line_end":18,"column_start":8,"column_end":18},"name":"cauchy_pdf","qualname":"::randist::cauchy::cauchy_pdf","value":"fn (x: f64, a: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the probability density p(x) at x for a Cauchy distribution with scale parameter a, using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2745},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/cauchy.rs","byte_start":374360,"byte_end":374368,"line_start":23,"line_end":23,"column_start":8,"column_end":16},"name":"cauchy_P","qualname":"::randist::cauchy::cauchy_P","value":"fn (x: f64, a: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Cauchy distribution with scale parameter a.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2746},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/cauchy.rs","byte_start":374594,"byte_end":374602,"line_start":28,"line_end":28,"column_start":8,"column_end":16},"name":"cauchy_Q","qualname":"::randist::cauchy::cauchy_Q","value":"fn (x: f64, a: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Cauchy distribution with scale parameter a.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2747},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/cauchy.rs","byte_start":374828,"byte_end":374839,"line_start":33,"line_end":33,"column_start":8,"column_end":19},"name":"cauchy_Pinv","qualname":"::randist::cauchy::cauchy_Pinv","value":"fn (P: f64, a: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Cauchy distribution with scale parameter a.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2748},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/cauchy.rs","byte_start":375068,"byte_end":375079,"line_start":38,"line_end":38,"column_start":8,"column_end":19},"name":"cauchy_Qinv","qualname":"::randist::cauchy::cauchy_Qinv","value":"fn (Q: f64, a: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Cauchy distribution with scale parameter a.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2749},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/chi_squared.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"chi_squared","qualname":"::randist::chi_squared","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/chi_squared.rs","parent":null,"children":[{"krate":0,"index":2750},{"krate":0,"index":2751},{"krate":0,"index":2752},{"krate":0,"index":2753},{"krate":0,"index":2754},{"krate":0,"index":2755},{"krate":0,"index":2756},{"krate":0,"index":2757}],"decl_id":null,"docs":"The chi-squared distribution arises in statistics. If Y_i are n independent Gaussian random variates with unit variance then the sum-of-squares,","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2752},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/chi_squared.rs","byte_start":375746,"byte_end":375751,"line_start":21,"line_end":21,"column_start":8,"column_end":13},"name":"chisq","qualname":"::randist::chi_squared::chisq","value":"fn (r: &mut Rng, nu: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random variate from the chi-squared distribution with nu degrees of freedom. The distribution function is,\n \n p(x) dx = {1 \\over 2 Gamma(\\nu/2) } (x/2)^{\\nu/2 - 1} \\exp(-x/2) dx\n \n for x >= 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2753},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/chi_squared.rs","byte_start":376010,"byte_end":376019,"line_start":26,"line_end":26,"column_start":8,"column_end":17},"name":"chisq_pdf","qualname":"::randist::chi_squared::chisq_pdf","value":"fn (x: f64, nu: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the probability density p(x) at x for a chi-squared distribution with nu degrees of freedom, using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2754},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/chi_squared.rs","byte_start":376257,"byte_end":376264,"line_start":31,"line_end":31,"column_start":8,"column_end":15},"name":"chisq_P","qualname":"::randist::chi_squared::chisq_P","value":"fn (x: f64, nu: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the chi-squared distribution with nu degrees of freedom.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2755},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/chi_squared.rs","byte_start":376500,"byte_end":376507,"line_start":36,"line_end":36,"column_start":8,"column_end":15},"name":"chisq_Q","qualname":"::randist::chi_squared::chisq_Q","value":"fn (x: f64, nu: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the chi-squared distribution with nu degrees of freedom.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2756},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/chi_squared.rs","byte_start":376743,"byte_end":376753,"line_start":41,"line_end":41,"column_start":8,"column_end":18},"name":"chisq_Pinv","qualname":"::randist::chi_squared::chisq_Pinv","value":"fn (P: f64, nu: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the chi-squared distribution with nu degrees of freedom.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2757},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/chi_squared.rs","byte_start":376992,"byte_end":377002,"line_start":46,"line_end":46,"column_start":8,"column_end":18},"name":"chisq_Qinv","qualname":"::randist::chi_squared::chisq_Qinv","value":"fn (Q: f64, nu: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the chi-squared distribution with nu degrees of freedom.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2758},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/dirichlet.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"dirichlet","qualname":"::randist::dirichlet","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/dirichlet.rs","parent":null,"children":[{"krate":0,"index":2759},{"krate":0,"index":2760},{"krate":0,"index":2761},{"krate":0,"index":2762},{"krate":0,"index":2763}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2761},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/dirichlet.rs","byte_start":377920,"byte_end":377929,"line_start":19,"line_end":19,"column_start":8,"column_end":17},"name":"dirichlet","qualname":"::randist::dirichlet::dirichlet","value":"fn (r: &mut Rng, alpha: &[f64], theta: &mut [f64]) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function returns an array of K random variates from a Dirichlet distribution of order K-1. The distribution function is\n \n p(\\theta_1, ..., \\theta_K) d\\theta_1 ... d\\theta_K = \n \n   (1/Z) \\prod_{i=1}^K \\theta_i^{\\alpha_i - 1} \\delta(1 -\\sum_{i=1}^K \\theta_i) d\\theta_1 ... d\\theta_K\n \n for theta_i >= 0 and alpha_i > 0. The delta function ensures that \\sum \\theta_i = 1. The normalization factor Z is\n \n Z = {\\prod_{i=1}^K \\Gamma(\\alpha_i)} / {\\Gamma( \\sum_{i=1}^K \\alpha_i)}\n \n The random variates are generated by sampling K values from gamma distributions with parameters a=alpha_i, b=1, and renormalizing. See A.M. Law, W.D. Kelton, Simulation Modeling and Analysis (1991).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2762},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/dirichlet.rs","byte_start":378281,"byte_end":378294,"line_start":24,"line_end":24,"column_start":8,"column_end":21},"name":"dirichlet_pdf","qualname":"::randist::dirichlet::dirichlet_pdf","value":"fn (alpha: &[f64], theta: &[f64]) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the probability density p(\\theta_1, ... , \\theta_K) at theta[K] for a Dirichlet distribution with parameters alpha[K], using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2763},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/dirichlet.rs","byte_start":378582,"byte_end":378597,"line_start":29,"line_end":29,"column_start":8,"column_end":23},"name":"dirichlet_lnpdf","qualname":"::randist::dirichlet::dirichlet_lnpdf","value":"fn (alpha: &[f64], theta: &[f64]) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the logarithm of the probability density p(\\theta_1, ... , \\theta_K) for a Dirichlet distribution with parameters alpha[K].\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2764},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/exponential.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"exponential","qualname":"::randist::exponential","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/exponential.rs","parent":null,"children":[{"krate":0,"index":2765},{"krate":0,"index":2766},{"krate":0,"index":2767},{"krate":0,"index":2768},{"krate":0,"index":2769},{"krate":0,"index":2770},{"krate":0,"index":2771},{"krate":0,"index":2772}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2767},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/exponential.rs","byte_start":379036,"byte_end":379047,"line_start":13,"line_end":13,"column_start":8,"column_end":19},"name":"exponential","qualname":"::randist::exponential::exponential","value":"fn (r: &mut Rng, mu: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random variate from the exponential distribution with mean mu. The distribution is,\n \n p(x) dx = {1 \\over \\mu} \\exp(-x/\\mu) dx\n \n for x >= 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2768},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/exponential.rs","byte_start":379299,"byte_end":379314,"line_start":18,"line_end":18,"column_start":8,"column_end":23},"name":"exponential_pdf","qualname":"::randist::exponential::exponential_pdf","value":"fn (x: f64, mu: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the probability density p(x) at x for an exponential distribution with mean mu, using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2769},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/exponential.rs","byte_start":379544,"byte_end":379557,"line_start":23,"line_end":23,"column_start":8,"column_end":21},"name":"exponential_P","qualname":"::randist::exponential::exponential_P","value":"fn (x: f64, mu: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the exponential distribution with mean mu.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2770},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/exponential.rs","byte_start":379785,"byte_end":379798,"line_start":28,"line_end":28,"column_start":8,"column_end":21},"name":"exponential_Q","qualname":"::randist::exponential::exponential_Q","value":"fn (x: f64, mu: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the exponential distribution with mean mu.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2771},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/exponential.rs","byte_start":379884,"byte_end":379900,"line_start":32,"line_end":32,"column_start":8,"column_end":24},"name":"exponential_Pinv","qualname":"::randist::exponential::exponential_Pinv","value":"fn (P: f64, mu: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2772},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/exponential.rs","byte_start":380131,"byte_end":380147,"line_start":37,"line_end":37,"column_start":8,"column_end":24},"name":"exponential_Qinv","qualname":"::randist::exponential::exponential_Qinv","value":"fn (Q: f64, mu: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the exponential distribution with mean mu.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2773},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/exponential_power.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"exponential_power","qualname":"::randist::exponential_power","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/exponential_power.rs","parent":null,"children":[{"krate":0,"index":2774},{"krate":0,"index":2775},{"krate":0,"index":2776},{"krate":0,"index":2777},{"krate":0,"index":2778},{"krate":0,"index":2779}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2776},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/exponential_power.rs","byte_start":380723,"byte_end":380729,"line_start":13,"line_end":13,"column_start":8,"column_end":14},"name":"exppow","qualname":"::randist::exponential_power::exppow","value":"fn (r: &mut Rng, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random variate from the exponential power distribution with scale parameter a and exponent b. The distribution is,\n \n p(x) dx = {1 \\over 2 a Gamma(1+1/b)} \\exp(-|x/a|^b) dx\n \n for x >= 0. For b = 1 this reduces to the Laplace distribution. For b = 2 it has the same form as a Gaussian distribution, but with a = \\sqrt{2} \\sigma.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2777},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/exponential_power.rs","byte_start":381016,"byte_end":381026,"line_start":18,"line_end":18,"column_start":8,"column_end":18},"name":"exppow_pdf","qualname":"::randist::exponential_power::exppow_pdf","value":"fn (x: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the probability density p(x) at x for an exponential power distribution with scale parameter a and exponent b, using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2778},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/exponential_power.rs","byte_start":381259,"byte_end":381267,"line_start":23,"line_end":23,"column_start":8,"column_end":16},"name":"exppow_P","qualname":"::randist::exponential_power::exppow_P","value":"fn (x: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes tthe cumulative distribution functions P(x), Q(x) for the exponential power distribution with parameters a and b.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2779},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/exponential_power.rs","byte_start":381498,"byte_end":381506,"line_start":28,"line_end":28,"column_start":8,"column_end":16},"name":"exppow_Q","qualname":"::randist::exponential_power::exppow_Q","value":"fn (x: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes tthe cumulative distribution functions P(x), Q(x) for the exponential power distribution with parameters a and b.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2780},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/f_distribution.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"f_distribution","qualname":"::randist::f_distribution","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/f_distribution.rs","parent":null,"children":[{"krate":0,"index":2781},{"krate":0,"index":2782},{"krate":0,"index":2783},{"krate":0,"index":2784},{"krate":0,"index":2785},{"krate":0,"index":2786},{"krate":0,"index":2787},{"krate":0,"index":2788}],"decl_id":null,"docs":"The F-distribution arises in statistics. If Y_1 and Y_2 are chi-squared deviates with \\nu_1 and \\nu_2 degrees of freedom then the ratio,","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2783},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/f_distribution.rs","byte_start":382324,"byte_end":382329,"line_start":30,"line_end":30,"column_start":8,"column_end":13},"name":"fdist","qualname":"::randist::f_distribution::fdist","value":"fn (r: &mut Rng, nu1: f64, nu2: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random variate from the F-distribution with degrees of freedom nu1 and nu2. The distribution function is,","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2784},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/f_distribution.rs","byte_start":382609,"byte_end":382618,"line_start":35,"line_end":35,"column_start":8,"column_end":17},"name":"fdist_pdf","qualname":"::randist::f_distribution::fdist_pdf","value":"fn (x: f64, nu1: f64, nu2: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the F-distribution with nu1 and nu2 degrees of freedom.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2785},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/f_distribution.rs","byte_start":382872,"byte_end":382879,"line_start":40,"line_end":40,"column_start":8,"column_end":15},"name":"fdist_P","qualname":"::randist::f_distribution::fdist_P","value":"fn (x: f64, nu1: f64, nu2: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the F-distribution with nu1 and nu2 degrees of freedom.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2786},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/f_distribution.rs","byte_start":383131,"byte_end":383138,"line_start":45,"line_end":45,"column_start":8,"column_end":15},"name":"fdist_Q","qualname":"::randist::f_distribution::fdist_Q","value":"fn (x: f64, nu1: f64, nu2: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the F-distribution with nu1 and nu2 degrees of freedom.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2787},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/f_distribution.rs","byte_start":383390,"byte_end":383400,"line_start":50,"line_end":50,"column_start":8,"column_end":18},"name":"fdist_Pinv","qualname":"::randist::f_distribution::fdist_Pinv","value":"fn (P: f64, nu1: f64, nu2: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the F-distribution with nu1 and nu2 degrees of freedom.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2788},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/f_distribution.rs","byte_start":383655,"byte_end":383665,"line_start":55,"line_end":55,"column_start":8,"column_end":18},"name":"fdist_Qinv","qualname":"::randist::f_distribution::fdist_Qinv","value":"fn (Q: f64, nu1: f64, nu2: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the F-distribution with nu1 and nu2 degrees of freedom.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2789},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/flat.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"flat","qualname":"::randist::flat","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/flat.rs","parent":null,"children":[{"krate":0,"index":2790},{"krate":0,"index":2791},{"krate":0,"index":2792},{"krate":0,"index":2793},{"krate":0,"index":2794},{"krate":0,"index":2795},{"krate":0,"index":2796},{"krate":0,"index":2797}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2792},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/flat.rs","byte_start":384076,"byte_end":384080,"line_start":13,"line_end":13,"column_start":8,"column_end":12},"name":"flat","qualname":"::randist::flat::flat","value":"fn (r: &mut Rng, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random variate from the flat (uniform) distribution from a to b. The distribution is,\n \n p(x) dx = {1 \\over (b-a)} dx\n \n if a <= x < b and 0 otherwise.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2793},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/flat.rs","byte_start":384328,"byte_end":384336,"line_start":18,"line_end":18,"column_start":8,"column_end":16},"name":"flat_pdf","qualname":"::randist::flat::flat_pdf","value":"fn (x: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the probability density p(x) at x for a uniform distribution from a to b, using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2794},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/flat.rs","byte_start":384561,"byte_end":384567,"line_start":23,"line_end":23,"column_start":8,"column_end":14},"name":"flat_P","qualname":"::randist::flat::flat_P","value":"fn (x: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for a uniform distribution from a to b.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2795},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/flat.rs","byte_start":384790,"byte_end":384796,"line_start":28,"line_end":28,"column_start":8,"column_end":14},"name":"flat_Q","qualname":"::randist::flat::flat_Q","value":"fn (x: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for a uniform distribution from a to b.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2796},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/flat.rs","byte_start":385019,"byte_end":385028,"line_start":33,"line_end":33,"column_start":8,"column_end":17},"name":"flat_Pinv","qualname":"::randist::flat::flat_Pinv","value":"fn (P: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for a uniform distribution from a to b.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2797},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/flat.rs","byte_start":385254,"byte_end":385263,"line_start":38,"line_end":38,"column_start":8,"column_end":17},"name":"flat_Qinv","qualname":"::randist::flat::flat_Qinv","value":"fn (Q: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for a uniform distribution from a to b.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2798},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gamma.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"gamma","qualname":"::randist::gamma","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gamma.rs","parent":null,"children":[{"krate":0,"index":2799},{"krate":0,"index":2800},{"krate":0,"index":2801},{"krate":0,"index":2802},{"krate":0,"index":2803},{"krate":0,"index":2804},{"krate":0,"index":2805},{"krate":0,"index":2806},{"krate":0,"index":2807}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2801},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gamma.rs","byte_start":385944,"byte_end":385949,"line_start":17,"line_end":17,"column_start":8,"column_end":13},"name":"gamma","qualname":"::randist::gamma::gamma","value":"fn (r: &mut Rng, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random variate from the gamma distribution. The distribution function is,\n \n p(x) dx = {1 over Gamma(a) b^a} x^{a-1} e^{-x/b} dx\n \n for x > 0.\n \n The gamma distribution with an integer parameter a is known as the Erlang distribution.\n \n The variates are computed using the Marsaglia-Tsang fast gamma method. This function for this method was previously called gsl_ran_gamma_mt and can still be accessed using this name.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2802},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gamma.rs","byte_start":386149,"byte_end":386160,"line_start":22,"line_end":22,"column_start":8,"column_end":19},"name":"gamma_knuth","qualname":"::randist::gamma::gamma_knuth","value":"fn (r: &mut Rng, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns a gamma variate using the algorithms from Knuth (vol 2).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2803},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gamma.rs","byte_start":386425,"byte_end":386434,"line_start":27,"line_end":27,"column_start":8,"column_end":17},"name":"gamma_pdf","qualname":"::randist::gamma::gamma_pdf","value":"fn (x: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the probability density p(x) at x for a gamma distribution with parameters a and b, using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2804},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gamma.rs","byte_start":386690,"byte_end":386697,"line_start":32,"line_end":32,"column_start":8,"column_end":15},"name":"gamma_P","qualname":"::randist::gamma::gamma_P","value":"fn (x: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes This function computes the probability density p(x) at x for a gamma distribution with parameters a and b, using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2805},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gamma.rs","byte_start":386951,"byte_end":386958,"line_start":37,"line_end":37,"column_start":8,"column_end":15},"name":"gamma_Q","qualname":"::randist::gamma::gamma_Q","value":"fn (x: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes This function computes the probability density p(x) at x for a gamma distribution with parameters a and b, using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2806},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gamma.rs","byte_start":387212,"byte_end":387222,"line_start":42,"line_end":42,"column_start":8,"column_end":18},"name":"gamma_Pinv","qualname":"::randist::gamma::gamma_Pinv","value":"fn (P: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes This function computes the probability density p(x) at x for a gamma distribution with parameters a and b, using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2807},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gamma.rs","byte_start":387479,"byte_end":387489,"line_start":47,"line_end":47,"column_start":8,"column_end":18},"name":"gamma_Qinv","qualname":"::randist::gamma::gamma_Qinv","value":"fn (Q: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes This function computes the probability density p(x) at x for a gamma distribution with parameters a and b, using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2808},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gaussian.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"gaussian","qualname":"::randist::gaussian","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gaussian.rs","parent":null,"children":[{"krate":0,"index":2809},{"krate":0,"index":2810},{"krate":0,"index":2811},{"krate":0,"index":2812},{"krate":0,"index":2813},{"krate":0,"index":2814},{"krate":0,"index":2815},{"krate":0,"index":2816},{"krate":0,"index":2817},{"krate":0,"index":2818},{"krate":0,"index":2819},{"krate":0,"index":2820},{"krate":0,"index":2821},{"krate":0,"index":2822},{"krate":0,"index":2823},{"krate":0,"index":2824},{"krate":0,"index":2825}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2811},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gaussian.rs","byte_start":388219,"byte_end":388227,"line_start":14,"line_end":14,"column_start":8,"column_end":16},"name":"gaussian","qualname":"::randist::gaussian::gaussian","value":"fn (r: &mut Rng, sigma: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns a Gaussian random variate, with mean zero and standard deviation sigma.\n The probability distribution for Gaussian random variates is,\n \n p(x) dx = {1 \\over \\sqrt{2 \\pi \\sigma^2}} \\exp (-x^2 / 2\\sigma^2) dx\n for x in the range -\\infty to +\\infty. Use the transformation z = \\mu + x on the numbers returned by gsl_ran_gaussian to obtain a Gaussian distribution with mean \\mu.\n This function uses the Box-Muller algorithm which requires two calls to the random number generator r.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2812},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gaussian.rs","byte_start":388495,"byte_end":388507,"line_start":19,"line_end":19,"column_start":8,"column_end":20},"name":"gaussian_pdf","qualname":"::randist::gaussian::gaussian_pdf","value":"fn (x: f64, sigma: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the probability density p(x) at x for a Gaussian distribution with standard deviation sigma, using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2813},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gaussian.rs","byte_start":388598,"byte_end":388615,"line_start":23,"line_end":23,"column_start":8,"column_end":25},"name":"gaussian_ziggurat","qualname":"::randist::gaussian::gaussian_ziggurat","value":"fn (r: &mut Rng, sigma: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2814},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gaussian.rs","byte_start":388960,"byte_end":388981,"line_start":29,"line_end":29,"column_start":8,"column_end":29},"name":"gaussian_ratio_method","qualname":"::randist::gaussian::gaussian_ratio_method","value":"fn (r: &mut Rng, sigma: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes a Gaussian random variate using the alternative Marsaglia-Tsang ziggurat and Kinderman-Monahan-Leva ratio methods.\n The Ziggurat algorithm is the fastest available algorithm in most cases.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2815},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gaussian.rs","byte_start":389274,"byte_end":389283,"line_start":35,"line_end":35,"column_start":8,"column_end":17},"name":"ugaussian","qualname":"::randist::gaussian::ugaussian","value":"fn (r: &mut Rng) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes results for the unit Gaussian distribution.\n They are equivalent to the functions above with a standard deviation of one, sigma = 1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2816},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gaussian.rs","byte_start":389545,"byte_end":389558,"line_start":41,"line_end":41,"column_start":8,"column_end":21},"name":"ugaussian_pdf","qualname":"::randist::gaussian::ugaussian_pdf","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes results for the unit Gaussian distribution.\n They are equivalent to the functions above with a standard deviation of one, sigma = 1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2817},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gaussian.rs","byte_start":389794,"byte_end":389816,"line_start":47,"line_end":47,"column_start":8,"column_end":30},"name":"ugaussian_ratio_method","qualname":"::randist::gaussian::ugaussian_ratio_method","value":"fn (r: &mut Rng) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes results for the unit Gaussian distribution.\n They are equivalent to the functions above with a standard deviation of one, sigma = 1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2818},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gaussian.rs","byte_start":390084,"byte_end":390094,"line_start":52,"line_end":52,"column_start":8,"column_end":18},"name":"gaussian_P","qualname":"::randist::gaussian::gaussian_P","value":"fn (x: f64, sigma: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Gaussian distribution with standard deviation sigma.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2819},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gaussian.rs","byte_start":390339,"byte_end":390349,"line_start":57,"line_end":57,"column_start":8,"column_end":18},"name":"gaussian_Q","qualname":"::randist::gaussian::gaussian_Q","value":"fn (x: f64, sigma: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Gaussian distribution with standard deviation sigma.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2820},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gaussian.rs","byte_start":390594,"byte_end":390607,"line_start":62,"line_end":62,"column_start":8,"column_end":21},"name":"gaussian_Pinv","qualname":"::randist::gaussian::gaussian_Pinv","value":"fn (P: f64, sigma: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Gaussian distribution with standard deviation sigma.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2821},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gaussian.rs","byte_start":390855,"byte_end":390868,"line_start":67,"line_end":67,"column_start":8,"column_end":21},"name":"gaussian_Qinv","qualname":"::randist::gaussian::gaussian_Qinv","value":"fn (Q: f64, sigma: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Gaussian distribution with standard deviation sigma.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2822},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gaussian.rs","byte_start":391091,"byte_end":391102,"line_start":72,"line_end":72,"column_start":8,"column_end":19},"name":"ugaussian_P","qualname":"::randist::gaussian::ugaussian_P","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the unit Gaussian distribution.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2823},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gaussian.rs","byte_start":391304,"byte_end":391315,"line_start":77,"line_end":77,"column_start":8,"column_end":19},"name":"ugaussian_Q","qualname":"::randist::gaussian::ugaussian_Q","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the unit Gaussian distribution.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2824},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gaussian.rs","byte_start":391517,"byte_end":391531,"line_start":82,"line_end":82,"column_start":8,"column_end":22},"name":"ugaussian_Pinv","qualname":"::randist::gaussian::ugaussian_Pinv","value":"fn (P: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the unit Gaussian distribution.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2825},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gaussian.rs","byte_start":391736,"byte_end":391750,"line_start":87,"line_end":87,"column_start":8,"column_end":22},"name":"ugaussian_Qinv","qualname":"::randist::gaussian::ugaussian_Qinv","value":"fn (Q: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the unit Gaussian distribution.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2826},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gaussian_tail.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"gaussian_tail","qualname":"::randist::gaussian_tail","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gaussian_tail.rs","parent":null,"children":[{"krate":0,"index":2827},{"krate":0,"index":2828},{"krate":0,"index":2829},{"krate":0,"index":2830},{"krate":0,"index":2831},{"krate":0,"index":2832}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2829},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gaussian_tail.rs","byte_start":392627,"byte_end":392640,"line_start":18,"line_end":18,"column_start":8,"column_end":21},"name":"gaussian_tail","qualname":"::randist::gaussian_tail::gaussian_tail","value":"fn (r: &mut Rng, a: f64, sigma: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function provides random variates from the upper tail of a Gaussian distribution with standard deviation sigma.\n The values returned are larger than the lower limit a, which must be positive. The method is based on Marsaglia’s famous rectangle-wedge-tail algorithm (Ann. Math. Stat. 32, 894–899 (1961)), with this aspect explained in Knuth, v2, 3rd ed, p139,586 (exercise 11).\n \n The probability distribution for Gaussian tail random variates is,\n \n p(x) dx = {1 \\over N(a;\\sigma) \\sqrt{2 \\pi \\sigma^2}} \\exp (- x^2/(2 \\sigma^2)) dx\n \n for x > a where N(a;\\sigma) is the normalization constant,\n \n N(a;\\sigma) = (1/2) erfc(a / sqrt(2 sigma^2)).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2830},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gaussian_tail.rs","byte_start":392947,"byte_end":392964,"line_start":23,"line_end":23,"column_start":8,"column_end":25},"name":"gaussian_tail_pdf","qualname":"::randist::gaussian_tail::gaussian_tail_pdf","value":"fn (x: f64, a: f64, sigma: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the probability density p(x) at x for a Gaussian tail distribution with standard deviation sigma and lower limit a, using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2831},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gaussian_tail.rs","byte_start":393240,"byte_end":393254,"line_start":28,"line_end":28,"column_start":8,"column_end":22},"name":"ugaussian_tail","qualname":"::randist::gaussian_tail::ugaussian_tail","value":"fn (r: &mut Rng, a: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes results for the tail of a unit Gaussian distribution. They are equivalent to the functions above with a standard deviation of one, sigma = 1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2832},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gaussian_tail.rs","byte_start":393538,"byte_end":393556,"line_start":33,"line_end":33,"column_start":8,"column_end":26},"name":"ugaussian_tail_pdf","qualname":"::randist::gaussian_tail::ugaussian_tail_pdf","value":"fn (x: f64, a: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes results for the tail of a unit Gaussian distribution. They are equivalent to the functions above with a standard deviation of one, sigma = 1.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2833},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/geometric.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"geometric","qualname":"::randist::geometric","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/geometric.rs","parent":null,"children":[{"krate":0,"index":2834},{"krate":0,"index":2835},{"krate":0,"index":2836},{"krate":0,"index":2837},{"krate":0,"index":2838},{"krate":0,"index":2839}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2836},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/geometric.rs","byte_start":394165,"byte_end":394174,"line_start":14,"line_end":14,"column_start":8,"column_end":17},"name":"geometric","qualname":"::randist::geometric::geometric","value":"fn (r: &mut Rng, p: f64) -> u32","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random integer from the geometric distribution, the number of independent trials with probability p until the first success.\n The probability distribution for geometric variates is,\n \n p(k) =  p (1-p)^(k-1)\n \n for k >= 1. Note that the distribution begins with k=1 with this definition. There is another convention in which the exponent k-1 is replaced by k.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2837},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/geometric.rs","byte_start":394438,"byte_end":394451,"line_start":19,"line_end":19,"column_start":8,"column_end":21},"name":"geometric_pdf","qualname":"::randist::geometric::geometric_pdf","value":"fn (k: u32, p: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the probability p(k) of obtaining k from a geometric distribution with probability parameter p, using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2838},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/geometric.rs","byte_start":394660,"byte_end":394671,"line_start":24,"line_end":24,"column_start":8,"column_end":19},"name":"geometric_P","qualname":"::randist::geometric::geometric_P","value":"fn (k: u32, p: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(k), Q(k) for the geometric distribution with parameter p.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2839},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/geometric.rs","byte_start":394878,"byte_end":394889,"line_start":29,"line_end":29,"column_start":8,"column_end":19},"name":"geometric_Q","qualname":"::randist::geometric::geometric_Q","value":"fn (k: u32, p: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(k), Q(k) for the geometric distribution with parameter p.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2840},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gumbel.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"gumbel","qualname":"::randist::gumbel","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gumbel.rs","parent":null,"children":[{"krate":0,"index":2841},{"krate":0,"index":2850}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2841},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gumbel.rs","byte_start":395064,"byte_end":395070,"line_start":5,"line_end":5,"column_start":9,"column_end":15},"name":"type_1","qualname":"::randist::gumbel::type_1","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gumbel.rs","parent":null,"children":[{"krate":0,"index":2842},{"krate":0,"index":2843},{"krate":0,"index":2844},{"krate":0,"index":2845},{"krate":0,"index":2846},{"krate":0,"index":2847},{"krate":0,"index":2848},{"krate":0,"index":2849}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2844},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gumbel.rs","byte_start":395349,"byte_end":395356,"line_start":14,"line_end":14,"column_start":12,"column_end":19},"name":"gumbel1","qualname":"::randist::gumbel::type_1::gumbel1","value":"fn (r: &mut Rng, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random variate from the Type-1 Gumbel distribution. The Type-1 Gumbel distribution function is,\n \n p(x) dx = a b \\exp(-(b \\exp(-ax) + ax)) dx\n \n for -\\infty < x < \\infty.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2845},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gumbel.rs","byte_start":395641,"byte_end":395652,"line_start":19,"line_end":19,"column_start":12,"column_end":23},"name":"gumbel1_pdf","qualname":"::randist::gumbel::type_1::gumbel1_pdf","value":"fn (x: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the probability density p(x) at x for a Type-1 Gumbel distribution with parameters a and b, using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2846},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gumbel.rs","byte_start":395916,"byte_end":395925,"line_start":24,"line_end":24,"column_start":12,"column_end":21},"name":"gumbel1_P","qualname":"::randist::gumbel::type_1::gumbel1_P","value":"fn (x: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Type-1 Gumbel distribution with parameters a and b.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2847},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gumbel.rs","byte_start":396187,"byte_end":396196,"line_start":29,"line_end":29,"column_start":12,"column_end":21},"name":"gumbel1_Q","qualname":"::randist::gumbel::type_1::gumbel1_Q","value":"fn (x: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Type-1 Gumbel distribution with parameters a and b.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2848},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gumbel.rs","byte_start":396458,"byte_end":396470,"line_start":34,"line_end":34,"column_start":12,"column_end":24},"name":"gumbel1_Pinv","qualname":"::randist::gumbel::type_1::gumbel1_Pinv","value":"fn (P: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Type-1 Gumbel distribution with parameters a and b.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2849},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gumbel.rs","byte_start":396735,"byte_end":396747,"line_start":39,"line_end":39,"column_start":12,"column_end":24},"name":"gumbel1_Qinv","qualname":"::randist::gumbel::type_1::gumbel1_Qinv","value":"fn (Q: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Type-1 Gumbel distribution with parameters a and b.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2850},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gumbel.rs","byte_start":396852,"byte_end":396858,"line_start":44,"line_end":44,"column_start":9,"column_end":15},"name":"type_2","qualname":"::randist::gumbel::type_2","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gumbel.rs","parent":null,"children":[{"krate":0,"index":2851},{"krate":0,"index":2852},{"krate":0,"index":2853},{"krate":0,"index":2854},{"krate":0,"index":2855},{"krate":0,"index":2856},{"krate":0,"index":2857},{"krate":0,"index":2858}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2853},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gumbel.rs","byte_start":397130,"byte_end":397137,"line_start":53,"line_end":53,"column_start":12,"column_end":19},"name":"gumbel2","qualname":"::randist::gumbel::type_2::gumbel2","value":"fn (r: &mut Rng, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random variate from the Type-2 Gumbel distribution. The Type-2 Gumbel distribution function is,\n \n p(x) dx = a b x^{-a-1} \\exp(-b x^{-a}) dx\n \n for 0 < x < \\infty.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2854},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gumbel.rs","byte_start":397422,"byte_end":397433,"line_start":58,"line_end":58,"column_start":12,"column_end":23},"name":"gumbel2_pdf","qualname":"::randist::gumbel::type_2::gumbel2_pdf","value":"fn (x: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the probability density p(x) at x for a Type-2 Gumbel distribution with parameters a and b, using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2855},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gumbel.rs","byte_start":397697,"byte_end":397706,"line_start":63,"line_end":63,"column_start":12,"column_end":21},"name":"gumbel2_P","qualname":"::randist::gumbel::type_2::gumbel2_P","value":"fn (x: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Type-2 Gumbel distribution with parameters a and b.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2856},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gumbel.rs","byte_start":397968,"byte_end":397977,"line_start":68,"line_end":68,"column_start":12,"column_end":21},"name":"gumbel2_Q","qualname":"::randist::gumbel::type_2::gumbel2_Q","value":"fn (x: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Type-2 Gumbel distribution with parameters a and b.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2857},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gumbel.rs","byte_start":398239,"byte_end":398251,"line_start":73,"line_end":73,"column_start":12,"column_end":24},"name":"gumbel2_Pinv","qualname":"::randist::gumbel::type_2::gumbel2_Pinv","value":"fn (P: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Type-2 Gumbel distribution with parameters a and b.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2858},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/gumbel.rs","byte_start":398516,"byte_end":398528,"line_start":78,"line_end":78,"column_start":12,"column_end":24},"name":"gumbel2_Qinv","qualname":"::randist::gumbel::type_2::gumbel2_Qinv","value":"fn (Q: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Type-2 Gumbel distribution with parameters a and b.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2859},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/hypergeometric.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"hypergeometric","qualname":"::randist::hypergeometric","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/hypergeometric.rs","parent":null,"children":[{"krate":0,"index":2860},{"krate":0,"index":2861},{"krate":0,"index":2862},{"krate":0,"index":2863},{"krate":0,"index":2864},{"krate":0,"index":2865}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2862},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/hypergeometric.rs","byte_start":399319,"byte_end":399333,"line_start":16,"line_end":16,"column_start":8,"column_end":22},"name":"hypergeometric","qualname":"::randist::hypergeometric::hypergeometric","value":"fn (r: &mut Rng, n1: u32, n2: u32, t: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random integer from the hypergeometric distribution. The probability distribution for hypergeometric random variates is,\n \n p(k) =  C(n_1, k) C(n_2, t - k) / C(n_1 + n_2, t)\n \n where C(a,b) = a!/(b!(a-b)!) and t <= n_1 + n_2. The domain of k is max(0,t-n_2), ..., min(t,n_1).\n \n If a population contains n_1 elements of “type 1” and n_2 elements of “type 2” then the hypergeometric distribution gives the probability of obtaining\n k elements of “type 1” in t samples from the population without replacement.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2863},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/hypergeometric.rs","byte_start":399630,"byte_end":399648,"line_start":21,"line_end":21,"column_start":8,"column_end":26},"name":"hypergeometric_pdf","qualname":"::randist::hypergeometric::hypergeometric_pdf","value":"fn (k: u32, n1: u32, n2: u32, t: u32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the probability p(k) of obtaining k from a hypergeometric distribution with parameters n1, n2, t, using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2864},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/hypergeometric.rs","byte_start":399905,"byte_end":399921,"line_start":26,"line_end":26,"column_start":8,"column_end":24},"name":"hypergeometric_P","qualname":"::randist::hypergeometric::hypergeometric_P","value":"fn (k: u32, n1: u32, n2: u32, t: u32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(k), Q(k) for the hypergeometric distribution with parameters n1, n2 and t.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2865},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/hypergeometric.rs","byte_start":400176,"byte_end":400192,"line_start":31,"line_end":31,"column_start":8,"column_end":24},"name":"hypergeometric_Q","qualname":"::randist::hypergeometric::hypergeometric_Q","value":"fn (k: u32, n1: u32, n2: u32, t: u32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(k), Q(k) for the hypergeometric distribution with parameters n1, n2 and t.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2866},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/landau.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"landau","qualname":"::randist::landau","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/landau.rs","parent":null,"children":[{"krate":0,"index":2867},{"krate":0,"index":2868},{"krate":0,"index":2869},{"krate":0,"index":2870}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2869},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/landau.rs","byte_start":400869,"byte_end":400875,"line_start":15,"line_end":15,"column_start":8,"column_end":14},"name":"landau","qualname":"::randist::landau::landau","value":"fn (r: &mut Rng) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random variate from the Landau distribution. The probability distribution for Landau random variates is defined analytically by the complex integral,\n \n p(x) = (1/(2 \\pi i)) \\int_{c-i\\infty}^{c+i\\infty} ds exp(s log(s) + x s) \n \n For numerical purposes it is more convenient to use the following equivalent form of the integral,\n \n p(x) = (1/\\pi) \\int_0^\\infty dt \\exp(-t \\log(t) - x t) \\sin(\\pi t).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2870},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/landau.rs","byte_start":401111,"byte_end":401121,"line_start":20,"line_end":20,"column_start":8,"column_end":18},"name":"landau_pdf","qualname":"::randist::landau::landau_pdf","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the probability density p(x) at x for the Landau distribution using an approximation to the formula given above.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2871},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/laplace.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"laplace","qualname":"::randist::laplace","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/laplace.rs","parent":null,"children":[{"krate":0,"index":2872},{"krate":0,"index":2873},{"krate":0,"index":2874},{"krate":0,"index":2875},{"krate":0,"index":2876},{"krate":0,"index":2877},{"krate":0,"index":2878},{"krate":0,"index":2879}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2874},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/laplace.rs","byte_start":401502,"byte_end":401509,"line_start":13,"line_end":13,"column_start":8,"column_end":15},"name":"laplace","qualname":"::randist::laplace::laplace","value":"fn (r: &mut Rng, a: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random variate from the Laplace distribution with width a. The distribution is,\n \n p(x) dx = {1 \\over 2 a}  \\exp(-|x/a|) dx\n \n for -\\infty < x < \\infty.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2875},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/laplace.rs","byte_start":401750,"byte_end":401761,"line_start":18,"line_end":18,"column_start":8,"column_end":19},"name":"laplace_pdf","qualname":"::randist::laplace::laplace_pdf","value":"fn (x: f64, a: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the probability density p(x) at x for a Laplace distribution with width a, using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2876},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/laplace.rs","byte_start":401981,"byte_end":401990,"line_start":23,"line_end":23,"column_start":8,"column_end":17},"name":"laplace_P","qualname":"::randist::laplace::laplace_P","value":"fn (x: f64, a: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Laplace distribution with width a.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2877},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/laplace.rs","byte_start":402208,"byte_end":402217,"line_start":28,"line_end":28,"column_start":8,"column_end":17},"name":"laplace_Q","qualname":"::randist::laplace::laplace_Q","value":"fn (x: f64, a: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Laplace distribution with width a.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2878},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/laplace.rs","byte_start":402435,"byte_end":402447,"line_start":33,"line_end":33,"column_start":8,"column_end":20},"name":"laplace_Pinv","qualname":"::randist::laplace::laplace_Pinv","value":"fn (P: f64, a: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Laplace distribution with width a.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2879},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/laplace.rs","byte_start":402668,"byte_end":402680,"line_start":38,"line_end":38,"column_start":8,"column_end":20},"name":"laplace_Qinv","qualname":"::randist::laplace::laplace_Qinv","value":"fn (Q: f64, a: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Laplace distribution with width a.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2880},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/levy_alpha.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"levy_alpha","qualname":"::randist::levy_alpha","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/levy_alpha.rs","parent":null,"children":[{"krate":0,"index":2881},{"krate":0,"index":2882},{"krate":0,"index":2883}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2883},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/levy_alpha.rs","byte_start":403551,"byte_end":403555,"line_start":15,"line_end":15,"column_start":8,"column_end":12},"name":"levy","qualname":"::randist::levy_alpha::levy","value":"fn (r: &mut Rng, c: f64, alpha: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random variate from the Levy symmetric stable distribution with scale c and exponent alpha. The symmetric stable probability distribution is defined by a Fourier transform,\n \n p(x) = {1 \\over 2 \\pi} \\int_{-\\infty}^{+\\infty} dt \\exp(-it x - |c t|^alpha)\n \n There is no explicit solution for the form of p(x) and the library does not define a corresponding pdf function. For \\alpha = 1 the distribution reduces to the Cauchy distribution. For \\alpha = 2 it is a Gaussian distribution with \\sigma = \\sqrt{2} c. For \\alpha < 1 the tails of the distribution become extremely wide.\n \n The algorithm only works for 0 < alpha <= 2.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2884},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/levy_skew.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"levy_skew","qualname":"::randist::levy_skew","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/levy_skew.rs","parent":null,"children":[{"krate":0,"index":2885},{"krate":0,"index":2886},{"krate":0,"index":2887}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2887},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/levy_skew.rs","byte_start":404986,"byte_end":404995,"line_start":20,"line_end":20,"column_start":8,"column_end":17},"name":"levy_skew","qualname":"::randist::levy_skew::levy_skew","value":"fn (r: &mut Rng, c: f64, alpha: f64, beta: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random variate from the Levy skew stable distribution with scale c, exponent alpha and skewness parameter beta.\n The skewness parameter must lie in the range [-1,1]. The Levy skew stable probability distribution is defined by a Fourier transform,\n \n p(x) = {1 \\over 2 \\pi} \\int_{-\\infty}^{+\\infty} dt \\exp(-it x - |c t|^alpha (1-i beta sign(t) tan(pi alpha/2)))\n \n When \\alpha = 1 the term \\tan(\\pi \\alpha/2) is replaced by -(2/\\pi)\\log|t|. There is no explicit solution for the form of p(x) and the library does not define a corresponding pdf function.\n For \\alpha = 2 the distribution reduces to a Gaussian distribution with \\sigma = \\sqrt{2} c and the skewness parameter has no effect. For \\alpha < 1 the tails of the distribution become extremely wide.\n The symmetric distribution corresponds to \\beta = 0.\n \n The algorithm only works for 0 < alpha <= 2.\n \n The Levy alpha-stable distributions have the property that if N alpha-stable variates are drawn from the distribution p(c, \\alpha, \\beta) then the sum Y = X_1 + X_2 + \\dots + X_N will also be distributed as an alpha-stable variate, p(N^(1/\\alpha) c, \\alpha, \\beta).\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2888},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/logarithmic.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"logarithmic","qualname":"::randist::logarithmic","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/logarithmic.rs","parent":null,"children":[{"krate":0,"index":2889},{"krate":0,"index":2890},{"krate":0,"index":2891},{"krate":0,"index":2892}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2891},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/logarithmic.rs","byte_start":405476,"byte_end":405487,"line_start":13,"line_end":13,"column_start":8,"column_end":19},"name":"logarithmic","qualname":"::randist::logarithmic::logarithmic","value":"fn (r: &mut Rng, p: f64) -> u32","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random integer from the logarithmic distribution. The probability distribution for logarithmic random variates is,\n \n p(k) = {-1 \\over \\log(1-p)} {(p^k \\over k)}\n \n for k >= 1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2892},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/logarithmic.rs","byte_start":405755,"byte_end":405770,"line_start":18,"line_end":18,"column_start":8,"column_end":23},"name":"logarithmic_pdf","qualname":"::randist::logarithmic::logarithmic_pdf","value":"fn (k: u32, p: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the probability p(k) of obtaining k from a logarithmic distribution with probability parameter p, using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2893},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/logistic.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"logistic","qualname":"::randist::logistic","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/logistic.rs","parent":null,"children":[{"krate":0,"index":2894},{"krate":0,"index":2895},{"krate":0,"index":2896},{"krate":0,"index":2897},{"krate":0,"index":2898},{"krate":0,"index":2899},{"krate":0,"index":2900},{"krate":0,"index":2901}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2896},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/logistic.rs","byte_start":406179,"byte_end":406187,"line_start":13,"line_end":13,"column_start":8,"column_end":16},"name":"logistic","qualname":"::randist::logistic::logistic","value":"fn (r: &mut Rng, a: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random variate from the logistic distribution. The distribution function is,\n \n p(x) dx = { \\exp(-x/a) \\over a (1 + \\exp(-x/a))^2 } dx\n \n for -\\infty < x < +\\infty.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2897},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/logistic.rs","byte_start":406440,"byte_end":406452,"line_start":18,"line_end":18,"column_start":8,"column_end":20},"name":"logistic_pdf","qualname":"::randist::logistic::logistic_pdf","value":"fn (x: f64, a: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the probability density p(x) at x for a logistic distribution with scale parameter a, using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2898},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/logistic.rs","byte_start":406684,"byte_end":406694,"line_start":23,"line_end":23,"column_start":8,"column_end":18},"name":"logistic_P","qualname":"::randist::logistic::logistic_P","value":"fn (x: f64, a: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the logistic distribution with scale parameter a.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2899},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/logistic.rs","byte_start":406924,"byte_end":406934,"line_start":28,"line_end":28,"column_start":8,"column_end":18},"name":"logistic_Q","qualname":"::randist::logistic::logistic_Q","value":"fn (x: f64, a: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the logistic distribution with scale parameter a.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2900},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/logistic.rs","byte_start":407164,"byte_end":407177,"line_start":33,"line_end":33,"column_start":8,"column_end":21},"name":"logistic_Pinv","qualname":"::randist::logistic::logistic_Pinv","value":"fn (P: f64, a: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the logistic distribution with scale parameter a.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2901},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/logistic.rs","byte_start":407410,"byte_end":407423,"line_start":38,"line_end":38,"column_start":8,"column_end":21},"name":"logistic_Qinv","qualname":"::randist::logistic::logistic_Qinv","value":"fn (Q: f64, a: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the logistic distribution with scale parameter a.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2902},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/lognormal.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"lognormal","qualname":"::randist::lognormal","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/lognormal.rs","parent":null,"children":[{"krate":0,"index":2903},{"krate":0,"index":2904},{"krate":0,"index":2905},{"krate":0,"index":2906},{"krate":0,"index":2907},{"krate":0,"index":2908},{"krate":0,"index":2909},{"krate":0,"index":2910}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2905},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/lognormal.rs","byte_start":407845,"byte_end":407854,"line_start":13,"line_end":13,"column_start":8,"column_end":17},"name":"lognormal","qualname":"::randist::lognormal::lognormal","value":"fn (r: &mut Rng, zeta: f64, sigma: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random variate from the lognormal distribution. The distribution function is,\n \n p(x) dx = {1 \\over x \\sqrt{2 \\pi \\sigma^2} } \\exp(-(\\ln(x) - \\zeta)^2/2 \\sigma^2) dx\n \n for x > 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2906},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/lognormal.rs","byte_start":408142,"byte_end":408155,"line_start":18,"line_end":18,"column_start":8,"column_end":21},"name":"lognormal_pdf","qualname":"::randist::lognormal::lognormal_pdf","value":"fn (x: f64, zeta: f64, sigma: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the probability density p(x) at x for a lognormal distribution with parameters zeta and sigma, using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2907},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/lognormal.rs","byte_start":408422,"byte_end":408433,"line_start":23,"line_end":23,"column_start":8,"column_end":19},"name":"lognormal_P","qualname":"::randist::lognormal::lognormal_P","value":"fn (x: f64, zeta: f64, sigma: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the lognormal distribution with parameters zeta and sigma.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2908},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/lognormal.rs","byte_start":408698,"byte_end":408709,"line_start":28,"line_end":28,"column_start":8,"column_end":19},"name":"lognormal_Q","qualname":"::randist::lognormal::lognormal_Q","value":"fn (x: f64, zeta: f64, sigma: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the lognormal distribution with parameters zeta and sigma.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2909},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/lognormal.rs","byte_start":408974,"byte_end":408988,"line_start":33,"line_end":33,"column_start":8,"column_end":22},"name":"lognormal_Pinv","qualname":"::randist::lognormal::lognormal_Pinv","value":"fn (P: f64, zeta: f64, sigma: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the lognormal distribution with parameters zeta and sigma.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2910},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/lognormal.rs","byte_start":409256,"byte_end":409270,"line_start":38,"line_end":38,"column_start":8,"column_end":22},"name":"lognormal_Qinv","qualname":"::randist::lognormal::lognormal_Qinv","value":"fn (Q: f64, zeta: f64, sigma: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the lognormal distribution with parameters zeta and sigma.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2911},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/multinomial.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"multinomial","qualname":"::randist::multinomial","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/multinomial.rs","parent":null,"children":[{"krate":0,"index":2912},{"krate":0,"index":2913},{"krate":0,"index":2914},{"krate":0,"index":2915},{"krate":0,"index":2916}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2914},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/multinomial.rs","byte_start":410299,"byte_end":410310,"line_start":17,"line_end":17,"column_start":8,"column_end":19},"name":"multinomial","qualname":"::randist::multinomial::multinomial","value":"fn (r: &mut Rng, N: u32, p: &[f64], n: &mut [u32]) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function computes a random sample n[] from the multinomial distribution formed by N trials from an underlying distribution p[K]. The distribution function for n[] is,\n \n P(n_1, n_2, ..., n_K) = \n   (N!/(n_1! n_2! ... n_K!)) p_1^n_1 p_2^n_2 ... p_K^n_K\n \n where (n_1, n_2, ..., n_K) are nonnegative integers with sum_{k=1}^K n_k = N, and (p_1, p_2, ..., p_K) is a probability distribution with \\sum p_i = 1. If the array p[K] is not normalized then its\n entries will be treated as weights and normalized appropriately. The arrays n[] and p[] must both be of length K.\n \n Random variates are generated using the conditional binomial method (see C.S. Davis, The computer generation of multinomial random variates, Comp. Stat. Data Anal. 16 (1993) 205–217 for details).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2915},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/multinomial.rs","byte_start":410654,"byte_end":410669,"line_start":22,"line_end":22,"column_start":8,"column_end":23},"name":"multinomial_pdf","qualname":"::randist::multinomial::multinomial_pdf","value":"fn (p: &[f64], n: &[u32]) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the probability P(n_1, n_2, ..., n_K) of sampling n[K] from a multinomial distribution with parameters p[K], using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2916},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/multinomial.rs","byte_start":410933,"byte_end":410950,"line_start":27,"line_end":27,"column_start":8,"column_end":25},"name":"multinomial_lnpdf","qualname":"::randist::multinomial::multinomial_lnpdf","value":"fn (p: &[f64], n: &[u32]) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the logarithm of the probability for the multinomial distribution P(n_1, n_2, ..., n_K) with parameters p[K].\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2917},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/negative_binomial.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"negative_binomial","qualname":"::randist::negative_binomial","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/negative_binomial.rs","parent":null,"children":[{"krate":0,"index":2918},{"krate":0,"index":2919},{"krate":0,"index":2920},{"krate":0,"index":2921},{"krate":0,"index":2922},{"krate":0,"index":2923}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2920},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/negative_binomial.rs","byte_start":411583,"byte_end":411600,"line_start":14,"line_end":14,"column_start":8,"column_end":25},"name":"negative_binomial","qualname":"::randist::negative_binomial::negative_binomial","value":"fn (r: &mut Rng, p: f64, n: f64) -> u32","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random integer from the negative binomial distribution, the number of failures occurring before n successes in independent trials with\n probability p of success. The probability distribution for negative binomial variates is,\n \n p(k) = {\\Gamma(n + k) \\over \\Gamma(k+1) \\Gamma(n) } p^n (1-p)^k\n \n Note that n is not required to be an integer.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2921},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/negative_binomial.rs","byte_start":411886,"byte_end":411907,"line_start":19,"line_end":19,"column_start":8,"column_end":29},"name":"negative_binomial_pdf","qualname":"::randist::negative_binomial::negative_binomial_pdf","value":"fn (k: u32, p: f64, n: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the probability p(k) of obtaining k from a negative binomial distribution with parameters p and n, using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2922},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/negative_binomial.rs","byte_start":412150,"byte_end":412169,"line_start":24,"line_end":24,"column_start":8,"column_end":27},"name":"negative_binomial_P","qualname":"::randist::negative_binomial::negative_binomial_P","value":"fn (k: u32, p: f64, n: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(k), Q(k) for the negative binomial distribution with parameters p and n.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2923},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/negative_binomial.rs","byte_start":412410,"byte_end":412429,"line_start":29,"line_end":29,"column_start":8,"column_end":27},"name":"negative_binomial_Q","qualname":"::randist::negative_binomial::negative_binomial_Q","value":"fn (k: u32, p: f64, n: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(k), Q(k) for the negative binomial distribution with parameters p and n.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2924},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/pareto.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"pareto","qualname":"::randist::pareto","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/pareto.rs","parent":null,"children":[{"krate":0,"index":2925},{"krate":0,"index":2926},{"krate":0,"index":2927},{"krate":0,"index":2928},{"krate":0,"index":2929},{"krate":0,"index":2930},{"krate":0,"index":2931},{"krate":0,"index":2932}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2927},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/pareto.rs","byte_start":412825,"byte_end":412831,"line_start":13,"line_end":13,"column_start":8,"column_end":14},"name":"pareto","qualname":"::randist::pareto::pareto","value":"fn (r: &mut Rng, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random variate from the Pareto distribution of order a. The distribution function is,\n \n p(x) dx = (a/b) / (x/b)^{a+1} dx\n \n for x >= b.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2928},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/pareto.rs","byte_start":413096,"byte_end":413106,"line_start":18,"line_end":18,"column_start":8,"column_end":18},"name":"pareto_pdf","qualname":"::randist::pareto::pareto_pdf","value":"fn (x: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the probability density p(x) at x for a Pareto distribution with exponent a and scale b, using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2929},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/pareto.rs","byte_start":413350,"byte_end":413358,"line_start":23,"line_end":23,"column_start":8,"column_end":16},"name":"pareto_P","qualname":"::randist::pareto::pareto_P","value":"fn (x: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Pareto distribution with exponent a and scale b.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2930},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/pareto.rs","byte_start":413600,"byte_end":413608,"line_start":28,"line_end":28,"column_start":8,"column_end":16},"name":"pareto_Q","qualname":"::randist::pareto::pareto_Q","value":"fn (x: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Pareto distribution with exponent a and scale b.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2931},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/pareto.rs","byte_start":413850,"byte_end":413861,"line_start":33,"line_end":33,"column_start":8,"column_end":19},"name":"pareto_Pinv","qualname":"::randist::pareto::pareto_Pinv","value":"fn (P: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Pareto distribution with exponent a and scale b.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2932},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/pareto.rs","byte_start":414106,"byte_end":414117,"line_start":38,"line_end":38,"column_start":8,"column_end":19},"name":"pareto_Qinv","qualname":"::randist::pareto::pareto_Qinv","value":"fn (Q: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Pareto distribution with exponent a and scale b.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2933},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/pascal.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"pascal","qualname":"::randist::pascal","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/pascal.rs","parent":null,"children":[{"krate":0,"index":2934},{"krate":0,"index":2935},{"krate":0,"index":2936},{"krate":0,"index":2937},{"krate":0,"index":2938},{"krate":0,"index":2939}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2936},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/pascal.rs","byte_start":414578,"byte_end":414584,"line_start":13,"line_end":13,"column_start":8,"column_end":14},"name":"pascal","qualname":"::randist::pascal::pascal","value":"fn (r: &mut Rng, p: f64, n: u32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random integer from the Pascal distribution. The Pascal distribution is simply a negative binomial distribution with an integer value of n.\n \n p(k) = {(n + k - 1)! \\over k! (n - 1)! } p^n (1-p)^k\n \n for k >= 0\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2937},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/pascal.rs","byte_start":414848,"byte_end":414858,"line_start":18,"line_end":18,"column_start":8,"column_end":18},"name":"pascal_pdf","qualname":"::randist::pascal::pascal_pdf","value":"fn (k: u32, p: f64, n: u32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the probability p(k) of obtaining k from a Pascal distribution with parameters p and n, using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2938},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/pascal.rs","byte_start":415079,"byte_end":415087,"line_start":23,"line_end":23,"column_start":8,"column_end":16},"name":"pascal_P","qualname":"::randist::pascal::pascal_P","value":"fn (k: u32, p: f64, n: u32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(k), Q(k) for the Pascal distribution with parameters p and n.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2939},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/pascal.rs","byte_start":415306,"byte_end":415314,"line_start":28,"line_end":28,"column_start":8,"column_end":16},"name":"pascal_Q","qualname":"::randist::pascal::pascal_Q","value":"fn (k: u32, p: f64, n: u32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(k), Q(k) for the Pascal distribution with parameters p and n.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2940},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/poisson.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"poisson","qualname":"::randist::poisson","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/poisson.rs","parent":null,"children":[{"krate":0,"index":2941},{"krate":0,"index":2942},{"krate":0,"index":2943},{"krate":0,"index":2944},{"krate":0,"index":2945},{"krate":0,"index":2946}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2943},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/poisson.rs","byte_start":415728,"byte_end":415735,"line_start":13,"line_end":13,"column_start":8,"column_end":15},"name":"poisson","qualname":"::randist::poisson::poisson","value":"fn (r: &mut Rng, mu: f64) -> u32","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random integer from the Poisson distribution with mean mu. The probability distribution for Poisson variates is,\n \n p(k) = {\\mu^k \\over k!} \\exp(-\\mu)\n \n for k >= 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2944},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/poisson.rs","byte_start":415981,"byte_end":415992,"line_start":18,"line_end":18,"column_start":8,"column_end":19},"name":"poisson_pdf","qualname":"::randist::poisson::poisson_pdf","value":"fn (k: u32, mu: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the probability p(k) of obtaining k from a Poisson distribution with mean mu, using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2945},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/poisson.rs","byte_start":416200,"byte_end":416209,"line_start":23,"line_end":23,"column_start":8,"column_end":17},"name":"poisson_P","qualname":"::randist::poisson::poisson_P","value":"fn (k: u32, mu: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(k), Q(k) for the Poisson distribution with parameter mu.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2946},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/poisson.rs","byte_start":416415,"byte_end":416424,"line_start":28,"line_end":28,"column_start":8,"column_end":17},"name":"poisson_Q","qualname":"::randist::poisson::poisson_Q","value":"fn (k: u32, mu: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(k), Q(k) for the Poisson distribution with parameter mu.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2947},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/rayleigh.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"rayleigh","qualname":"::randist::rayleigh","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/rayleigh.rs","parent":null,"children":[{"krate":0,"index":2948},{"krate":0,"index":2949},{"krate":0,"index":2950},{"krate":0,"index":2951},{"krate":0,"index":2952},{"krate":0,"index":2953},{"krate":0,"index":2954},{"krate":0,"index":2955}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2950},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/rayleigh.rs","byte_start":416833,"byte_end":416841,"line_start":13,"line_end":13,"column_start":8,"column_end":16},"name":"rayleigh","qualname":"::randist::rayleigh::rayleigh","value":"fn (r: &mut Rng, sigma: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random variate from the Rayleigh distribution with scale parameter sigma. The distribution is,\n \n p(x) dx = {x \\over \\sigma^2} \\exp(- x^2/(2 \\sigma^2)) dx\n \n for x > 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2951},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/rayleigh.rs","byte_start":417106,"byte_end":417118,"line_start":18,"line_end":18,"column_start":8,"column_end":20},"name":"rayleigh_pdf","qualname":"::randist::rayleigh::rayleigh_pdf","value":"fn (x: f64, sigma: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the probability density p(x) at x for a Rayleigh distribution with scale parameter sigma, using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2952},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/rayleigh.rs","byte_start":417362,"byte_end":417372,"line_start":23,"line_end":23,"column_start":8,"column_end":18},"name":"rayleigh_P","qualname":"::randist::rayleigh::rayleigh_P","value":"fn (x: f64, sigma: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Rayleigh distribution with scale parameter sigma.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2953},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/rayleigh.rs","byte_start":417614,"byte_end":417624,"line_start":28,"line_end":28,"column_start":8,"column_end":18},"name":"rayleigh_Q","qualname":"::randist::rayleigh::rayleigh_Q","value":"fn (x: f64, sigma: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Rayleigh distribution with scale parameter sigma.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2954},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/rayleigh.rs","byte_start":417866,"byte_end":417879,"line_start":33,"line_end":33,"column_start":8,"column_end":21},"name":"rayleigh_Pinv","qualname":"::randist::rayleigh::rayleigh_Pinv","value":"fn (P: f64, sigma: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Rayleigh distribution with scale parameter sigma.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2955},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/rayleigh.rs","byte_start":418124,"byte_end":418137,"line_start":38,"line_end":38,"column_start":8,"column_end":21},"name":"rayleigh_Qinv","qualname":"::randist::rayleigh::rayleigh_Qinv","value":"fn (Q: f64, sigma: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Rayleigh distribution with scale parameter sigma.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2956},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/rayleigh_tail.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"rayleigh_tail","qualname":"::randist::rayleigh_tail","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/rayleigh_tail.rs","parent":null,"children":[{"krate":0,"index":2957},{"krate":0,"index":2958},{"krate":0,"index":2959},{"krate":0,"index":2960}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2959},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/rayleigh_tail.rs","byte_start":418599,"byte_end":418612,"line_start":13,"line_end":13,"column_start":8,"column_end":21},"name":"rayleigh_tail","qualname":"::randist::rayleigh_tail::rayleigh_tail","value":"fn (r: &mut Rng, a: f64, sigma: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random variate from the tail of the Rayleigh distribution with scale parameter sigma and a lower limit of a. The distribution is,\n \n p(x) dx = {x \\over \\sigma^2} \\exp ((a^2 - x^2) /(2 \\sigma^2)) dx\n \n for x > a.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2960},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/rayleigh_tail.rs","byte_start":418916,"byte_end":418933,"line_start":18,"line_end":18,"column_start":8,"column_end":25},"name":"rayleigh_tail_pdf","qualname":"::randist::rayleigh_tail::rayleigh_tail_pdf","value":"fn (x: f64, a: f64, sigma: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the probability density p(x) at x for a Rayleigh tail distribution with scale parameter sigma and lower limit a, using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2961},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/shuffling_sampling.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"shuffling_sampling","qualname":"::randist::shuffling_sampling","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/shuffling_sampling.rs","parent":null,"children":[{"krate":0,"index":2962},{"krate":0,"index":2963},{"krate":0,"index":2964},{"krate":0,"index":2965},{"krate":0,"index":2966},{"krate":0,"index":2968},{"krate":0,"index":2970}],"decl_id":null,"docs":"The following functions allow the shuffling and sampling of a set of objects.\nThe algorithms rely on a random number generator as a source of randomness and a poor quality generator can lead to correlations in the output.\nIn particular it is important to avoid generators with a short period. For more information see Knuth, v2, 3rd ed, Section 3.4.2, “Random Sampling and Shuffling”.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2966},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/shuffling_sampling.rs","byte_start":420135,"byte_end":420142,"line_start":31,"line_end":31,"column_start":8,"column_end":15},"name":"shuffle","qualname":"::randist::shuffling_sampling::shuffle","value":"fn <T> (r: &mut Rng, base: &mut [T]) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function randomly shuffles the order of n objects, each of size size, stored in the array base[0..n-1]. The output of the random number generator r is used to\n produce the permutation. The algorithm generates all possible n! permutations with equal probability, assuming a perfect source of random numbers.\n \n The following code shows how to shuffle the numbers from 0 to 51,\n \n ```C\n int a[52];\n \n for (i = 0; i < 52; i++)\n   {\n     a[i] = i;\n   }\n \n gsl_ran_shuffle (r, a, 52, sizeof (int));\n ```\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2968},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/shuffling_sampling.rs","byte_start":421320,"byte_end":421326,"line_start":56,"line_end":56,"column_start":8,"column_end":14},"name":"choose","qualname":"::randist::shuffling_sampling::choose","value":"fn <T> (r: &mut Rng, dest: &mut [T], src: &[T]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function fills the array dest[k] with k objects taken randomly from the n elements of the array src[0..n-1]. The objects are each of size size.\n The output of the random number generator r is used to make the selection. The algorithm ensures all possible samples are equally likely, assuming a perfect source of randomness.\n \n The objects are sampled without replacement, thus each object can only appear once in dest[k]. It is required that k be less than or equal to n.\n The objects in dest will be in the same relative order as those in src. You will need to call gsl_ran_shuffle(r, dest, n, size) if you want to randomize the order.\n \n The following code shows how to select a random sample of three unique numbers from the set 0 to 99,\n \n ```C\n double a[3], b[100];\n \n for (i = 0; i < 100; i++)\n   {\n     b[i] = (double) i;\n   }\n \n gsl_ran_choose (r, a, 3, b, 100, sizeof (double));\n ```\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2970},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/shuffling_sampling.rs","byte_start":422142,"byte_end":422148,"line_start":68,"line_end":68,"column_start":8,"column_end":14},"name":"sample","qualname":"::randist::shuffling_sampling::sample","value":"fn <T> (r: &mut Rng, dest: &mut [T], src: &[T]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function is like gsl_ran_choose but samples k items from the original array of n items src with replacement, so the same object can appear more\n than once in the output sequence dest. There is no requirement that k be less than n in this case.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2972},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/spherical_vector.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"spherical_vector","qualname":"::randist::spherical_vector","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/spherical_vector.rs","parent":null,"children":[{"krate":0,"index":2973},{"krate":0,"index":2974},{"krate":0,"index":2975},{"krate":0,"index":2976},{"krate":0,"index":2977},{"krate":0,"index":2978}],"decl_id":null,"docs":"The spherical distributions generate random vectors, located on a spherical surface.\nThey can be used as random directions, for example in the steps of a random walk.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2975},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/spherical_vector.rs","byte_start":424049,"byte_end":424055,"line_start":21,"line_end":21,"column_start":8,"column_end":14},"name":"dir_2d","qualname":"::randist::spherical_vector::dir_2d","value":"fn (r: &mut Rng, x: &mut f64, y: &mut f64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random direction vector v = (x,y) in two dimensions. The vector is normalized such that |v|^2 = x^2 + y^2 = 1.\n The obvious way to do this is to take a uniform random number between 0 and 2\\pi and let x and y be the sine and cosine respectively.\n Two trig functions would have been expensive in the old days, but with modern hardware implementations, this is sometimes the fastest way to go.\n This is the case for the Pentium (but not the case for the Sun Sparcstation).\n One can avoid the trig evaluations by choosing x and y in the interior of a unit circle (choose them at random from the interior of the enclosing square,\n and then reject those that are outside the unit circle), and then dividing by \\sqrt{x^2 + y^2}. A much cleverer approach, attributed to von Neumann\n (See Knuth, v2, 3rd ed, p140, exercise 23), requires neither trig nor a square root. In this approach, u and v are chosen at random from the interior of\n a unit circle, and then x=(u^2-v^2)/(u^2+v^2) and y=2uv/(u^2+v^2).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2976},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/spherical_vector.rs","byte_start":425222,"byte_end":425240,"line_start":33,"line_end":33,"column_start":8,"column_end":26},"name":"dir_2d_trig_method","qualname":"::randist::spherical_vector::dir_2d_trig_method","value":"fn (r: &mut Rng, x: &mut f64, y: &mut f64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random direction vector v = (x,y) in two dimensions. The vector is normalized such that |v|^2 = x^2 + y^2 = 1.\n The obvious way to do this is to take a uniform random number between 0 and 2\\pi and let x and y be the sine and cosine respectively.\n Two trig functions would have been expensive in the old days, but with modern hardware implementations, this is sometimes the fastest way to go.\n This is the case for the Pentium (but not the case for the Sun Sparcstation).\n One can avoid the trig evaluations by choosing x and y in the interior of a unit circle (choose them at random from the interior of the enclosing square,\n and then reject those that are outside the unit circle), and then dividing by \\sqrt{x^2 + y^2}. A much cleverer approach, attributed to von Neumann\n (See Knuth, v2, 3rd ed, p140, exercise 23), requires neither trig nor a square root. In this approach, u and v are chosen at random from the interior of\n a unit circle, and then x=(u^2-v^2)/(u^2+v^2) and y=2uv/(u^2+v^2).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2977},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/spherical_vector.rs","byte_start":425773,"byte_end":425779,"line_start":40,"line_end":40,"column_start":8,"column_end":14},"name":"dir_3d","qualname":"::randist::spherical_vector::dir_3d","value":"fn (r: &mut Rng, x: &mut f64, y: &mut f64, z: &mut f64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random direction vector v = (x,y,z) in three dimensions. The vector is normalized such that |v|^2 = x^2 + y^2 + z^2 = 1.\n The method employed is due to Robert E. Knop (CACM 13, 326 (1970)), and explained in Knuth, v2, 3rd ed, p136. It uses the surprising fact that the\n distribution projected along any axis is actually uniform (this is only true for 3 dimensions).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2978},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/spherical_vector.rs","byte_start":426415,"byte_end":426421,"line_start":47,"line_end":47,"column_start":8,"column_end":14},"name":"dir_nd","qualname":"::randist::spherical_vector::dir_nd","value":"fn (r: &mut Rng, x: &mut [f64]) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random direction vector v = (x_1,x_2,...,x_n) in n dimensions. The vector is normalized such that |v|^2 = x_1^2 + x_2^2 + ... + x_n^2 = 1.\n The method uses the fact that a multivariate Gaussian distribution is spherically symmetric. Each component is generated to have a Gaussian distribution, and then\n the components are normalized. The method is described by Knuth, v2, 3rd ed, p135–136, and attributed to G. W. Brown, Modern Mathematics for the Engineer (1956).\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2979},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/t_distribution.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"t_distribution","qualname":"::randist::t_distribution","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/t_distribution.rs","parent":null,"children":[{"krate":0,"index":2980},{"krate":0,"index":2981},{"krate":0,"index":2982},{"krate":0,"index":2983},{"krate":0,"index":2984},{"krate":0,"index":2985},{"krate":0,"index":2986},{"krate":0,"index":2987}],"decl_id":null,"docs":"The t-distribution arises in statistics. If Y_1 has a normal distribution and Y_2 has a chi-squared distribution with \\nu degrees of freedom then the ratio,","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2982},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/t_distribution.rs","byte_start":427188,"byte_end":427193,"line_start":23,"line_end":23,"column_start":8,"column_end":13},"name":"tdist","qualname":"::randist::t_distribution::tdist","value":"fn (r: &mut Rng, nu: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random variate from the t-distribution. The distribution function is,\n \n p(x) dx = {Gamma((\\nu + 1)/2) \\over \\sqrt{\\pi \\nu} Gamma(\\nu/2)}\n \n    (1 + x^2/\\nu)^{-(\\nu + 1)/2} dx\n \n for -\\infty < x < +\\infty.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2983},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/t_distribution.rs","byte_start":427442,"byte_end":427451,"line_start":28,"line_end":28,"column_start":8,"column_end":17},"name":"tdist_pdf","qualname":"::randist::t_distribution::tdist_pdf","value":"fn (x: f64, nu: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the probability density p(x) at x for a t-distribution with nu degrees of freedom, using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2984},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/t_distribution.rs","byte_start":427679,"byte_end":427686,"line_start":33,"line_end":33,"column_start":8,"column_end":15},"name":"tdist_P","qualname":"::randist::t_distribution::tdist_P","value":"fn (x: f64, nu: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the t-distribution with nu degrees of freedom.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2985},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/t_distribution.rs","byte_start":427912,"byte_end":427919,"line_start":38,"line_end":38,"column_start":8,"column_end":15},"name":"tdist_Q","qualname":"::randist::t_distribution::tdist_Q","value":"fn (x: f64, nu: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the t-distribution with nu degrees of freedom.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2986},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/t_distribution.rs","byte_start":428145,"byte_end":428155,"line_start":43,"line_end":43,"column_start":8,"column_end":18},"name":"tdist_Pinv","qualname":"::randist::t_distribution::tdist_Pinv","value":"fn (P: f64, nu: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the t-distribution with nu degrees of freedom.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2987},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/t_distribution.rs","byte_start":428384,"byte_end":428394,"line_start":48,"line_end":48,"column_start":8,"column_end":18},"name":"tdist_Qinv","qualname":"::randist::t_distribution::tdist_Qinv","value":"fn (Q: f64, nu: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the t-distribution with nu degrees of freedom.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2988},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/weibull.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"weibull","qualname":"::randist::weibull","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/weibull.rs","parent":null,"children":[{"krate":0,"index":2989},{"krate":0,"index":2990},{"krate":0,"index":2991},{"krate":0,"index":2992},{"krate":0,"index":2993},{"krate":0,"index":2994},{"krate":0,"index":2995},{"krate":0,"index":2996}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2991},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/weibull.rs","byte_start":428780,"byte_end":428787,"line_start":13,"line_end":13,"column_start":8,"column_end":15},"name":"weibull","qualname":"::randist::weibull::weibull","value":"fn (r: &mut Rng, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random variate from the Weibull distribution. The distribution function is,\n \n p(x) dx = {b \\over a^b} x^{b-1}  \\exp(-(x/a)^b) dx\n \n for x >= 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2992},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/weibull.rs","byte_start":429054,"byte_end":429065,"line_start":18,"line_end":18,"column_start":8,"column_end":19},"name":"weibull_pdf","qualname":"::randist::weibull::weibull_pdf","value":"fn (x: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the probability density p(x) at x for a Weibull distribution with scale a and exponent b, using the formula given above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2993},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/weibull.rs","byte_start":429311,"byte_end":429320,"line_start":23,"line_end":23,"column_start":8,"column_end":17},"name":"weibull_P","qualname":"::randist::weibull::weibull_P","value":"fn (x: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Weibull distribution with scale a and exponent b.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2994},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/weibull.rs","byte_start":429564,"byte_end":429573,"line_start":28,"line_end":28,"column_start":8,"column_end":17},"name":"weibull_Q","qualname":"::randist::weibull::weibull_Q","value":"fn (x: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Weibull distribution with scale a and exponent b.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2995},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/weibull.rs","byte_start":429817,"byte_end":429829,"line_start":33,"line_end":33,"column_start":8,"column_end":20},"name":"weibull_Pinv","qualname":"::randist::weibull::weibull_Pinv","value":"fn (P: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Weibull distribution with scale a and exponent b.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":2996},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/weibull.rs","byte_start":430076,"byte_end":430088,"line_start":38,"line_end":38,"column_start":8,"column_end":20},"name":"weibull_Qinv","qualname":"::randist::weibull::weibull_Qinv","value":"fn (Q: f64, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the cumulative distribution functions P(x), Q(x) and their inverses for the Weibull distribution with scale a and exponent b.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":2997},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"types","qualname":"::types","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","parent":null,"children":[{"krate":0,"index":2998},{"krate":0,"index":2999},{"krate":0,"index":3000},{"krate":0,"index":3001},{"krate":0,"index":3004},{"krate":0,"index":3005},{"krate":0,"index":3018},{"krate":0,"index":3021},{"krate":0,"index":3026},{"krate":0,"index":3032},{"krate":0,"index":3037},{"krate":0,"index":3038},{"krate":0,"index":3042},{"krate":0,"index":3045},{"krate":0,"index":3048},{"krate":0,"index":3054},{"krate":0,"index":3059},{"krate":0,"index":3060},{"krate":0,"index":3061},{"krate":0,"index":3068},{"krate":0,"index":3069},{"krate":0,"index":3070},{"krate":0,"index":3073},{"krate":0,"index":3074},{"krate":0,"index":3077},{"krate":0,"index":3080},{"krate":0,"index":3087},{"krate":0,"index":3090},{"krate":0,"index":3093},{"krate":0,"index":3097},{"krate":0,"index":3100},{"krate":0,"index":3104},{"krate":0,"index":3125},{"krate":0,"index":3156},{"krate":0,"index":3192},{"krate":0,"index":3357},{"krate":0,"index":3376},{"krate":0,"index":3536},{"krate":0,"index":3564},{"krate":0,"index":3678},{"krate":0,"index":3893},{"krate":0,"index":3949},{"krate":0,"index":3976},{"krate":0,"index":4095},{"krate":0,"index":4192},{"krate":0,"index":4277},{"krate":0,"index":4354},{"krate":0,"index":4418},{"krate":0,"index":4449},{"krate":0,"index":4481},{"krate":0,"index":4596},{"krate":0,"index":4643},{"krate":0,"index":4658},{"krate":0,"index":4694},{"krate":0,"index":4710},{"krate":0,"index":4720},{"krate":0,"index":4813},{"krate":0,"index":4861},{"krate":0,"index":4894},{"krate":0,"index":4928},{"krate":0,"index":5031},{"krate":0,"index":5117}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":3104},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/basis_spline.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"basis_spline","qualname":"::types::basis_spline","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/basis_spline.rs","parent":null,"children":[{"krate":0,"index":3105},{"krate":0,"index":3106},{"krate":0,"index":3107},{"krate":0,"index":3108},{"krate":0,"index":3110},{"krate":0,"index":3118},{"krate":0,"index":3120}],"decl_id":null,"docs":"B-splines are commonly used as basis functions to fit smoothing curves to large data sets.\nTo do this, the abscissa axis is broken up into some number of intervals, where the endpoints of\neach interval are called breakpoints.","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":3108},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/basis_spline.rs","byte_start":435669,"byte_end":435685,"line_start":57,"line_end":57,"column_start":12,"column_end":28},"name":"BSpLineWorkspace","qualname":"::types::basis_spline::BSpLineWorkspace","value":"BSpLineWorkspace {  }","parent":null,"children":[{"krate":0,"index":3109}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3111},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/basis_spline.rs","byte_start":436066,"byte_end":436069,"line_start":68,"line_end":68,"column_start":12,"column_end":15},"name":"new","qualname":"<BSpLineWorkspace>::new","value":"fn (k: usize, nbreak: usize) -> Option<BSpLineWorkspace>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates a workspace for computing B-splines of order k.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3112},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/basis_spline.rs","byte_start":436480,"byte_end":436485,"line_start":82,"line_end":82,"column_start":12,"column_end":17},"name":"knots","qualname":"<BSpLineWorkspace>::knots","value":"fn (&mut self, breakpts: &VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the knots associated with the given breakpoints and stores them\n internally in w->knots.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3113},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/basis_spline.rs","byte_start":436872,"byte_end":436885,"line_start":89,"line_end":89,"column_start":12,"column_end":25},"name":"knots_uniform","qualname":"<BSpLineWorkspace>::knots_uniform","value":"fn (&mut self, a: f64, b: f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function assumes uniformly spaced breakpoints on [a,b] and constructs the corresponding\n knot vector using the previously specified nbreak parameter.\n The knots are stored in w->knots.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3114},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/basis_spline.rs","byte_start":437501,"byte_end":437505,"line_start":101,"line_end":101,"column_start":12,"column_end":16},"name":"eval","qualname":"<BSpLineWorkspace>::eval","value":"fn (&mut self, x: f64, B: &mut VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function evaluates all B-spline basis functions at the position x and stores them in\n the vector B, so that the i-th element is B_i(x).","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3115},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/basis_spline.rs","byte_start":438233,"byte_end":438246,"line_start":112,"line_end":112,"column_start":12,"column_end":25},"name":"eval_non_zero","qualname":"<BSpLineWorkspace>::eval_non_zero","value":"fn (&mut self, x: f64, Bk: &mut VectorF64, istart: &mut usize, iend: &mut usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function evaluates all potentially nonzero B-spline basis functions at the position x\n and stores them in the vector Bk, so that the i-th element is B_(istart+i)(x).","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3116},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/basis_spline.rs","byte_start":438603,"byte_end":438610,"line_start":118,"line_end":118,"column_start":12,"column_end":19},"name":"ncoeffs","qualname":"<BSpLineWorkspace>::ncoeffs","value":"fn (&mut self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" This function returns the number of B-spline coefficients given by n = nbreak + k - 2.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3117},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/basis_spline.rs","byte_start":439404,"byte_end":439421,"line_start":134,"line_end":134,"column_start":12,"column_end":29},"name":"greville_abscissa","qualname":"<BSpLineWorkspace>::greville_abscissa","value":"fn (&mut self, i: usize) -> f64","parent":null,"children":[],"decl_id":null,"docs":" The Greville abscissae are defined to be the mean location of k-1 consecutive knots in the\n knot vector for each basis spline function of order k.","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":3125},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/chebyshev.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"chebyshev","qualname":"::types::chebyshev","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/chebyshev.rs","parent":null,"children":[{"krate":0,"index":3126},{"krate":0,"index":3127},{"krate":0,"index":3128},{"krate":0,"index":3129},{"krate":0,"index":3130},{"krate":0,"index":3133},{"krate":0,"index":3149},{"krate":0,"index":3151}],"decl_id":null,"docs":"#Chebyshev Approximations","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":3130},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/chebyshev.rs","byte_start":444949,"byte_end":444959,"line_start":38,"line_end":38,"column_start":12,"column_end":22},"name":"ChebSeries","qualname":"::types::chebyshev::ChebSeries","value":"ChebSeries {  }","parent":null,"children":[{"krate":0,"index":3131},{"krate":0,"index":3132}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3134},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/chebyshev.rs","byte_start":445050,"byte_end":445053,"line_start":44,"line_end":44,"column_start":12,"column_end":15},"name":"new","qualname":"<ChebSeries>::new","value":"fn (n: usize) -> Option<ChebSeries>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3135},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/chebyshev.rs","byte_start":445681,"byte_end":445685,"line_start":62,"line_end":62,"column_start":12,"column_end":16},"name":"init","qualname":"<ChebSeries>::init","value":"fn <T> (&mut self, func: ::function<T>, a: f64, b: f64, param: &mut T) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the Chebyshev approximation cs for the function f over the range\n (a,b) to the previously specified order. The computation of the Chebyshev approximation is\n an O(n^2) process, and requires n function evaluations.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3137},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/chebyshev.rs","byte_start":447038,"byte_end":447043,"line_start":96,"line_end":96,"column_start":12,"column_end":17},"name":"order","qualname":"<ChebSeries>::order","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" This function returns the order of Chebyshev series cs.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3138},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/chebyshev.rs","byte_start":447242,"byte_end":447246,"line_start":102,"line_end":102,"column_start":12,"column_end":16},"name":"size","qualname":"<ChebSeries>::size","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" This function returns the size of the Chebyshev coefficient array c[] for the Chebyshev\n series cs.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3139},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/chebyshev.rs","byte_start":447454,"byte_end":447462,"line_start":108,"line_end":108,"column_start":12,"column_end":20},"name":"as_slice","qualname":"<ChebSeries>::as_slice","value":"fn <'r> (&'r self) -> &'r [f64]","parent":null,"children":[],"decl_id":null,"docs":" This function returns a pointer to the coefficient array c[] location in memory for the\n Chebyshev series cs.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3141},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/chebyshev.rs","byte_start":447662,"byte_end":447674,"line_start":114,"line_end":114,"column_start":12,"column_end":24},"name":"as_mut_slice","qualname":"<ChebSeries>::as_mut_slice","value":"fn <'r> (&'r mut self) -> &'r mut [f64]","parent":null,"children":[],"decl_id":null,"docs":" This function returns a pointer to the coefficient array c[] location in memory for the\n Chebyshev series cs.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3143},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/chebyshev.rs","byte_start":447833,"byte_end":447837,"line_start":119,"line_end":119,"column_start":12,"column_end":16},"name":"eval","qualname":"<ChebSeries>::eval","value":"fn (&self, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function evaluates the Chebyshev series cs at a given point x.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3144},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/chebyshev.rs","byte_start":448157,"byte_end":448165,"line_start":126,"line_end":126,"column_start":12,"column_end":20},"name":"eval_err","qualname":"<ChebSeries>::eval_err","value":"fn (&self, x: f64, result: &mut f64, abs_err: &mut f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the Chebyshev series cs at a given point x, estimating both the\n series result and its absolute error abserr.\n The error estimate is made from the first neglected term in the series.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3145},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/chebyshev.rs","byte_start":448464,"byte_end":448470,"line_start":132,"line_end":132,"column_start":12,"column_end":18},"name":"eval_n","qualname":"<ChebSeries>::eval_n","value":"fn (&self, order: usize, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function evaluates the Chebyshev series cs at a given point x, to (at most) the given\n order order.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3146},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/chebyshev.rs","byte_start":448848,"byte_end":448858,"line_start":139,"line_end":139,"column_start":12,"column_end":22},"name":"eval_n_err","qualname":"<ChebSeries>::eval_n_err","value":"fn (&self, order: usize, x: f64, result: &mut f64, abs_err: &mut f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function evaluates a Chebyshev series cs at a given point x, estimating both the series\n result and its absolute error abserr, to (at most) the given order order. The error estimate\n is made from the first neglected term in the series.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3147},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/chebyshev.rs","byte_start":449307,"byte_end":449317,"line_start":147,"line_end":147,"column_start":12,"column_end":22},"name":"calc_deriv","qualname":"<ChebSeries>::calc_deriv","value":"fn (&self, deriv: &mut ChebSeries) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the derivative of the series cs, storing the derivative coefficients\n in the previously allocated deriv. The two series cs and deriv must have been allocated with\n the same order.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3148},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/chebyshev.rs","byte_start":449779,"byte_end":449789,"line_start":155,"line_end":155,"column_start":12,"column_end":22},"name":"calc_integ","qualname":"<ChebSeries>::calc_integ","value":"fn (&self, integ: &mut ChebSeries) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the integral of the series cs, storing the integral coefficients in\n the previously allocated integ. The two series cs and integ must have been allocated with\n the same order. The lower limit of the integration is taken to be the left hand end of the\n range a.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":3156},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/combination.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"combination","qualname":"::types::combination","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/combination.rs","parent":null,"children":[{"krate":0,"index":3157},{"krate":0,"index":3158},{"krate":0,"index":3159},{"krate":0,"index":3160},{"krate":0,"index":3163},{"krate":0,"index":3164},{"krate":0,"index":3167},{"krate":0,"index":3183},{"krate":0,"index":3185},{"krate":0,"index":3190}],"decl_id":null,"docs":"#Combinations","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":3164},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/combination.rs","byte_start":451443,"byte_end":451454,"line_start":27,"line_end":27,"column_start":12,"column_end":23},"name":"Combination","qualname":"::types::combination::Combination","value":"Combination {  }","parent":null,"children":[{"krate":0,"index":3165},{"krate":0,"index":3166}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3168},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/combination.rs","byte_start":451968,"byte_end":451971,"line_start":38,"line_end":38,"column_start":12,"column_end":15},"name":"new","qualname":"<Combination>::new","value":"fn (n: usize, k: usize) -> Option<Combination>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates memory for a new combination with parameters n, k. The combination\n is not initialized and its elements are undefined. Use the function\n `Combination::new_init_first` if you want to create a combination which is initialized to\n the lexicographically first combination. A null pointer is returned if insufficient memory\n is available to create the combination.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3169},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/combination.rs","byte_start":452874,"byte_end":452888,"line_start":63,"line_end":63,"column_start":12,"column_end":26},"name":"new_init_first","qualname":"<Combination>::new_init_first","value":"fn (n: usize, k: usize) -> Option<Combination>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates memory for a new combination with parameters n, k and initializes it\n to the lexicographically first combination. A null pointer is returned if insufficient\n memory is available to create the combination.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3170},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/combination.rs","byte_start":453667,"byte_end":453677,"line_start":87,"line_end":87,"column_start":12,"column_end":22},"name":"init_first","qualname":"<Combination>::init_first","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function initializes the combination c to the lexicographically first combination, i.e.\n (0,1,2,...,k-1).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3171},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/combination.rs","byte_start":453897,"byte_end":453906,"line_start":93,"line_end":93,"column_start":12,"column_end":21},"name":"init_last","qualname":"<Combination>::init_last","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function initializes the combination c to the lexicographically last combination, i.e.\n (n-k,n-k+1,…,n-1).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3172},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/combination.rs","byte_start":454143,"byte_end":454147,"line_start":99,"line_end":99,"column_start":12,"column_end":16},"name":"copy","qualname":"<Combination>::copy","value":"fn (&self, dest: &mut Combination) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the combination self into the combination dest. The two\n combinations must have the same size.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3173},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/combination.rs","byte_start":454492,"byte_end":454495,"line_start":105,"line_end":105,"column_start":12,"column_end":15},"name":"get","qualname":"<Combination>::get","value":"fn (&self, i: usize) -> usize","parent":null,"children":[],"decl_id":null,"docs":" This function returns the value of the i-th element of the combination self. If i lies\n outside the allowed range of 0 to k-1 then the error handler is invoked and 0 is returned.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3174},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/combination.rs","byte_start":454666,"byte_end":454667,"line_start":110,"line_end":110,"column_start":12,"column_end":13},"name":"n","qualname":"<Combination>::n","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" This function returns the range (n) of the combination self.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3175},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/combination.rs","byte_start":454836,"byte_end":454837,"line_start":115,"line_end":115,"column_start":12,"column_end":13},"name":"k","qualname":"<Combination>::k","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" This function returns the number of elements (k) in the combination self.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3176},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/combination.rs","byte_start":455014,"byte_end":455022,"line_start":120,"line_end":120,"column_start":12,"column_end":20},"name":"as_slice","qualname":"<Combination>::as_slice","value":"fn <'r> (&'r self) -> &'r [usize]","parent":null,"children":[],"decl_id":null,"docs":" This function returns a pointer to the array of elements in the combination self.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3178},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/combination.rs","byte_start":455189,"byte_end":455201,"line_start":125,"line_end":125,"column_start":12,"column_end":24},"name":"as_mut_slice","qualname":"<Combination>::as_mut_slice","value":"fn <'r> (&'r mut self) -> &'r mut [usize]","parent":null,"children":[],"decl_id":null,"docs":" This function returns a pointer to the array of elements in the combination self.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3180},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/combination.rs","byte_start":455472,"byte_end":455480,"line_start":131,"line_end":131,"column_start":12,"column_end":20},"name":"is_valid","qualname":"<Combination>::is_valid","value":"fn (&self) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function checks that the combination self is valid. The k elements should lie in the\n range 0 to n-1, with each value occurring once at most and in increasing order.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3181},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/combination.rs","byte_start":455971,"byte_end":455975,"line_start":139,"line_end":139,"column_start":12,"column_end":16},"name":"next","qualname":"<Combination>::next","value":"fn (&mut self) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function advances the combination self to the next combination in lexicographic order\n and returns `Success`. If no further combinations are available it returns Failure and\n leaves self unmodified. Starting with the first combination and repeatedly applying this\n function will iterate through all possible combinations of a given order.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3182},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/combination.rs","byte_start":456338,"byte_end":456342,"line_start":146,"line_end":146,"column_start":12,"column_end":16},"name":"prev","qualname":"<Combination>::prev","value":"fn (&mut self) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function steps backwards from the combination self to the previous combination in\n lexicographic order, returning `Success`. If no previous combination is available it returns\n `Failure` and leaves self unmodified.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":3192},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"complex","qualname":"::types::complex","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","parent":null,"children":[{"krate":0,"index":3193},{"krate":0,"index":3196},{"krate":0,"index":3197},{"krate":0,"index":3198},{"krate":0,"index":3199},{"krate":0,"index":3203},{"krate":0,"index":6997},{"krate":0,"index":7004},{"krate":0,"index":7000},{"krate":0,"index":7001},{"krate":0,"index":3207},{"krate":0,"index":3267},{"krate":0,"index":3269},{"krate":0,"index":3271},{"krate":0,"index":3273},{"krate":0,"index":3276},{"krate":0,"index":3279},{"krate":0,"index":3282},{"krate":0,"index":7005},{"krate":0,"index":7012},{"krate":0,"index":7008},{"krate":0,"index":7009},{"krate":0,"index":3285},{"krate":0,"index":3345},{"krate":0,"index":3347},{"krate":0,"index":3349},{"krate":0,"index":3351},{"krate":0,"index":3354}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Trait","id":{"krate":0,"index":3199},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":457868,"byte_end":457872,"line_start":13,"line_end":13,"column_start":11,"column_end":15},"name":"CFFI","qualname":"::types::complex::CFFI","value":"CFFI<T>","parent":null,"children":[{"krate":0,"index":3201},{"krate":0,"index":3202}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3201},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":457885,"byte_end":457889,"line_start":14,"line_end":14,"column_start":8,"column_end":12},"name":"wrap","qualname":"::types::complex::CFFI::wrap","value":"fn (s: T) -> Self","parent":{"krate":0,"index":3199},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3202},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":457912,"byte_end":457918,"line_start":15,"line_end":15,"column_start":8,"column_end":14},"name":"unwrap","qualname":"::types::complex::CFFI::unwrap","value":"fn (self) -> T","parent":{"krate":0,"index":3199},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Trait","id":{"krate":0,"index":3203},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":457959,"byte_end":457963,"line_start":19,"line_end":19,"column_start":11,"column_end":15},"name":"FFFI","qualname":"::types::complex::FFFI","value":"FFFI<T>","parent":null,"children":[{"krate":0,"index":3205},{"krate":0,"index":3206}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3205},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":457976,"byte_end":457980,"line_start":20,"line_end":20,"column_start":8,"column_end":12},"name":"wrap","qualname":"::types::complex::FFFI::wrap","value":"fn (self) -> T","parent":{"krate":0,"index":3203},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3206},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":458000,"byte_end":458006,"line_start":21,"line_end":21,"column_start":8,"column_end":14},"name":"unwrap","qualname":"::types::complex::FFFI::unwrap","value":"fn (t: T) -> Self","parent":{"krate":0,"index":3203},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":6997},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":458074,"byte_end":458084,"line_start":26,"line_end":26,"column_start":12,"column_end":22},"name":"ComplexF64","qualname":"::types::complex::ComplexF64","value":"ComplexF64 { dat }","parent":null,"children":[{"krate":0,"index":6998}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"repr(C)","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":458025,"byte_end":458035,"line_start":24,"line_end":24,"column_start":1,"column_end":11}}]},{"kind":"Field","id":{"krate":0,"index":6998},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":458095,"byte_end":458098,"line_start":27,"line_end":27,"column_start":9,"column_end":12},"name":"dat","qualname":"::types::complex::ComplexF64::dat","value":"[f64; _]","parent":{"krate":0,"index":6997},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3208},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":458261,"byte_end":458265,"line_start":33,"line_end":33,"column_start":12,"column_end":16},"name":"rect","qualname":"<ComplexF64>::rect","value":"fn (x: f64, y: f64) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function uses the rectangular Cartesian components (x,y) to return the complex number\n z = x + i y.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3209},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":458527,"byte_end":458532,"line_start":39,"line_end":39,"column_start":12,"column_end":17},"name":"polar","qualname":"<ComplexF64>::polar","value":"fn (r: f64, theta: f64) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex number z = r \\exp(i \\theta) = r (\\cos(\\theta) + i\n \\sin(\\theta)) from the polar representation (r,theta).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3210},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":458762,"byte_end":458765,"line_start":45,"line_end":45,"column_start":12,"column_end":15},"name":"arg","qualname":"<ComplexF64>::arg","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the argument of the complex number z, \\arg(z), where -\\pi < \\arg(z)\n <= \\pi.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3211},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":458931,"byte_end":458934,"line_start":50,"line_end":50,"column_start":12,"column_end":15},"name":"abs","qualname":"<ComplexF64>::abs","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the magnitude of the complex number z, |z|.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3212},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":459110,"byte_end":459114,"line_start":55,"line_end":55,"column_start":12,"column_end":16},"name":"abs2","qualname":"<ComplexF64>::abs2","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the squared magnitude of the complex number z, |z|^2.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3213},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":459525,"byte_end":459531,"line_start":66,"line_end":66,"column_start":12,"column_end":18},"name":"logabs","qualname":"<ComplexF64>::logabs","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the natural logarithm of the magnitude of the complex number z,\n \\log|z|.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3214},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":459703,"byte_end":459706,"line_start":71,"line_end":71,"column_start":12,"column_end":15},"name":"add","qualname":"<ComplexF64>::add","value":"fn (&self, other: &ComplexF64) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the sum of the complex numbers a and b, z=a+b.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3215},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":459932,"byte_end":459935,"line_start":76,"line_end":76,"column_start":12,"column_end":15},"name":"sub","qualname":"<ComplexF64>::sub","value":"fn (&self, other: &ComplexF64) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the difference of the complex numbers a and b, z=a-b.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3216},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":460157,"byte_end":460160,"line_start":81,"line_end":81,"column_start":12,"column_end":15},"name":"mul","qualname":"<ComplexF64>::mul","value":"fn (&self, other: &ComplexF64) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the product of the complex numbers a and b, z=ab.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3217},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":460384,"byte_end":460387,"line_start":86,"line_end":86,"column_start":12,"column_end":15},"name":"div","qualname":"<ComplexF64>::div","value":"fn (&self, other: &ComplexF64) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the quotient of the complex numbers a and b, z=a/b.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3218},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":460621,"byte_end":460629,"line_start":91,"line_end":91,"column_start":12,"column_end":20},"name":"add_real","qualname":"<ComplexF64>::add_real","value":"fn (&self, x: f64) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the sum of the complex number a and the real number x, z=a+x.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3219},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":460850,"byte_end":460858,"line_start":96,"line_end":96,"column_start":12,"column_end":20},"name":"sub_real","qualname":"<ComplexF64>::sub_real","value":"fn (&self, x: f64) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the difference of the complex number a and the real number x, z=a-x.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3220},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":461075,"byte_end":461083,"line_start":101,"line_end":101,"column_start":12,"column_end":20},"name":"mul_real","qualname":"<ComplexF64>::mul_real","value":"fn (&self, x: f64) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the product of the complex number a and the real number x, z=ax.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3221},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":461302,"byte_end":461310,"line_start":106,"line_end":106,"column_start":12,"column_end":20},"name":"div_real","qualname":"<ComplexF64>::div_real","value":"fn (&self, x: f64) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the quotient of the complex number a and the real number x, z=a/x.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3222},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":461535,"byte_end":461543,"line_start":111,"line_end":111,"column_start":12,"column_end":20},"name":"add_imag","qualname":"<ComplexF64>::add_imag","value":"fn (&self, x: f64) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the sum of the complex number a and the imaginary number iy, z=a+iy.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3223},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":461779,"byte_end":461787,"line_start":117,"line_end":117,"column_start":12,"column_end":20},"name":"sub_imag","qualname":"<ComplexF64>::sub_imag","value":"fn (&self, x: f64) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the difference of the complex number a and the imaginary number iy,\n z=a-iy.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3224},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":462022,"byte_end":462030,"line_start":123,"line_end":123,"column_start":12,"column_end":20},"name":"mul_imag","qualname":"<ComplexF64>::mul_imag","value":"fn (&self, x: f64) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the product of the complex number a and the imaginary number iy,\n z=a*(iy).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3225},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":462266,"byte_end":462274,"line_start":129,"line_end":129,"column_start":12,"column_end":20},"name":"div_imag","qualname":"<ComplexF64>::div_imag","value":"fn (&self, x: f64) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the quotient of the complex number a and the imaginary number iy,\n z=a/(iy).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3226},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":462488,"byte_end":462497,"line_start":134,"line_end":134,"column_start":12,"column_end":21},"name":"conjugate","qualname":"<ComplexF64>::conjugate","value":"fn (&self) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex conjugate of the complex number z, z^* = x - i y.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3227},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":462730,"byte_end":462737,"line_start":140,"line_end":140,"column_start":12,"column_end":19},"name":"inverse","qualname":"<ComplexF64>::inverse","value":"fn (&self) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the inverse, or reciprocal, of the complex number z, 1/z = (x - i y)/\n (x^2 + y^2).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3228},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":462934,"byte_end":462942,"line_start":145,"line_end":145,"column_start":12,"column_end":20},"name":"negative","qualname":"<ComplexF64>::negative","value":"fn (&self) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the negative of the complex number z, -z = (-x) + i(-y).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3229},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":463262,"byte_end":463266,"line_start":153,"line_end":153,"column_start":12,"column_end":16},"name":"sqrt","qualname":"<ComplexF64>::sqrt","value":"fn (&self) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the square root of the complex number z, \\sqrt z.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3230},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":463474,"byte_end":463483,"line_start":158,"line_end":158,"column_start":12,"column_end":21},"name":"sqrt_real","qualname":"<ComplexF64>::sqrt_real","value":"fn (x: f64) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex square root of the real number x, where x may be negative.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3231},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":463765,"byte_end":463768,"line_start":164,"line_end":164,"column_start":12,"column_end":15},"name":"pow","qualname":"<ComplexF64>::pow","value":"fn (&self, other: &ComplexF64) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" The function returns the complex number z raised to the complex power a, z^a.\n This is computed as \\exp(\\log(z)*a) using complex logarithms and complex exponentials.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3232},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":463994,"byte_end":464002,"line_start":169,"line_end":169,"column_start":12,"column_end":20},"name":"pow_real","qualname":"<ComplexF64>::pow_real","value":"fn (&self, x: f64) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex number z raised to the real power x, z^x.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3233},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":464212,"byte_end":464215,"line_start":174,"line_end":174,"column_start":12,"column_end":15},"name":"exp","qualname":"<ComplexF64>::exp","value":"fn (&self) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex exponential of the complex number z, \\exp(z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3234},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":464490,"byte_end":464493,"line_start":182,"line_end":182,"column_start":12,"column_end":15},"name":"log","qualname":"<ComplexF64>::log","value":"fn (&self) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex natural logarithm (base e) of the complex number z,\n \\log(z).","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3235},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":464697,"byte_end":464702,"line_start":187,"line_end":187,"column_start":12,"column_end":17},"name":"log10","qualname":"<ComplexF64>::log10","value":"fn (&self) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex base-10 logarithm of the complex number z, \\log_10 (z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3236},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":464969,"byte_end":464974,"line_start":193,"line_end":193,"column_start":12,"column_end":17},"name":"log_b","qualname":"<ComplexF64>::log_b","value":"fn (&self, other: &ComplexF64) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex base-b logarithm of the complex number z, \\log_b(z).\n This quantity is computed as the ratio \\log(z)/\\log(b).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3237},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":465237,"byte_end":465240,"line_start":199,"line_end":199,"column_start":12,"column_end":15},"name":"sin","qualname":"<ComplexF64>::sin","value":"fn (&self) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex sine of the complex number z, \\sin(z) = (\\exp(iz) -\n \\exp(-iz))/(2i).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3238},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":465464,"byte_end":465467,"line_start":205,"line_end":205,"column_start":12,"column_end":15},"name":"cos","qualname":"<ComplexF64>::cos","value":"fn (&self) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex cosine of the complex number z, \\cos(z) = (\\exp(iz) +\n \\exp(-iz))/2.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3239},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":465683,"byte_end":465686,"line_start":211,"line_end":211,"column_start":12,"column_end":15},"name":"tan","qualname":"<ComplexF64>::tan","value":"fn (&self) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex tangent of the complex number z, \\tan(z) =\n \\sin(z)/\\cos(z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3240},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":465887,"byte_end":465890,"line_start":216,"line_end":216,"column_start":12,"column_end":15},"name":"sec","qualname":"<ComplexF64>::sec","value":"fn (&self) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex secant of the complex number z, \\sec(z) = 1/\\cos(z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3241},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":466093,"byte_end":466096,"line_start":221,"line_end":221,"column_start":12,"column_end":15},"name":"csc","qualname":"<ComplexF64>::csc","value":"fn (&self) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex cosecant of the complex number z, \\csc(z) = 1/\\sin(z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3242},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":466300,"byte_end":466303,"line_start":226,"line_end":226,"column_start":12,"column_end":15},"name":"cot","qualname":"<ComplexF64>::cot","value":"fn (&self) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex cotangent of the complex number z, \\cot(z) = 1/\\tan(z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3243},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":466575,"byte_end":466581,"line_start":232,"line_end":232,"column_start":12,"column_end":18},"name":"arcsin","qualname":"<ComplexF64>::arcsin","value":"fn (&self) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex arcsine of the complex number z, \\arcsin(z).\n The branch cuts are on the real axis, less than -1 and greater than 1.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3244},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":467075,"byte_end":467086,"line_start":241,"line_end":241,"column_start":12,"column_end":23},"name":"arcsin_real","qualname":"<ComplexF64>::arcsin_real","value":"fn (z: f64) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex arcsine of the real number z, \\arcsin(z).\n \n * For z between -1 and 1, the function returns a real value in the range [-\\pi/2,\\pi/2].\n * For z less than -1 the result has a real part of -\\pi/2 and a positive imaginary part.\n * For z greater than 1 the result has a real part of \\pi/2 and a negative imaginary part.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3245},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":467357,"byte_end":467363,"line_start":247,"line_end":247,"column_start":12,"column_end":18},"name":"arccos","qualname":"<ComplexF64>::arccos","value":"fn (&self) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex arccosine of the complex number z, \\arccos(z).\n The branch cuts are on the real axis, less than -1 and greater than 1.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3246},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":467827,"byte_end":467838,"line_start":256,"line_end":256,"column_start":12,"column_end":23},"name":"arccos_real","qualname":"<ComplexF64>::arccos_real","value":"fn (z: f64) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex arccosine of the real number z, \\arccos(z).\n \n * For z between -1 and 1, the function returns a real value in the range [0,\\pi].\n * For z less than -1 the result has a real part of \\pi and a negative imaginary part.\n * For z greater than 1 the result is purely imaginary and positive.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3247},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":468104,"byte_end":468110,"line_start":262,"line_end":262,"column_start":12,"column_end":18},"name":"arctan","qualname":"<ComplexF64>::arctan","value":"fn (&self) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex arctangent of the complex number z, \\arctan(z).\n The branch cuts are on the imaginary axis, below -i and above i.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3248},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":468331,"byte_end":468337,"line_start":268,"line_end":268,"column_start":12,"column_end":18},"name":"arcsec","qualname":"<ComplexF64>::arcsec","value":"fn (&self) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex arcsecant of the complex number z, \\arcsec(z) =\n \\arccos(1/z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3249},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":468547,"byte_end":468558,"line_start":273,"line_end":273,"column_start":12,"column_end":23},"name":"arcsec_real","qualname":"<ComplexF64>::arcsec_real","value":"fn (z: f64) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex arcsecant of the real number z, \\arcsec(z) = \\arccos(1/z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3250},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":468775,"byte_end":468781,"line_start":279,"line_end":279,"column_start":12,"column_end":18},"name":"arccsc","qualname":"<ComplexF64>::arccsc","value":"fn (&self) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex arccosecant of the complex number z, \\arccsc(z) =\n \\arcsin(1/z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3251},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":469001,"byte_end":469012,"line_start":285,"line_end":285,"column_start":12,"column_end":23},"name":"arccsc_real","qualname":"<ComplexF64>::arccsc_real","value":"fn (z: f64) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex arccosecant of the real number z, \\arccsc(z) =\n \\arcsin(1/z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3252},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":469230,"byte_end":469236,"line_start":291,"line_end":291,"column_start":12,"column_end":18},"name":"arccot","qualname":"<ComplexF64>::arccot","value":"fn (&self) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex arccotangent of the complex number z, \\arccot(z) =\n \\arctan(1/z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3253},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":469471,"byte_end":469475,"line_start":297,"line_end":297,"column_start":12,"column_end":16},"name":"sinh","qualname":"<ComplexF64>::sinh","value":"fn (&self) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex hyperbolic sine of the complex number z, \\sinh(z) =\n (\\exp(z) - \\exp(-z))/2.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3254},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":469710,"byte_end":469714,"line_start":303,"line_end":303,"column_start":12,"column_end":16},"name":"cosh","qualname":"<ComplexF64>::cosh","value":"fn (&self) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex hyperbolic cosine of the complex number z, \\cosh(z) =\n (\\exp(z) + \\exp(-z))/2.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3255},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":469945,"byte_end":469949,"line_start":309,"line_end":309,"column_start":12,"column_end":16},"name":"tanh","qualname":"<ComplexF64>::tanh","value":"fn (&self) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex hyperbolic tangent of the complex number z, \\tanh(z) =\n \\sinh(z)/\\cosh(z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3256},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":470172,"byte_end":470176,"line_start":315,"line_end":315,"column_start":12,"column_end":16},"name":"sech","qualname":"<ComplexF64>::sech","value":"fn (&self) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex hyperbolic secant of the complex number z, \\sech(z) =\n 1/\\cosh(z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3257},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":470401,"byte_end":470405,"line_start":321,"line_end":321,"column_start":12,"column_end":16},"name":"csch","qualname":"<ComplexF64>::csch","value":"fn (&self) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex hyperbolic cosecant of the complex number z, \\csch(z) =\n 1/\\sinh(z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3258},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":470631,"byte_end":470635,"line_start":327,"line_end":327,"column_start":12,"column_end":16},"name":"coth","qualname":"<ComplexF64>::coth","value":"fn (&self) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex hyperbolic cotangent of the complex number z, \\coth(z) =\n 1/\\tanh(z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3259},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":470914,"byte_end":470921,"line_start":333,"line_end":333,"column_start":12,"column_end":19},"name":"arcsinh","qualname":"<ComplexF64>::arcsinh","value":"fn (&self) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex hyperbolic arcsine of the complex number z, \\arcsinh(z).\n The branch cuts are on the imaginary axis, below -i and above i.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3260},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":471342,"byte_end":471349,"line_start":341,"line_end":341,"column_start":12,"column_end":19},"name":"arccosh","qualname":"<ComplexF64>::arccosh","value":"fn (&self) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex hyperbolic arccosine of the complex number z, \\arccosh(z).\n The branch cut is on the real axis, less than 1.\n Note that in this case we use the negative square root in formula 4.6.21 of Abramowitz &\n Stegun giving \\arccosh(z)=\\log(z-\\sqrt{z^2-1}).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3261},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":471557,"byte_end":471569,"line_start":346,"line_end":346,"column_start":12,"column_end":24},"name":"arccosh_real","qualname":"<ComplexF64>::arccosh_real","value":"fn (z: f64) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex hyperbolic arccosine of the real number z, \\arccosh(z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3262},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":471870,"byte_end":471877,"line_start":354,"line_end":354,"column_start":12,"column_end":19},"name":"arctanh","qualname":"<ComplexF64>::arctanh","value":"fn (&self) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex hyperbolic arctangent of the complex number z,\n \\arctanh(z).","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3263},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":472086,"byte_end":472098,"line_start":359,"line_end":359,"column_start":12,"column_end":24},"name":"arctanh_real","qualname":"<ComplexF64>::arctanh_real","value":"fn (z: f64) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex hyperbolic arctangent of the real number z, \\arctanh(z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3264},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":472327,"byte_end":472334,"line_start":365,"line_end":365,"column_start":12,"column_end":19},"name":"arcsech","qualname":"<ComplexF64>::arcsech","value":"fn (&self) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex hyperbolic arcsecant of the complex number z, \\arcsech(z)\n = \\arccosh(1/z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3265},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":472570,"byte_end":472577,"line_start":371,"line_end":371,"column_start":12,"column_end":19},"name":"arccsch","qualname":"<ComplexF64>::arccsch","value":"fn (&self) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex hyperbolic arccosecant of the complex number z,\n \\arccsch(z) = \\arcsin(1/z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3266},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":472815,"byte_end":472822,"line_start":377,"line_end":377,"column_start":12,"column_end":19},"name":"arccoth","qualname":"<ComplexF64>::arccoth","value":"fn (&self) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex hyperbolic arccotangent of the complex number z,\n \\arccoth(z) = \\arctanh(1/z).\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":7005},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":474562,"byte_end":474572,"line_start":454,"line_end":454,"column_start":12,"column_end":22},"name":"ComplexF32","qualname":"::types::complex::ComplexF32","value":"ComplexF32 { dat }","parent":null,"children":[{"krate":0,"index":7006}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"repr(C)","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":474513,"byte_end":474523,"line_start":452,"line_end":452,"column_start":1,"column_end":11}}]},{"kind":"Field","id":{"krate":0,"index":7006},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":474583,"byte_end":474586,"line_start":455,"line_end":455,"column_start":9,"column_end":12},"name":"dat","qualname":"::types::complex::ComplexF32::dat","value":"[f32; _]","parent":{"krate":0,"index":7005},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3286},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":474749,"byte_end":474753,"line_start":461,"line_end":461,"column_start":12,"column_end":16},"name":"rect","qualname":"<ComplexF32>::rect","value":"fn (x: f32, y: f32) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function uses the rectangular Cartesian components (x,y) to return the complex number\n z = x + i y.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3287},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":475029,"byte_end":475034,"line_start":467,"line_end":467,"column_start":12,"column_end":17},"name":"polar","qualname":"<ComplexF32>::polar","value":"fn (r: f32, theta: f32) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex number z = r \\exp(i \\theta) = r (\\cos(\\theta) + i\n \\sin(\\theta)) from the polar representation (r,theta).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3288},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":475278,"byte_end":475281,"line_start":473,"line_end":473,"column_start":12,"column_end":15},"name":"arg","qualname":"<ComplexF32>::arg","value":"fn (&self) -> f32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the argument of the complex number z, \\arg(z), where -\\pi < \\arg(z)\n <= \\pi.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3289},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":475454,"byte_end":475457,"line_start":478,"line_end":478,"column_start":12,"column_end":15},"name":"abs","qualname":"<ComplexF32>::abs","value":"fn (&self) -> f32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the magnitude of the complex number z, |z|.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3290},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":475640,"byte_end":475644,"line_start":483,"line_end":483,"column_start":12,"column_end":16},"name":"abs2","qualname":"<ComplexF32>::abs2","value":"fn (&self) -> f32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the squared magnitude of the complex number z, |z|^2.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3291},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":476054,"byte_end":476060,"line_start":493,"line_end":493,"column_start":12,"column_end":18},"name":"logabs","qualname":"<ComplexF32>::logabs","value":"fn (&self) -> f32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the natural logarithm of the magnitude of the complex number z,\n \\log|z|.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3292},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":476239,"byte_end":476242,"line_start":498,"line_end":498,"column_start":12,"column_end":15},"name":"add","qualname":"<ComplexF32>::add","value":"fn (&self, other: &ComplexF32) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the sum of the complex numbers a and b, z=a+b.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3293},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":476468,"byte_end":476471,"line_start":503,"line_end":503,"column_start":12,"column_end":15},"name":"sub","qualname":"<ComplexF32>::sub","value":"fn (&self, other: &ComplexF32) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the difference of the complex numbers a and b, z=a-b.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3294},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":476693,"byte_end":476696,"line_start":508,"line_end":508,"column_start":12,"column_end":15},"name":"mul","qualname":"<ComplexF32>::mul","value":"fn (&self, other: &ComplexF32) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the product of the complex numbers a and b, z=ab.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3295},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":476920,"byte_end":476923,"line_start":513,"line_end":513,"column_start":12,"column_end":15},"name":"div","qualname":"<ComplexF32>::div","value":"fn (&self, other: &ComplexF32) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the quotient of the complex numbers a and b, z=a/b.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3296},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":477157,"byte_end":477165,"line_start":518,"line_end":518,"column_start":12,"column_end":20},"name":"add_real","qualname":"<ComplexF32>::add_real","value":"fn (&self, x: f32) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the sum of the complex number a and the real number x, z=a+x.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3297},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":477393,"byte_end":477401,"line_start":523,"line_end":523,"column_start":12,"column_end":20},"name":"sub_real","qualname":"<ComplexF32>::sub_real","value":"fn (&self, x: f32) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the difference of the complex number a and the real number x, z=a-x.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3298},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":477625,"byte_end":477633,"line_start":528,"line_end":528,"column_start":12,"column_end":20},"name":"mul_real","qualname":"<ComplexF32>::mul_real","value":"fn (&self, x: f32) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the product of the complex number a and the real number x, z=ax.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3299},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":477859,"byte_end":477867,"line_start":533,"line_end":533,"column_start":12,"column_end":20},"name":"div_real","qualname":"<ComplexF32>::div_real","value":"fn (&self, x: f32) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the quotient of the complex number a and the real number x, z=a/x.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3300},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":478099,"byte_end":478107,"line_start":538,"line_end":538,"column_start":12,"column_end":20},"name":"add_imag","qualname":"<ComplexF32>::add_imag","value":"fn (&self, x: f32) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the sum of the complex number a and the imaginary number iy, z=a+iy.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3301},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":478342,"byte_end":478350,"line_start":543,"line_end":543,"column_start":12,"column_end":20},"name":"sub_imag","qualname":"<ComplexF32>::sub_imag","value":"fn (&self, x: f32) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the difference of the complex number a and the imaginary number iy, z=a-iy.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3302},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":478584,"byte_end":478592,"line_start":548,"line_end":548,"column_start":12,"column_end":20},"name":"mul_imag","qualname":"<ComplexF32>::mul_imag","value":"fn (&self, x: f32) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the product of the complex number a and the imaginary number iy, z=a*(iy).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3303},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":478827,"byte_end":478835,"line_start":553,"line_end":553,"column_start":12,"column_end":20},"name":"div_imag","qualname":"<ComplexF32>::div_imag","value":"fn (&self, x: f32) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the quotient of the complex number a and the imaginary number iy, z=a/(iy).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3304},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":479056,"byte_end":479065,"line_start":558,"line_end":558,"column_start":12,"column_end":21},"name":"conjugate","qualname":"<ComplexF32>::conjugate","value":"fn (&self) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex conjugate of the complex number z, z^* = x - i y.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3305},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":479298,"byte_end":479305,"line_start":564,"line_end":564,"column_start":12,"column_end":19},"name":"inverse","qualname":"<ComplexF32>::inverse","value":"fn (&self) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the inverse, or reciprocal, of the complex number z, 1/z = (x - i y)/\n (x^2 + y^2).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3306},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":479502,"byte_end":479510,"line_start":569,"line_end":569,"column_start":12,"column_end":20},"name":"negative","qualname":"<ComplexF32>::negative","value":"fn (&self) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the negative of the complex number z, -z = (-x) + i(-y).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3307},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":479830,"byte_end":479834,"line_start":577,"line_end":577,"column_start":12,"column_end":16},"name":"sqrt","qualname":"<ComplexF32>::sqrt","value":"fn (&self) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the square root of the complex number z, \\sqrt z.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3308},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":480042,"byte_end":480051,"line_start":582,"line_end":582,"column_start":12,"column_end":21},"name":"sqrt_real","qualname":"<ComplexF32>::sqrt_real","value":"fn (x: f32) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex square root of the real number x, where x may be negative.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3309},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":480348,"byte_end":480351,"line_start":589,"line_end":589,"column_start":12,"column_end":15},"name":"pow","qualname":"<ComplexF32>::pow","value":"fn (&self, other: &ComplexF32) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" The function returns the complex number z raised to the complex power a, z^a.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3310},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":480577,"byte_end":480585,"line_start":594,"line_end":594,"column_start":12,"column_end":20},"name":"pow_real","qualname":"<ComplexF32>::pow_real","value":"fn (&self, x: f32) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex number z raised to the real power x, z^x.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3311},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":480802,"byte_end":480805,"line_start":599,"line_end":599,"column_start":12,"column_end":15},"name":"exp","qualname":"<ComplexF32>::exp","value":"fn (&self) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex exponential of the complex number z, \\exp(z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3312},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":481064,"byte_end":481067,"line_start":605,"line_end":605,"column_start":12,"column_end":15},"name":"log","qualname":"<ComplexF32>::log","value":"fn (&self) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex natural logarithm (base e) of the complex number z, \\log(z).\n The branch cut is the negative real axis.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3313},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":481271,"byte_end":481276,"line_start":610,"line_end":610,"column_start":12,"column_end":17},"name":"log10","qualname":"<ComplexF32>::log10","value":"fn (&self) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex base-10 logarithm of the complex number z, \\log_10 (z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3314},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":481543,"byte_end":481548,"line_start":616,"line_end":616,"column_start":12,"column_end":17},"name":"log_b","qualname":"<ComplexF32>::log_b","value":"fn (&self, other: &ComplexF32) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex base-b logarithm of the complex number z, \\log_b(z).\n This quantity is computed as the ratio \\log(z)/\\log(b).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3315},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":481811,"byte_end":481814,"line_start":622,"line_end":622,"column_start":12,"column_end":15},"name":"sin","qualname":"<ComplexF32>::sin","value":"fn (&self) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex sine of the complex number z, \\sin(z) = (\\exp(iz) -\n \\exp(-iz))/(2i).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3316},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":482038,"byte_end":482041,"line_start":628,"line_end":628,"column_start":12,"column_end":15},"name":"cos","qualname":"<ComplexF32>::cos","value":"fn (&self) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex cosine of the complex number z, \\cos(z) = (\\exp(iz) +\n \\exp(-iz))/2.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3317},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":482257,"byte_end":482260,"line_start":634,"line_end":634,"column_start":12,"column_end":15},"name":"tan","qualname":"<ComplexF32>::tan","value":"fn (&self) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex tangent of the complex number z, \\tan(z) =\n \\sin(z)/\\cos(z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3318},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":482461,"byte_end":482464,"line_start":639,"line_end":639,"column_start":12,"column_end":15},"name":"sec","qualname":"<ComplexF32>::sec","value":"fn (&self) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex secant of the complex number z, \\sec(z) = 1/\\cos(z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3319},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":482667,"byte_end":482670,"line_start":644,"line_end":644,"column_start":12,"column_end":15},"name":"csc","qualname":"<ComplexF32>::csc","value":"fn (&self) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex cosecant of the complex number z, \\csc(z) = 1/\\sin(z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3320},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":482874,"byte_end":482877,"line_start":649,"line_end":649,"column_start":12,"column_end":15},"name":"cot","qualname":"<ComplexF32>::cot","value":"fn (&self) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex cotangent of the complex number z, \\cot(z) = 1/\\tan(z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3321},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":483149,"byte_end":483155,"line_start":655,"line_end":655,"column_start":12,"column_end":18},"name":"arcsin","qualname":"<ComplexF32>::arcsin","value":"fn (&self) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex arcsine of the complex number z, \\arcsin(z).\n The branch cuts are on the real axis, less than -1 and greater than 1.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3322},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":483649,"byte_end":483660,"line_start":664,"line_end":664,"column_start":12,"column_end":23},"name":"arcsin_real","qualname":"<ComplexF32>::arcsin_real","value":"fn (z: f32) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex arcsine of the real number z, \\arcsin(z).\n \n * For z between -1 and 1, the function returns a real value in the range [-\\pi/2,\\pi/2].\n * For z less than -1 the result has a real part of -\\pi/2 and a positive imaginary part.\n * For z greater than 1 the result has a real part of \\pi/2 and a negative imaginary part.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3323},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":483938,"byte_end":483944,"line_start":670,"line_end":670,"column_start":12,"column_end":18},"name":"arccos","qualname":"<ComplexF32>::arccos","value":"fn (&self) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex arccosine of the complex number z, \\arccos(z).\n The branch cuts are on the real axis, less than -1 and greater than 1.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3324},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":484408,"byte_end":484419,"line_start":679,"line_end":679,"column_start":12,"column_end":23},"name":"arccos_real","qualname":"<ComplexF32>::arccos_real","value":"fn (z: f32) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex arccosine of the real number z, \\arccos(z).\n \n * For z between -1 and 1, the function returns a real value in the range [0,\\pi].\n * For z less than -1 the result has a real part of \\pi and a negative imaginary part.\n * For z greater than 1 the result is purely imaginary and positive.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3325},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":484692,"byte_end":484698,"line_start":685,"line_end":685,"column_start":12,"column_end":18},"name":"arctan","qualname":"<ComplexF32>::arctan","value":"fn (&self) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex arctangent of the complex number z, \\arctan(z).\n The branch cuts are on the imaginary axis, below -i and above i.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3326},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":484920,"byte_end":484926,"line_start":691,"line_end":691,"column_start":12,"column_end":18},"name":"arcsec","qualname":"<ComplexF32>::arcsec","value":"fn (&self) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex arcsecant of the complex number z, \\arcsec(z) = \n \\arccos(1/z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3327},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":485136,"byte_end":485147,"line_start":696,"line_end":696,"column_start":12,"column_end":23},"name":"arcsec_real","qualname":"<ComplexF32>::arcsec_real","value":"fn (z: f32) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex arcsecant of the real number z, \\arcsec(z) = \\arccos(1/z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3328},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":485371,"byte_end":485377,"line_start":702,"line_end":702,"column_start":12,"column_end":18},"name":"arccsc","qualname":"<ComplexF32>::arccsc","value":"fn (&self) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex arccosecant of the complex number z, \\arccsc(z) =\n \\arcsin(1/z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3329},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":485597,"byte_end":485608,"line_start":708,"line_end":708,"column_start":12,"column_end":23},"name":"arccsc_real","qualname":"<ComplexF32>::arccsc_real","value":"fn (z: f32) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex arccosecant of the real number z, \\arccsc(z) =\n \\arcsin(1/z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3330},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":485833,"byte_end":485839,"line_start":714,"line_end":714,"column_start":12,"column_end":18},"name":"arccot","qualname":"<ComplexF32>::arccot","value":"fn (&self) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex arccotangent of the complex number z, \\arccot(z) =\n \\arctan(1/z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3331},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":486074,"byte_end":486078,"line_start":720,"line_end":720,"column_start":12,"column_end":16},"name":"sinh","qualname":"<ComplexF32>::sinh","value":"fn (&self) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex hyperbolic sine of the complex number z, \\sinh(z) =\n (\\exp(z) - \\exp(-z))/2.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3332},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":486313,"byte_end":486317,"line_start":726,"line_end":726,"column_start":12,"column_end":16},"name":"cosh","qualname":"<ComplexF32>::cosh","value":"fn (&self) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex hyperbolic cosine of the complex number z, \\cosh(z) =\n (\\exp(z) + \\exp(-z))/2.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3333},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":486548,"byte_end":486552,"line_start":732,"line_end":732,"column_start":12,"column_end":16},"name":"tanh","qualname":"<ComplexF32>::tanh","value":"fn (&self) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex hyperbolic tangent of the complex number z, \\tanh(z) =\n \\sinh(z)/\\cosh(z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3334},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":486775,"byte_end":486779,"line_start":738,"line_end":738,"column_start":12,"column_end":16},"name":"sech","qualname":"<ComplexF32>::sech","value":"fn (&self) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex hyperbolic secant of the complex number z, \\sech(z) =\n 1/\\cosh(z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3335},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":487004,"byte_end":487008,"line_start":744,"line_end":744,"column_start":12,"column_end":16},"name":"csch","qualname":"<ComplexF32>::csch","value":"fn (&self) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex hyperbolic cosecant of the complex number z, \\csch(z) =\n 1/\\sinh(z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3336},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":487234,"byte_end":487238,"line_start":750,"line_end":750,"column_start":12,"column_end":16},"name":"coth","qualname":"<ComplexF32>::coth","value":"fn (&self) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex hyperbolic cotangent of the complex number z, \\coth(z) =\n 1/\\tanh(z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3337},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":487517,"byte_end":487524,"line_start":756,"line_end":756,"column_start":12,"column_end":19},"name":"arcsinh","qualname":"<ComplexF32>::arcsinh","value":"fn (&self) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex hyperbolic arcsine of the complex number z, \\arcsinh(z).\n The branch cuts are on the imaginary axis, below -i and above i.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3338},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":487961,"byte_end":487968,"line_start":766,"line_end":766,"column_start":12,"column_end":19},"name":"arccosh","qualname":"<ComplexF32>::arccosh","value":"fn (&self) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex hyperbolic arccosine of the complex number z, \\arccosh(z).","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3339},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":488176,"byte_end":488188,"line_start":771,"line_end":771,"column_start":12,"column_end":24},"name":"arccosh_real","qualname":"<ComplexF32>::arccosh_real","value":"fn (z: f32) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex hyperbolic arccosine of the real number z, \\arccosh(z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3340},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":488496,"byte_end":488503,"line_start":779,"line_end":779,"column_start":12,"column_end":19},"name":"arctanh","qualname":"<ComplexF32>::arctanh","value":"fn (&self) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex hyperbolic arctangent of the complex number z, \n arctanh(z).","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3341},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":488712,"byte_end":488724,"line_start":784,"line_end":784,"column_start":12,"column_end":24},"name":"arctanh_real","qualname":"<ComplexF32>::arctanh_real","value":"fn (z: f32) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex hyperbolic arctangent of the real number z, \\arctanh(z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3342},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":488960,"byte_end":488967,"line_start":790,"line_end":790,"column_start":12,"column_end":19},"name":"arcsech","qualname":"<ComplexF32>::arcsech","value":"fn (&self) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex hyperbolic arcsecant of the complex number z, \\arcsech(z)\n = \\arccosh(1/z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3343},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":489203,"byte_end":489210,"line_start":796,"line_end":796,"column_start":12,"column_end":19},"name":"arccsch","qualname":"<ComplexF32>::arccsch","value":"fn (&self) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex hyperbolic arccosecant of the complex number z,\n \\arccsch(z) = \\arcsin(1/z).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3344},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":489448,"byte_end":489455,"line_start":802,"line_end":802,"column_start":12,"column_end":19},"name":"arccoth","qualname":"<ComplexF32>::arccoth","value":"fn (&self) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the complex hyperbolic arccotangent of the complex number z,\n \\arccoth(z) = \\arctanh(1/z).\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":3357},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/discrete_hankel.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"discrete_hankel","qualname":"::types::discrete_hankel","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/discrete_hankel.rs","parent":null,"children":[{"krate":0,"index":3358},{"krate":0,"index":3359},{"krate":0,"index":3360},{"krate":0,"index":3362},{"krate":0,"index":3369},{"krate":0,"index":3371}],"decl_id":null,"docs":"#Discrete Hankel Transforms","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":3360},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/discrete_hankel.rs","byte_start":513127,"byte_end":513141,"line_start":59,"line_end":59,"column_start":12,"column_end":26},"name":"DiscreteHankel","qualname":"::types::discrete_hankel::DiscreteHankel","value":"DiscreteHankel {  }","parent":null,"children":[{"krate":0,"index":3361}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3363},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/discrete_hankel.rs","byte_start":513289,"byte_end":513292,"line_start":65,"line_end":65,"column_start":12,"column_end":15},"name":"new","qualname":"<DiscreteHankel>::new","value":"fn (size: usize) -> Option<DiscreteHankel>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates a Discrete Hankel transform object of size `size`.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3364},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/discrete_hankel.rs","byte_start":513702,"byte_end":513715,"line_start":79,"line_end":79,"column_start":12,"column_end":25},"name":"new_with_init","qualname":"<DiscreteHankel>::new_with_init","value":"fn (size: usize, nu: f64, xmax: f64) -> Option<DiscreteHankel>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates a Discrete Hankel transform object of size `size` and initializes it\n for the given values of `nu` and `xmax`.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3365},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/discrete_hankel.rs","byte_start":514099,"byte_end":514103,"line_start":92,"line_end":92,"column_start":12,"column_end":16},"name":"init","qualname":"<DiscreteHankel>::init","value":"fn (&mut self, nu: f64, xmax: f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function initializes the transform `self` for the given values of `nu` and `xmax`.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3366},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/discrete_hankel.rs","byte_start":514584,"byte_end":514589,"line_start":101,"line_end":101,"column_start":12,"column_end":17},"name":"apply","qualname":"<DiscreteHankel>::apply","value":"fn (&self, f_in: &[f64]) -> Result<Vec<f64>, enums::Value>","parent":null,"children":[],"decl_id":null,"docs":" This function applies the transform t to the array f_in whose size is equal to the size of\n the transform. The result is stored in the array `f_out` which must be of the same length.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3367},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/discrete_hankel.rs","byte_start":515314,"byte_end":515322,"line_start":116,"line_end":116,"column_start":12,"column_end":20},"name":"x_sample","qualname":"<DiscreteHankel>::x_sample","value":"fn (&self, n: i32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the value of the n-th sample point in the unit interval,\n (j_{\\nu,n+1}/j_{\\nu,M}) X. These are the points where the function f(t) is assumed to be\n sampled.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3368},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/discrete_hankel.rs","byte_start":515515,"byte_end":515523,"line_start":121,"line_end":121,"column_start":12,"column_end":20},"name":"k_sample","qualname":"<DiscreteHankel>::k_sample","value":"fn (&self, n: i32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the value of the n-th sample point in “k-space”, j_{\\nu,n+1}/X.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":3376},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"eigen_symmetric_workspace","qualname":"::types::eigen_symmetric_workspace","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","parent":null,"children":[{"krate":0,"index":3377},{"krate":0,"index":3378},{"krate":0,"index":3379},{"krate":0,"index":3384},{"krate":0,"index":3386},{"krate":0,"index":3389},{"krate":0,"index":3391},{"krate":0,"index":3396},{"krate":0,"index":3398},{"krate":0,"index":3401},{"krate":0,"index":3403},{"krate":0,"index":3408},{"krate":0,"index":3410},{"krate":0,"index":3413},{"krate":0,"index":3415},{"krate":0,"index":3420},{"krate":0,"index":3422},{"krate":0,"index":3425},{"krate":0,"index":3427},{"krate":0,"index":3432},{"krate":0,"index":3434},{"krate":0,"index":3440},{"krate":0,"index":3442},{"krate":0,"index":3447},{"krate":0,"index":3449},{"krate":0,"index":3454},{"krate":0,"index":3456},{"krate":0,"index":3461},{"krate":0,"index":3463},{"krate":0,"index":3466},{"krate":0,"index":3468},{"krate":0,"index":3473},{"krate":0,"index":3475},{"krate":0,"index":3478},{"krate":0,"index":3480},{"krate":0,"index":3485},{"krate":0,"index":3487},{"krate":0,"index":3490},{"krate":0,"index":3492},{"krate":0,"index":3497},{"krate":0,"index":3499},{"krate":0,"index":3502},{"krate":0,"index":3504},{"krate":0,"index":3509},{"krate":0,"index":3511},{"krate":0,"index":3516},{"krate":0,"index":3518},{"krate":0,"index":3523},{"krate":0,"index":3525},{"krate":0,"index":3529},{"krate":0,"index":3531}],"decl_id":null,"docs":"#Real Symmetric Matrices","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":3384},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":521437,"byte_end":521460,"line_start":102,"line_end":102,"column_start":12,"column_end":35},"name":"EigenSymmetricWorkspace","qualname":"::types::eigen_symmetric_workspace::EigenSymmetricWorkspace","value":"EigenSymmetricWorkspace {  }","parent":null,"children":[{"krate":0,"index":3385}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3387},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":521700,"byte_end":521703,"line_start":109,"line_end":109,"column_start":12,"column_end":15},"name":"new","qualname":"<EigenSymmetricWorkspace>::new","value":"fn (n: usize) -> Option<EigenSymmetricWorkspace>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates a workspace for computing eigenvalues of n-by-n real symmetric\n matrices. The size of the workspace is O(2n).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3388},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":522265,"byte_end":522269,"line_start":123,"line_end":123,"column_start":12,"column_end":16},"name":"symm","qualname":"<EigenSymmetricWorkspace>::symm","value":"fn (&self, A: &mut MatrixF64, eval: &mut VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the eigenvalues of the real symmetric matrix `A`. The diagonal and\n lower triangular part of `A` are destroyed during the computation, but the strict upper\n triangular part is not referenced. The eigenvalues are stored in the vector `eval` and are\n unordered.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":3396},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":523289,"byte_end":523313,"line_start":157,"line_end":157,"column_start":12,"column_end":36},"name":"EigenSymmetricVWorkspace","qualname":"::types::eigen_symmetric_workspace::EigenSymmetricVWorkspace","value":"EigenSymmetricVWorkspace {  }","parent":null,"children":[{"krate":0,"index":3397}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3399},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":523572,"byte_end":523575,"line_start":164,"line_end":164,"column_start":12,"column_end":15},"name":"new","qualname":"<EigenSymmetricVWorkspace>::new","value":"fn (n: usize) -> Option<EigenSymmetricVWorkspace>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates a workspace for computing eigenvalues and eigenvectors of n-by-n\n real symmetric matrices. The size of the workspace is O(4n).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3400},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":524438,"byte_end":524443,"line_start":181,"line_end":181,"column_start":12,"column_end":17},"name":"symmv","qualname":"<EigenSymmetricVWorkspace>::symmv","value":"fn (&self, A: &mut MatrixF64, eval: &mut VectorF64, evec: &mut MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the eigenvalues and eigenvectors of the real symmetric matrix `A`.\n The diagonal and lower triangular part of `A` are destroyed during the computation, but the\n strict upper triangular part is not referenced. The eigenvalues are stored in the vector\n `eval` and are unordered. The corresponding eigenvectors are stored in the columns of the\n matrix `evec`. For example, the eigenvector in the first column corresponds to the first\n eigenvalue. The eigenvectors are guaranteed to be mutually orthogonal and normalised to unit\n magnitude.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":3408},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":525633,"byte_end":525656,"line_start":220,"line_end":220,"column_start":12,"column_end":35},"name":"EigenHermitianWorkspace","qualname":"::types::eigen_symmetric_workspace::EigenHermitianWorkspace","value":"EigenHermitianWorkspace {  }","parent":null,"children":[{"krate":0,"index":3409}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3411},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":525899,"byte_end":525902,"line_start":227,"line_end":227,"column_start":12,"column_end":15},"name":"new","qualname":"<EigenHermitianWorkspace>::new","value":"fn (n: usize) -> Option<EigenHermitianWorkspace>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates a workspace for computing eigenvalues of n-by-n complex hermitian\n matrices. The size of the workspace is O(3n).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3412},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":526631,"byte_end":526635,"line_start":242,"line_end":242,"column_start":12,"column_end":16},"name":"herm","qualname":"<EigenHermitianWorkspace>::herm","value":"fn (&mut self, A: &mut MatrixComplexF64, eval: &mut VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the eigenvalues of the complex hermitian matrix `A`. Additional\n workspace of the appropriate size must be provided in `self`. The diagonal and lower\n triangular part of `A` are destroyed during the computation, but the strict upper triangular\n part is not referenced. The imaginary parts of the diagonal are assumed to be zero and are\n not referenced. The eigenvalues are stored in the vector `eval` and are unordered.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":3420},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":527666,"byte_end":527690,"line_start":276,"line_end":276,"column_start":12,"column_end":36},"name":"EigenHermitianVWorkspace","qualname":"::types::eigen_symmetric_workspace::EigenHermitianVWorkspace","value":"EigenHermitianVWorkspace {  }","parent":null,"children":[{"krate":0,"index":3421}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3423},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":527952,"byte_end":527955,"line_start":283,"line_end":283,"column_start":12,"column_end":15},"name":"new","qualname":"<EigenHermitianVWorkspace>::new","value":"fn (n: usize) -> Option<EigenHermitianVWorkspace>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates a workspace for computing eigenvalues and eigenvectors of n-by-n\n complex hermitian matrices. The size of the workspace is O(5n).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3424},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":529001,"byte_end":529006,"line_start":302,"line_end":302,"column_start":12,"column_end":17},"name":"hermv","qualname":"<EigenHermitianVWorkspace>::hermv","value":"fn (&mut self, A: &mut MatrixComplexF64, eval: &mut VectorF64, evec: &mut MatrixComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the eigenvalues and eigenvectors of the complex hermitian matrix `A`.\n Additional workspace of the appropriate size must be provided in `self`. The diagonal and\n lower triangular part of `A` are destroyed during the computation, but the strict upper\n triangular part is not referenced. The imaginary parts of the diagonal are assumed to be\n zero and are not referenced. The eigenvalues are stored in the vector `eval` and are\n unordered. The corresponding complex eigenvectors are stored in the columns of the matrix\n `evec`. For example, the eigenvector in the first column corresponds to the first\n eigenvalue. The eigenvectors are guaranteed to be mutually orthogonal and normalised to unit\n magnitude.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":3432},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":530214,"byte_end":530235,"line_start":341,"line_end":341,"column_start":12,"column_end":33},"name":"EigenNonSymmWorkspace","qualname":"::types::eigen_symmetric_workspace::EigenNonSymmWorkspace","value":"EigenNonSymmWorkspace {  }","parent":null,"children":[{"krate":0,"index":3433}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3435},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":530479,"byte_end":530482,"line_start":348,"line_end":348,"column_start":12,"column_end":15},"name":"new","qualname":"<EigenNonSymmWorkspace>::new","value":"fn (n: usize) -> Option<EigenNonSymmWorkspace>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates a workspace for computing eigenvalues of n-by-n complex hermitian\n matrices. The size of the workspace is O(3n).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3436},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":532327,"byte_end":532333,"line_start":384,"line_end":384,"column_start":12,"column_end":18},"name":"params","qualname":"<EigenNonSymmWorkspace>::params","value":"fn (&mut self, compute_t: i32, balance: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function sets some parameters which determine how the eigenvalue problem is solved in\n subsequent calls to gsl_eigen_nonsymm.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3437},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":533112,"byte_end":533119,"line_start":395,"line_end":395,"column_start":12,"column_end":19},"name":"nonsymm","qualname":"<EigenNonSymmWorkspace>::nonsymm","value":"fn (&mut self, A: &mut MatrixF64, eval: &mut VectorComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the eigenvalues of the real nonsymmetric matrix `A` and stores them\n in the vector `eval`. If T is desired, it is stored in the upper portion of `A` on output.\n Otherwise, on output, the diagonal of `A` will contain the 1-by-1 real eigenvalues and\n 2-by-2 complex conjugate eigenvalue systems, and the rest of `A` is destroyed. In rare\n cases, this function may fail to find all eigenvalues. If this happens, an error code is\n returned and the number of converged eigenvalues is stored in w->n_evals. The converged\n eigenvalues are stored in the beginning of `eval`.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3438},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":533571,"byte_end":533580,"line_start":405,"line_end":405,"column_start":12,"column_end":21},"name":"nonsymm_Z","qualname":"<EigenNonSymmWorkspace>::nonsymm_Z","value":"fn (&mut self, A: &mut MatrixF64, eval: &mut VectorComplexF64, Z: &mut MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function is identical to gsl_eigen_nonsymm except that it also computes the Schur\n vectors and stores them into `Z`.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3439},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":534069,"byte_end":534076,"line_start":418,"line_end":418,"column_start":12,"column_end":19},"name":"n_evals","qualname":"<EigenNonSymmWorkspace>::n_evals","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":3447},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":534879,"byte_end":534901,"line_start":448,"line_end":448,"column_start":12,"column_end":34},"name":"EigenNonSymmVWorkspace","qualname":"::types::eigen_symmetric_workspace::EigenNonSymmVWorkspace","value":"EigenNonSymmVWorkspace {  }","parent":null,"children":[{"krate":0,"index":3448}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3450},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":535164,"byte_end":535167,"line_start":455,"line_end":455,"column_start":12,"column_end":15},"name":"new","qualname":"<EigenNonSymmVWorkspace>::new","value":"fn (n: usize) -> Option<EigenNonSymmVWorkspace>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates a workspace for computing eigenvalues and eigenvectors of n-by-n\n real nonsymmetric matrices. The size of the workspace is O(5n).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3451},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":535809,"byte_end":535815,"line_start":469,"line_end":469,"column_start":12,"column_end":18},"name":"params","qualname":"<EigenNonSymmVWorkspace>::params","value":"fn (&mut self, balance: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function sets parameters which determine how the eigenvalue problem is solved in\n subsequent calls to gsl_eigen_nonsymmv. If `balance` is set to 1, a balancing transformation\n is applied to the matrix. See gsl_eigen_nonsymm_params for more information. Balancing is\n turned off by default since it does not preserve the orthogonality of the Schur vectors.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3452},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":536574,"byte_end":536582,"line_start":480,"line_end":480,"column_start":12,"column_end":20},"name":"nonsymmv","qualname":"<EigenNonSymmVWorkspace>::nonsymmv","value":"fn (&mut self, A: &mut MatrixF64, eval: &mut VectorComplexF64, evec: &mut MatrixComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes eigenvalues and right eigenvectors of the n-by-n real nonsymmetric\n matrix `A`. It first calls gsl_eigen_nonsymm to compute the eigenvalues, Schur form T, and\n Schur vectors. Then it finds eigenvectors of T and backtransforms them using the Schur\n vectors. The Schur vectors are destroyed in the process, but can be saved by using\n gsl_eigen_nonsymmv_Z. The computed eigenvectors are normalized to have unit magnitude. On\n output, the upper portion of `A` contains the Schur form T. If gsl_eigen_nonsymm fails, no\n eigenvectors are computed, and an error code is returned.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3453},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":537195,"byte_end":537205,"line_start":495,"line_end":495,"column_start":12,"column_end":22},"name":"nonsymmv_Z","qualname":"<EigenNonSymmVWorkspace>::nonsymmv_Z","value":"fn (&mut self, A: &mut MatrixF64, eval: &mut VectorComplexF64, evec: &mut MatrixComplexF64, Z: &mut MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function is identical to gsl_eigen_nonsymmv except that it also saves the Schur vectors\n into `Z`.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":3461},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":538564,"byte_end":538585,"line_start":536,"line_end":536,"column_start":12,"column_end":33},"name":"EigenGenSymmWorkspace","qualname":"::types::eigen_symmetric_workspace::EigenGenSymmWorkspace","value":"EigenGenSymmWorkspace {  }","parent":null,"children":[{"krate":0,"index":3462}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3464},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":538851,"byte_end":538854,"line_start":543,"line_end":543,"column_start":12,"column_end":15},"name":"new","qualname":"<EigenGenSymmWorkspace>::new","value":"fn (n: usize) -> Option<EigenGenSymmWorkspace>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates a workspace for computing eigenvalues of n-by-n real generalized\n symmetric-definite eigensystems. The size of the workspace is O(2n).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3465},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":539362,"byte_end":539369,"line_start":556,"line_end":556,"column_start":12,"column_end":19},"name":"gensymm","qualname":"<EigenGenSymmWorkspace>::gensymm","value":"fn (&mut self, mut A: MatrixF64, B: &mut MatrixF64, eval: &mut VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the eigenvalues of the real generalized symmetric-definite matrix\n pair (A, B), and stores them in `eval`, using the method outlined above. On output, `B`\n contains its Cholesky decomposition and `A` is destroyed.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":3473},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":540568,"byte_end":540590,"line_start":595,"line_end":595,"column_start":12,"column_end":34},"name":"EigenGenSymmVWorkspace","qualname":"::types::eigen_symmetric_workspace::EigenGenSymmVWorkspace","value":"EigenGenSymmVWorkspace {  }","parent":null,"children":[{"krate":0,"index":3474}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3476},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":540875,"byte_end":540878,"line_start":602,"line_end":602,"column_start":12,"column_end":15},"name":"new","qualname":"<EigenGenSymmVWorkspace>::new","value":"fn (n: usize) -> Option<EigenGenSymmVWorkspace>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates a workspace for computing eigenvalues and eigenvectors of n-by-n\n real generalized symmetric-definite eigensystems. The size of the workspace is O(4n).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3477},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":541470,"byte_end":541478,"line_start":616,"line_end":616,"column_start":12,"column_end":20},"name":"gensymmv","qualname":"<EigenGenSymmVWorkspace>::gensymmv","value":"fn (&mut self, mut A: MatrixF64, B: &mut MatrixF64, eval: &mut VectorF64, evec: &mut MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the eigenvalues and eigenvectors of the real generalized\n symmetric-definite matrix pair (A, B), and stores them in `eval` and `evec` respectively.\n The computed eigenvectors are normalized to have unit magnitude. On output, `B` contains its\n Cholesky decomposition and `A` is destroyed.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":3485},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":542807,"byte_end":542828,"line_start":657,"line_end":657,"column_start":12,"column_end":33},"name":"EigenGenHermWorkspace","qualname":"::types::eigen_symmetric_workspace::EigenGenHermWorkspace","value":"EigenGenHermWorkspace {  }","parent":null,"children":[{"krate":0,"index":3486}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3488},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":543097,"byte_end":543100,"line_start":664,"line_end":664,"column_start":12,"column_end":15},"name":"new","qualname":"<EigenGenHermWorkspace>::new","value":"fn (n: usize) -> Option<EigenGenHermWorkspace>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates a workspace for computing eigenvalues of n-by-n complex generalized\n hermitian-definite eigensystems. The size of the workspace is O(3n).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3489},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":543611,"byte_end":543618,"line_start":677,"line_end":677,"column_start":12,"column_end":19},"name":"genherm","qualname":"<EigenGenHermWorkspace>::genherm","value":"fn (&mut self, mut A: MatrixComplexF64, B: &mut MatrixComplexF64, eval: &mut VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the eigenvalues of the complex generalized hermitian-definite matrix\n pair (A, B), and stores them in `eval`, using the method outlined above. On output, `B`\n contains its Cholesky decomposition and `A` is destroyed.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":3497},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":544831,"byte_end":544853,"line_start":716,"line_end":716,"column_start":12,"column_end":34},"name":"EigenGenHermVWorkspace","qualname":"::types::eigen_symmetric_workspace::EigenGenHermVWorkspace","value":"EigenGenHermVWorkspace {  }","parent":null,"children":[{"krate":0,"index":3498}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3500},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":545124,"byte_end":545127,"line_start":723,"line_end":723,"column_start":12,"column_end":15},"name":"new","qualname":"<EigenGenHermVWorkspace>::new","value":"fn (n: usize) -> Option<EigenGenHermVWorkspace>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates a workspace for computing eigenvalues of n-by-n complex generalized\n hermitian-definite eigensystems. The size of the workspace is O(3n).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3501},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":545641,"byte_end":545649,"line_start":736,"line_end":736,"column_start":12,"column_end":20},"name":"genhermv","qualname":"<EigenGenHermVWorkspace>::genhermv","value":"fn (&mut self, mut A: MatrixComplexF64, B: &mut MatrixComplexF64, eval: &mut VectorF64, evec: &mut MatrixComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the eigenvalues of the complex generalized hermitian-definite matrix\n pair (A, B), and stores them in `eval`, using the method outlined above. On output, `B`\n contains its Cholesky decomposition and `A` is destroyed.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":3509},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":546999,"byte_end":547016,"line_start":777,"line_end":777,"column_start":12,"column_end":29},"name":"EigenGenWorkspace","qualname":"::types::eigen_symmetric_workspace::EigenGenWorkspace","value":"EigenGenWorkspace {  }","parent":null,"children":[{"krate":0,"index":3510}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3512},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":547267,"byte_end":547270,"line_start":784,"line_end":784,"column_start":12,"column_end":15},"name":"new","qualname":"<EigenGenWorkspace>::new","value":"fn (n: usize) -> Option<EigenGenWorkspace>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates a workspace for computing eigenvalues of n-by-n real generalized\n nonsymmetric eigensystems. The size of the workspace is O(n).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3513},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":548492,"byte_end":548498,"line_start":809,"line_end":809,"column_start":12,"column_end":18},"name":"params","qualname":"<EigenGenWorkspace>::params","value":"fn (&mut self, compute_s: i32, compute_t: i32, balance: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function sets some parameters which determine how the eigenvalue problem is solved in\n subsequent calls to gsl_eigen_gen.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3514},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":549489,"byte_end":549492,"line_start":823,"line_end":823,"column_start":12,"column_end":15},"name":"gen","qualname":"<EigenGenWorkspace>::gen","value":"fn (&mut self, A: &mut MatrixF64, B: &mut MatrixF64, alpha: &mut VectorComplexF64, beta: &mut VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the eigenvalues of the real generalized nonsymmetric matrix pair\n (A, B), and stores them as pairs in (alpha, beta), where alpha is complex and beta is real.\n If \\beta_i is non-zero, then \\lambda = \\alpha_i / \\beta_i is an eigenvalue. Likewise, if\n \\alpha_i is non-zero, then \\mu = \\beta_i / \\alpha_i is an eigenvalue of the alternate\n problem \\mu A y = B y. The elements of beta are normalized to be non-negative.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3515},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":550203,"byte_end":550209,"line_start":840,"line_end":840,"column_start":12,"column_end":18},"name":"gen_QZ","qualname":"<EigenGenWorkspace>::gen_QZ","value":"fn (&mut self, A: &mut MatrixF64, B: &mut MatrixF64, alpha: &mut VectorComplexF64, beta: &mut VectorF64, Q: &mut MatrixF64, Z: &mut MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function is identical to gsl_eigen_gen except that it also computes the left and right\n Schur vectors and stores them into `Q` and `Z` respectively.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":3523},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":551656,"byte_end":551674,"line_start":885,"line_end":885,"column_start":12,"column_end":30},"name":"EigenGenVWorkspace","qualname":"::types::eigen_symmetric_workspace::EigenGenVWorkspace","value":"EigenGenVWorkspace {  }","parent":null,"children":[{"krate":0,"index":3524}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3526},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":551927,"byte_end":551930,"line_start":892,"line_end":892,"column_start":12,"column_end":15},"name":"new","qualname":"<EigenGenVWorkspace>::new","value":"fn (n: usize) -> Option<EigenGenVWorkspace>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates a workspace for computing eigenvalues of n-by-n real generalized\n nonsymmetric eigensystems. The size of the workspace is O(n).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3527},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":552930,"byte_end":552934,"line_start":910,"line_end":910,"column_start":12,"column_end":16},"name":"genv","qualname":"<EigenGenVWorkspace>::genv","value":"fn (&mut self, A: &mut MatrixF64, B: &mut MatrixF64, alpha: &mut VectorComplexF64, beta: &mut VectorF64, evec: &mut MatrixComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes eigenvalues and right eigenvectors of the n-by-n real generalized\n nonsymmetric matrix pair (A, B). The eigenvalues are stored in (alpha, beta) and the\n eigenvectors are stored in evec. It first calls gsl_eigen_gen to compute the eigenvalues,\n Schur forms, and Schur vectors. Then it finds eigenvectors of the Schur forms and\n backtransforms them using the Schur vectors. The Schur vectors are destroyed in the process,\n but can be saved by using gsl_eigen_genv_QZ. The computed eigenvectors are normalized to\n have unit magnitude. On output, (A, B) contains the generalized Schur form (S, T). If\n gsl_eigen_gen fails, no eigenvectors are computed, and an error code is returned.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3528},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":553764,"byte_end":553771,"line_start":929,"line_end":929,"column_start":12,"column_end":19},"name":"genv_QZ","qualname":"<EigenGenVWorkspace>::genv_QZ","value":"fn (&mut self, A: &mut MatrixF64, B: &mut MatrixF64, alpha: &mut VectorComplexF64, beta: &mut VectorF64, evec: &mut MatrixComplexF64, Q: &mut MatrixF64, Z: &mut MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function is identical to gsl_eigen_genv except that it also computes the left and right\n Schur vectors and stores them into `Q` and `Z` respectively.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":3536},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/fast_fourier_transforms.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"fast_fourier_transforms","qualname":"::types::fast_fourier_transforms","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/fast_fourier_transforms.rs","parent":null,"children":[{"krate":0,"index":3537},{"krate":0,"index":3538},{"krate":0,"index":3539},{"krate":0,"index":3542},{"krate":0,"index":3546},{"krate":0,"index":3548},{"krate":0,"index":3553},{"krate":0,"index":3555},{"krate":0,"index":3557},{"krate":0,"index":3559}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":3539},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/fast_fourier_transforms.rs","byte_start":561717,"byte_end":561736,"line_start":8,"line_end":8,"column_start":12,"column_end":31},"name":"FftComplexWaveTable","qualname":"::types::fast_fourier_transforms::FftComplexWaveTable","value":"FftComplexWaveTable {  }","parent":null,"children":[{"krate":0,"index":3540},{"krate":0,"index":3541}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3543},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/fast_fourier_transforms.rs","byte_start":562854,"byte_end":562857,"line_start":22,"line_end":22,"column_start":12,"column_end":15},"name":"new","qualname":"<FftComplexWaveTable>::new","value":"fn (n: usize) -> Option<FftComplexWaveTable>","parent":null,"children":[],"decl_id":null,"docs":" This function prepares a trigonometric lookup table for a complex FFT of length n. The function returns a pointer to the newly allocated\n gsl_fft_complex_wavetable if no errors were detected, and a null pointer in the case of error. The length n is factorized into a product\n of subtransforms, and the factors and their trigonometric coefficients are stored in the wavetable. The trigonometric coefficients are\n computed using direct calls to sin and cos, for accuracy. Recursion relations could be used to compute the lookup table faster, but if\n an application performs many FFTs of the same length then this computation is a one-off overhead which does not affect the final throughput.\n \n The wavetable structure can be used repeatedly for any transform of the same length. The table is not modified by calls to any of the other\n FFT functions. The same wavetable can be used for both forward and backward (or inverse) transforms of a given length.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3544},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/fast_fourier_transforms.rs","byte_start":563258,"byte_end":563264,"line_start":37,"line_end":37,"column_start":12,"column_end":18},"name":"factor","qualname":"<FftComplexWaveTable>::factor","value":"fn <'r> (&'r mut self) -> &'r mut [usize]","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":3553},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/fast_fourier_transforms.rs","byte_start":564185,"byte_end":564204,"line_start":72,"line_end":72,"column_start":12,"column_end":31},"name":"FftComplexWorkspace","qualname":"::types::fast_fourier_transforms::FftComplexWorkspace","value":"FftComplexWorkspace {  }","parent":null,"children":[{"krate":0,"index":3554}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3556},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/fast_fourier_transforms.rs","byte_start":564372,"byte_end":564375,"line_start":78,"line_end":78,"column_start":12,"column_end":15},"name":"new","qualname":"<FftComplexWorkspace>::new","value":"fn (n: usize) -> Option<FftComplexWorkspace>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates a workspace for a complex transform of length n.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":3564},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"histograms","qualname":"::types::histograms","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","parent":null,"children":[{"krate":0,"index":3565},{"krate":0,"index":3566},{"krate":0,"index":3567},{"krate":0,"index":3568},{"krate":0,"index":3570},{"krate":0,"index":3600},{"krate":0,"index":3602},{"krate":0,"index":3607},{"krate":0,"index":3609},{"krate":0,"index":3613},{"krate":0,"index":3615},{"krate":0,"index":3620},{"krate":0,"index":3622},{"krate":0,"index":3658},{"krate":0,"index":3660},{"krate":0,"index":3665},{"krate":0,"index":3667},{"krate":0,"index":3671},{"krate":0,"index":3673}],"decl_id":null,"docs":"#Histograms","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":3568},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":566954,"byte_end":566963,"line_start":31,"line_end":31,"column_start":12,"column_end":21},"name":"Histogram","qualname":"::types::histograms::Histogram","value":"Histogram {  }","parent":null,"children":[{"krate":0,"index":3569}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3571},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":567464,"byte_end":567467,"line_start":39,"line_end":39,"column_start":12,"column_end":15},"name":"new","qualname":"<Histogram>::new","value":"fn (n: usize) -> Option<Histogram>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates memory for a histogram with n bins, and returns a pointer to a newly created gsl_histogram struct. If insufficient\n memory is available a null pointer is returned and the error handler is invoked with an error code of Value::NoMem. The bins and ranges are\n not initialized, and should be prepared using one of the range-setting functions below in order to make the histogram ready for use.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3572},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":568752,"byte_end":568762,"line_start":71,"line_end":71,"column_start":12,"column_end":22},"name":"set_ranges","qualname":"<Histogram>::set_ranges","value":"fn (&mut self, range: &[f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function sets the ranges of the existing histogram h using the array range of size size. The values of the histogram bins are reset\n to zero. The range array should contain the desired bin limits. The ranges can be arbitrary, subject to the restriction that they are\n monotonically increasing.\n \n The following example shows how to create a histogram with logarithmic bins with ranges [1,10), [10,100) and [100,1000).","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3573},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":569399,"byte_end":569417,"line_start":83,"line_end":83,"column_start":12,"column_end":30},"name":"set_ranges_uniform","qualname":"<Histogram>::set_ranges_uniform","value":"fn (&mut self, xmin: f64, xmax: f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function sets the ranges of the existing histogram h to cover the range xmin to xmax uniformly. The values of the histogram bins\n are reset to zero. The bin ranges are shown in the table below,\n \n bin[0] corresponds to xmin <= x < xmin + d\n bin[1] corresponds to xmin + d <= x < xmin + 2 d\n ......\n bin[n-1] corresponds to xmin + (n-1)d <= x < xmax\n where d is the bin spacing, d = (xmax-xmin)/n.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3574},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":569763,"byte_end":569767,"line_start":89,"line_end":89,"column_start":12,"column_end":16},"name":"copy","qualname":"<Histogram>::copy","value":"fn (&self, dest: &mut Histogram) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the self histogram into the pre-existing histogram dest, making dest into an exact copy of self. The two histograms\n must be of the same size.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3575},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":570029,"byte_end":570034,"line_start":94,"line_end":94,"column_start":12,"column_end":17},"name":"clone","qualname":"<Histogram>::clone","value":"fn (&self) -> Option<Histogram>","parent":null,"children":[],"decl_id":null,"docs":" This function returns a pointer to a newly created histogram which is an exact copy of the self histogram.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3576},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":571016,"byte_end":571025,"line_start":113,"line_end":113,"column_start":12,"column_end":21},"name":"increment","qualname":"<Histogram>::increment","value":"fn (&mut self, x: f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function updates the self histogram by adding one (1.0) to the bin whose range contains the coordinate x.\n \n If x lies in the valid range of the histogram then the function returns zero to indicate success. If x is less than the lower limit of\n the histogram then the function returns Value::Dom, and none of bins are modified. Similarly, if the value of x is greater than or equal\n to the upper limit of the histogram then the function returns Value::Dom, and none of the bins are modified. The error handler is not\n called, however, since it is often necessary to compute histograms for a small range of a larger dataset, ignoring the values outside\n the range of interest.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3577},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":571331,"byte_end":571341,"line_start":119,"line_end":119,"column_start":12,"column_end":22},"name":"accumulate","qualname":"<Histogram>::accumulate","value":"fn (&mut self, x: f64, weight: f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function is similar to gsl_histogram_increment but increases the value of the appropriate bin in the histogram h by the floating-point\n number weight.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3578},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":571742,"byte_end":571745,"line_start":125,"line_end":125,"column_start":12,"column_end":15},"name":"get","qualname":"<Histogram>::get","value":"fn (&self, i: usize) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the contents of the i-th bin of the histogram h. If i lies outside the valid range of indices for the histogram then\n the error handler is called with an error code of Value::Dom and the function returns 0.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3579},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":572501,"byte_end":572510,"line_start":134,"line_end":134,"column_start":12,"column_end":21},"name":"get_range","qualname":"<Histogram>::get_range","value":"fn (&self, i: usize, lower: &mut f64, upper: &mut f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function finds the upper and lower range limits of the i-th bin of the self histogram. If the index i is valid then the corresponding\n range limits are stored in lower and upper. The lower limit is inclusive (i.e. events with this coordinate are included in the bin) and\n the upper limit is exclusive (i.e. events with the coordinate of the upper limit are excluded and fall in the neighboring higher bin,\n if it exists). The function returns 0 to indicate success. If i lies outside the valid range of indices for the histogram then\n the error handler is called and the function returns an error code of Value::Dom.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3580},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":572924,"byte_end":572927,"line_start":140,"line_end":140,"column_start":12,"column_end":15},"name":"max","qualname":"<Histogram>::max","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the maximum upper and minimum lower range limits and the number of bins of the self histogram. They provide a way\n of determining these values without accessing the gsl_histogram struct directly.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3581},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":573245,"byte_end":573248,"line_start":146,"line_end":146,"column_start":12,"column_end":15},"name":"min","qualname":"<Histogram>::min","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the maximum upper and minimum lower range limits and the number of bins of the self histogram. They provide a way\n of determining these values without accessing the gsl_histogram struct directly.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3582},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":573566,"byte_end":573570,"line_start":152,"line_end":152,"column_start":12,"column_end":16},"name":"bins","qualname":"<Histogram>::bins","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" This function returns the maximum upper and minimum lower range limits and the number of bins of the self histogram. They provide a way\n of determining these values without accessing the gsl_histogram struct directly.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3583},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":573731,"byte_end":573736,"line_start":157,"line_end":157,"column_start":12,"column_end":17},"name":"reset","qualname":"<Histogram>::reset","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function resets all the bins in the self histogram to zero.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3584},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":574366,"byte_end":574370,"line_start":165,"line_end":165,"column_start":12,"column_end":16},"name":"find","qualname":"<Histogram>::find","value":"fn (&self, x: f64, i: &mut usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function finds and sets the index i to the bin number which covers the coordinate x in the self histogram. The bin is located using\n a binary search. The search includes an optimization for histograms with uniform range, and will return the correct bin immediately in\n this case. If x is found in the range of the histogram then the function sets the index i and returns ::Value::Success. If x lies outside\n the valid range of the histogram then the function returns Value::Dom and the error handler is invoked.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3585},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":574595,"byte_end":574602,"line_start":170,"line_end":170,"column_start":12,"column_end":19},"name":"max_val","qualname":"<Histogram>::max_val","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the maximum value contained in the histogram bins.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3586},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":574874,"byte_end":574881,"line_start":176,"line_end":176,"column_start":12,"column_end":19},"name":"max_bin","qualname":"<Histogram>::max_bin","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" This function returns the index of the bin containing the maximum value. In the case where several bins contain the same maximum value\n the smallest index is returned.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3587},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":575053,"byte_end":575060,"line_start":181,"line_end":181,"column_start":12,"column_end":19},"name":"min_val","qualname":"<Histogram>::min_val","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the minimum value contained in the histogram bins.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3588},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":575332,"byte_end":575339,"line_start":187,"line_end":187,"column_start":12,"column_end":19},"name":"min_bin","qualname":"<Histogram>::min_bin","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" This function returns the index of the bin containing the minimum value. In the case where several bins contain the same maximum value\n the smallest index is returned.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3589},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":575696,"byte_end":575700,"line_start":193,"line_end":193,"column_start":12,"column_end":16},"name":"mean","qualname":"<Histogram>::mean","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the mean of the histogrammed variable, where the histogram is regarded as a probability distribution. Negative\n bin values are ignored for the purposes of this calculation. The accuracy of the result is limited by the bin width.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3590},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":576066,"byte_end":576071,"line_start":199,"line_end":199,"column_start":12,"column_end":17},"name":"sigma","qualname":"<Histogram>::sigma","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the standard deviation of the histogrammed variable, where the histogram is regarded as a probability distribution.\n Negative bin values are ignored for the purposes of this calculation. The accuracy of the result is limited by the bin width.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3591},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":576260,"byte_end":576263,"line_start":204,"line_end":204,"column_start":12,"column_end":15},"name":"sum","qualname":"<Histogram>::sum","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the sum of all bin values. Negative bin values are included in the sum.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3592},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":576481,"byte_end":576493,"line_start":209,"line_end":209,"column_start":12,"column_end":24},"name":"equal_bins_p","qualname":"<Histogram>::equal_bins_p","value":"fn (&self, other: &Histogram) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if the all of the individual bin ranges of the two histograms are identical, and false otherwise.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3593},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":576890,"byte_end":576893,"line_start":218,"line_end":218,"column_start":12,"column_end":15},"name":"add","qualname":"<Histogram>::add","value":"fn (&mut self, other: &Histogram) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function adds the contents of the bins in histogram other to the corresponding bins of self histogram, i.e. h'_1(i) = h_1(i) + h_2(i).\n The two histograms must have identical bin ranges.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3594},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":577253,"byte_end":577256,"line_start":224,"line_end":224,"column_start":12,"column_end":15},"name":"sub","qualname":"<Histogram>::sub","value":"fn (&mut self, other: &Histogram) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function subtracts the contents of the bins in histogram other from the corresponding bins of self histogram, i.e. h'_1(i) = h_1(i) - h_2(i).\n The two histograms must have identical bin ranges.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3595},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":577631,"byte_end":577634,"line_start":230,"line_end":230,"column_start":12,"column_end":15},"name":"mul","qualname":"<Histogram>::mul","value":"fn (&mut self, other: &Histogram) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function multiplies the contents of the bins of self histogram by the contents of the corresponding bins in other histogram, i.e. h'_1(i) =\n h_1(i) * h_2(i). The two histograms must have identical bin ranges.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3596},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":578006,"byte_end":578009,"line_start":236,"line_end":236,"column_start":12,"column_end":15},"name":"div","qualname":"<Histogram>::div","value":"fn (&mut self, other: &Histogram) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function divides the contents of the bins of self histogram by the contents of the corresponding bins in other histogram, i.e. h'_1(i) = h_1(i)\n / h_2(i). The two histograms must have identical bin ranges.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3597},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":578285,"byte_end":578290,"line_start":241,"line_end":241,"column_start":12,"column_end":17},"name":"scale","qualname":"<Histogram>::scale","value":"fn (&mut self, scale: f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function multiplies the contents of the bins of self histogram by the constant scale, i.e. h'_1(i) = h_1(i) * scale.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3598},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":578557,"byte_end":578562,"line_start":246,"line_end":246,"column_start":12,"column_end":17},"name":"shift","qualname":"<Histogram>::shift","value":"fn (&mut self, offset: f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function shifts the contents of the bins of self histogram by the constant offset, i.e. h'_1(i) = h_1(i) + offset.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3599},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":578733,"byte_end":578738,"line_start":251,"line_end":251,"column_start":12,"column_end":17},"name":"print","qualname":"<Histogram>::print","value":"fn (&self, stream: &mut Write) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"allow(unused_must_use)","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":578696,"byte_end":578721,"line_start":250,"line_end":250,"column_start":5,"column_end":30}}]},{"kind":"Struct","id":{"krate":0,"index":3607},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":580648,"byte_end":580660,"line_start":302,"line_end":302,"column_start":12,"column_end":24},"name":"HistogramPdf","qualname":"::types::histograms::HistogramPdf","value":"HistogramPdf {  }","parent":null,"children":[{"krate":0,"index":3608}],"decl_id":null,"docs":" The probability distribution function for a histogram consists of a set of bins which measure the probability of an event falling into a\n given range of a continuous variable x. A probability distribution function is defined by the following struct, which actually stores the\n cumulative probability distribution function. This is the natural quantity for generating samples via the inverse transform method, because\n there is a one-to-one mapping between the cumulative probability distribution and the range [0,1]. It can be shown that by taking a uniform\n random number in this range and finding its corresponding coordinate in the cumulative probability distribution we obtain samples with the\n desired probability distribution.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3610},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":581025,"byte_end":581028,"line_start":309,"line_end":309,"column_start":12,"column_end":15},"name":"new","qualname":"<HistogramPdf>::new","value":"fn (n: usize) -> Option<HistogramPdf>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates memory for a probability distribution with n bins and returns a pointer to a newly initialized gsl_histogram_pdf\n struct. If insufficient memory is available a null pointer is returned and the error handler is invoked with an error code of Value::NoMem.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3611},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":581572,"byte_end":581576,"line_start":323,"line_end":323,"column_start":12,"column_end":16},"name":"init","qualname":"<HistogramPdf>::init","value":"fn (&mut self, h: &Histogram) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function initializes the probability distribution self with the contents of the histogram h. If any of the bins of h are negative then\n the error handler is invoked with an error code of Value::Dom because a probability distribution cannot contain negative values.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3612},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":582143,"byte_end":582149,"line_start":333,"line_end":333,"column_start":12,"column_end":18},"name":"sample","qualname":"<HistogramPdf>::sample","value":"fn (&self, r: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function uses r, a uniform random number between zero and one, to compute a single random sample from the probability distribution\n self. The algorithm used to compute the sample s is given by the following formula,\n \n s = range[i] + delta * (range[i+1] - range[i])\n \n where i is the index which satisfies sum[i] <= r < sum[i+1] and delta is (r - sum[i])/(sum[i+1] - sum[i]).\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":3620},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":583403,"byte_end":583414,"line_start":369,"line_end":369,"column_start":12,"column_end":23},"name":"Histogram2D","qualname":"::types::histograms::Histogram2D","value":"Histogram2D {  }","parent":null,"children":[{"krate":0,"index":3621}],"decl_id":null,"docs":" A two dimensional histogram consists of a set of bins which count the number of events falling in a given area of the (x,y) plane. The simplest\n way to use a two dimensional histogram is to record two-dimensional position information, n(x,y). Another possibility is to form a joint\n distribution by recording related variables. For example a detector might record both the position of an event (x) and the amount of energy\n it deposited E. These could be histogrammed as the joint distribution n(x,E).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3623},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":583959,"byte_end":583962,"line_start":378,"line_end":378,"column_start":12,"column_end":15},"name":"new","qualname":"<Histogram2D>::new","value":"fn (nx: usize, ny: usize) -> Option<Histogram2D>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates memory for a two-dimensional histogram with nx bins in the x direction and ny bins in the y direction. The\n function returns a pointer to a newly created gsl_histogram2d struct. If insufficient memory is available a null pointer is returned\n and the error handler is invoked with an error code of Value::NoMem. The bins and ranges must be initialized with one of the\n functions below before the histogram is ready for use.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3624},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":584433,"byte_end":584443,"line_start":392,"line_end":392,"column_start":12,"column_end":22},"name":"set_ranges","qualname":"<Histogram2D>::set_ranges","value":"fn (&mut self, xrange: &[f64], yrange: &[f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function sets the ranges of the existing histogram h using the arrays xrange and yrange of size xsize and ysize respectively.\n The values of the histogram bins are reset to zero.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3625},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":585065,"byte_end":585083,"line_start":401,"line_end":401,"column_start":12,"column_end":30},"name":"set_ranges_uniform","qualname":"<Histogram2D>::set_ranges_uniform","value":"fn (&mut self, xmin: f64, xmax: f64, ymin: f64, ymax: f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function sets the ranges of the existing histogram h to cover the ranges xmin to xmax and ymin to ymax uniformly. The values\n of the histogram bins are reset to zero.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3626},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":585483,"byte_end":585487,"line_start":409,"line_end":409,"column_start":12,"column_end":16},"name":"copy","qualname":"<Histogram2D>::copy","value":"fn (&self, dest: &mut Histogram2D) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the histogram src into the pre-existing histogram dest, making dest into an exact copy of src. The two histograms\n must be of the same size.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3627},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":585752,"byte_end":585757,"line_start":414,"line_end":414,"column_start":12,"column_end":17},"name":"clone","qualname":"<Histogram2D>::clone","value":"fn (&self) -> Option<Histogram2D>","parent":null,"children":[],"decl_id":null,"docs":" his function returns a pointer to a newly created histogram which is an exact copy of the histogram self.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3628},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":586602,"byte_end":586611,"line_start":432,"line_end":432,"column_start":12,"column_end":21},"name":"increment","qualname":"<Histogram2D>::increment","value":"fn (&mut self, x: f64, y: f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function updates the histogram h by adding one (1.0) to the bin whose x and y ranges contain the coordinates (x,y).\n \n If the point (x,y) lies inside the valid ranges of the histogram then the function returns zero to indicate success. If (x,y) lies\n outside the limits of the histogram then the function returns Value::Dom, and none of the bins are modified. The error handler is not\n called, since it is often necessary to compute histograms for a small range of a larger dataset, ignoring any coordinates outside the\n range of interest.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3629},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":586932,"byte_end":586942,"line_start":438,"line_end":438,"column_start":12,"column_end":22},"name":"accumulate","qualname":"<Histogram2D>::accumulate","value":"fn (&mut self, x: f64, y: f64, weight: f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function is similar to gsl_histogram2d_increment but increases the value of the appropriate bin in the histogram h by the floating-point\n number weight.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3630},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":587364,"byte_end":587367,"line_start":444,"line_end":444,"column_start":12,"column_end":15},"name":"get","qualname":"<Histogram2D>::get","value":"fn (&self, i: usize, j: usize) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the contents of the (i,j)-th bin of the histogram h. If (i,j) lies outside the valid range of indices for the\n histogram then the error handler is called with an error code of Value::Dom and the function returns 0.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3631},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":588141,"byte_end":588151,"line_start":453,"line_end":453,"column_start":12,"column_end":22},"name":"get_xrange","qualname":"<Histogram2D>::get_xrange","value":"fn (&self, i: usize, xlower: &mut f64, xupper: &mut f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function finds the upper and lower range limits of the i-th and j-th bins in the x and y directions of the histogram h. The range\n limits are stored in xlower and xupper or ylower and yupper. The lower limits are inclusive (i.e. events with these coordinates are included\n in the bin) and the upper limits are exclusive (i.e. events with the value of the upper limit are not included and fall in the neighboring\n higher bin, if it exists). The functions return 0 to indicate success. If i or j lies outside the valid range of indices for the histogram\n then the error handler is called with an error code of Value::Dom.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3632},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":589000,"byte_end":589010,"line_start":462,"line_end":462,"column_start":12,"column_end":22},"name":"get_yrange","qualname":"<Histogram2D>::get_yrange","value":"fn (&self, j: usize, ylower: &mut f64, yupper: &mut f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function finds the upper and lower range limits of the i-th and j-th bins in the x and y directions of the histogram h. The range\n limits are stored in xlower and xupper or ylower and yupper. The lower limits are inclusive (i.e. events with these coordinates are included\n in the bin) and the upper limits are exclusive (i.e. events with the value of the upper limit are not included and fall in the neighboring\n higher bin, if it exists). The functions return 0 to indicate success. If i or j lies outside the valid range of indices for the histogram\n then the error handler is called with an error code of Value::Dom.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3633},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":589457,"byte_end":589461,"line_start":468,"line_end":468,"column_start":12,"column_end":16},"name":"xmax","qualname":"<Histogram2D>::xmax","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the maximum upper and minimum lower range limits and the number of bins for the x and y directions of the histogram h.\n They provide a way of determining these values without accessing the gsl_histogram2d struct directly.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3634},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":589808,"byte_end":589812,"line_start":474,"line_end":474,"column_start":12,"column_end":16},"name":"xmin","qualname":"<Histogram2D>::xmin","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the maximum upper and minimum lower range limits and the number of bins for the x and y directions of the histogram h.\n They provide a way of determining these values without accessing the gsl_histogram2d struct directly.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3635},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":590159,"byte_end":590161,"line_start":480,"line_end":480,"column_start":12,"column_end":14},"name":"nx","qualname":"<Histogram2D>::nx","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" This function returns the maximum upper and minimum lower range limits and the number of bins for the x and y directions of the histogram h.\n They provide a way of determining these values without accessing the gsl_histogram2d struct directly.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3636},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":590508,"byte_end":590512,"line_start":486,"line_end":486,"column_start":12,"column_end":16},"name":"ymax","qualname":"<Histogram2D>::ymax","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the maximum upper and minimum lower range limits and the number of bins for the x and y directions of the histogram h.\n They provide a way of determining these values without accessing the gsl_histogram2d struct directly.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3637},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":590859,"byte_end":590863,"line_start":492,"line_end":492,"column_start":12,"column_end":16},"name":"ymin","qualname":"<Histogram2D>::ymin","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the maximum upper and minimum lower range limits and the number of bins for the x and y directions of the histogram h.\n They provide a way of determining these values without accessing the gsl_histogram2d struct directly.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3638},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":591210,"byte_end":591212,"line_start":498,"line_end":498,"column_start":12,"column_end":14},"name":"ny","qualname":"<Histogram2D>::ny","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" This function returns the maximum upper and minimum lower range limits and the number of bins for the x and y directions of the histogram h.\n They provide a way of determining these values without accessing the gsl_histogram2d struct directly.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3639},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":591370,"byte_end":591375,"line_start":503,"line_end":503,"column_start":12,"column_end":17},"name":"reset","qualname":"<Histogram2D>::reset","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function resets all the bins of the histogram h to zero.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3640},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":591976,"byte_end":591980,"line_start":511,"line_end":511,"column_start":12,"column_end":16},"name":"find","qualname":"<Histogram2D>::find","value":"fn (&self, x: f64, y: f64, i: &mut usize, j: &mut usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function finds and sets the indices i and j to the bin which covers the coordinates (x,y). The bin is located using a binary search.\n The search includes an optimization for histograms with uniform ranges, and will return the correct bin immediately in this case. If\n (x,y) is found then the function sets the indices (i,j) and returns ::Value::Success. If (x,y) lies outside the valid range of the histogram\n then the function returns Value::Dom and the error handler is invoked.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3641},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":592236,"byte_end":592243,"line_start":516,"line_end":516,"column_start":12,"column_end":19},"name":"max_val","qualname":"<Histogram2D>::max_val","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the maximum value contained in the histogram bins.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3642},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":592568,"byte_end":592575,"line_start":522,"line_end":522,"column_start":12,"column_end":19},"name":"max_bin","qualname":"<Histogram2D>::max_bin","value":"fn (&self, i: &mut usize, j: &mut usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function finds the indices of the bin containing the maximum value in the histogram h and stores the result in (i,j). In the case\n where several bins contain the same maximum value the first bin found is returned.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3643},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":592776,"byte_end":592783,"line_start":527,"line_end":527,"column_start":12,"column_end":19},"name":"min_val","qualname":"<Histogram2D>::min_val","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the minimum value contained in the histogram bins.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3644},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":593108,"byte_end":593115,"line_start":533,"line_end":533,"column_start":12,"column_end":19},"name":"min_bin","qualname":"<Histogram2D>::min_bin","value":"fn (&self, i: &mut usize, j: &mut usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function finds the indices of the bin containing the minimum value in the histogram h and stores the result in (i,j). In the case\n where several bins contain the same maximum value the first bin found is returned.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3645},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":593447,"byte_end":593452,"line_start":539,"line_end":539,"column_start":12,"column_end":17},"name":"xmean","qualname":"<Histogram2D>::xmean","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the mean of the histogrammed x variable, where the histogram is regarded as a probability distribution. Negative\n bin values are ignored for the purposes of this calculation.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3646},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":593753,"byte_end":593758,"line_start":545,"line_end":545,"column_start":12,"column_end":17},"name":"ymean","qualname":"<Histogram2D>::ymean","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the mean of the histogrammed y variable, where the histogram is regarded as a probability distribution. Negative\n bin values are ignored for the purposes of this calculation.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3647},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":594073,"byte_end":594079,"line_start":551,"line_end":551,"column_start":12,"column_end":18},"name":"xsigma","qualname":"<Histogram2D>::xsigma","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the standard deviation of the histogrammed x variable, where the histogram is regarded as a probability\n distribution. Negative bin values are ignored for the purposes of this calculation.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3648},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":594395,"byte_end":594401,"line_start":557,"line_end":557,"column_start":12,"column_end":18},"name":"ysigma","qualname":"<Histogram2D>::ysigma","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the standard deviation of the histogrammed y variable, where the histogram is regarded as a probability\n distribution. Negative bin values are ignored for the purposes of this calculation.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3649},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":594716,"byte_end":594719,"line_start":563,"line_end":563,"column_start":12,"column_end":15},"name":"cov","qualname":"<Histogram2D>::cov","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the covariance of the histogrammed x and y variables, where the histogram is regarded as a probability\n distribution. Negative bin values are ignored for the purposes of this calculation.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3650},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":594908,"byte_end":594911,"line_start":568,"line_end":568,"column_start":12,"column_end":15},"name":"sum","qualname":"<Histogram2D>::sum","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the sum of all bin values. Negative bin values are included in the sum.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3651},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":595117,"byte_end":595129,"line_start":573,"line_end":573,"column_start":12,"column_end":24},"name":"equal_bins_p","qualname":"<Histogram2D>::equal_bins_p","value":"fn (&self, other: &Histogram2D) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns 1 if all the individual bin ranges of the two histograms are identical, and 0 otherwise.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3652},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":595528,"byte_end":595531,"line_start":582,"line_end":582,"column_start":12,"column_end":15},"name":"add","qualname":"<Histogram2D>::add","value":"fn (&mut self, other: &Histogram2D) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function adds the contents of the bins in histogram h2 to the corresponding bins of histogram h1, i.e. h'_1(i,j) = h_1(i,j)\n + h_2(i,j). The two histograms must have identical bin ranges.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3653},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":595896,"byte_end":595899,"line_start":588,"line_end":588,"column_start":12,"column_end":15},"name":"sub","qualname":"<Histogram2D>::sub","value":"fn (&mut self, other: &Histogram2D) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function subtracts the contents of the bins in histogram h2 from the corresponding bins of histogram h1, i.e. h'_1(i,j) = h_1(i,j)\n - h_2(i,j). The two histograms must have identical bin ranges.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3654},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":596279,"byte_end":596282,"line_start":594,"line_end":594,"column_start":12,"column_end":15},"name":"mul","qualname":"<Histogram2D>::mul","value":"fn (&mut self, other: &Histogram2D) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function multiplies the contents of the bins of histogram h1 by the contents of the corresponding bins in histogram h2, i.e. h'_1(i,j)\n = h_1(i,j) * h_2(i,j). The two histograms must have identical bin ranges.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3655},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":596659,"byte_end":596662,"line_start":600,"line_end":600,"column_start":12,"column_end":15},"name":"div","qualname":"<Histogram2D>::div","value":"fn (&mut self, other: &Histogram2D) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function divides the contents of the bins of histogram h1 by the contents of the corresponding bins in histogram h2, i.e. h'_1(i,j) =\n h_1(i,j) / h_2(i,j). The two histograms must have identical bin ranges.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3656},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":596941,"byte_end":596946,"line_start":605,"line_end":605,"column_start":12,"column_end":17},"name":"scale","qualname":"<Histogram2D>::scale","value":"fn (&mut self, scale: f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function multiplies the contents of the bins of histogram h by the constant scale, i.e. h'_1(i,j) = h_1(i,j) scale.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3657},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":597216,"byte_end":597221,"line_start":610,"line_end":610,"column_start":12,"column_end":17},"name":"shift","qualname":"<Histogram2D>::shift","value":"fn (&mut self, offset: f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function shifts the contents of the bins of histogram h by the constant offset, i.e. h'_1(i,j) = h_1(i,j) + offset.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":3665},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":598642,"byte_end":598656,"line_start":650,"line_end":650,"column_start":12,"column_end":26},"name":"Histogram2DPdf","qualname":"::types::histograms::Histogram2DPdf","value":"Histogram2DPdf {  }","parent":null,"children":[{"krate":0,"index":3666}],"decl_id":null,"docs":" As in the one-dimensional case, a two-dimensional histogram made by counting events can be regarded as a measurement of a probability distribution.\n Allowing for statistical error, the height of each bin represents the probability of an event where (x,y) falls in the range of that bin. For a\n two-dimensional histogram the probability distribution takes the form p(x,y) dx dy where,\n \n p(x,y) = n_{ij}/ (N A_{ij})\n \n In this equation n_{ij} is the number of events in the bin which contains (x,y), A_{ij} is the area of the bin and N is the total number of\n events. The distribution of events within each bin is assumed to be uniform.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3668},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":599056,"byte_end":599059,"line_start":658,"line_end":658,"column_start":12,"column_end":15},"name":"new","qualname":"<Histogram2DPdf>::new","value":"fn (nx: usize, ny: usize) -> Option<Histogram2DPdf>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates memory for a two-dimensional probability distribution of size nx-by-ny and returns a pointer to a newly initialized\n gsl_histogram2d_pdf struct. If insufficient memory is available a null pointer is returned and the error handler is invoked with an error\n code of Value::NoMem.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3669},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":599639,"byte_end":599643,"line_start":673,"line_end":673,"column_start":12,"column_end":16},"name":"init","qualname":"<Histogram2DPdf>::init","value":"fn (&mut self, h: &Histogram2D) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":"This function initializes the two-dimensional probability distribution calculated p from the histogram h. If any of the bins of h are\n negative then the error handler is invoked with an error code of GSL_EDOM because a probability distribution cannot contain negative\n values.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3670},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":599972,"byte_end":599978,"line_start":679,"line_end":679,"column_start":12,"column_end":18},"name":"sample","qualname":"<Histogram2DPdf>::sample","value":"fn (&self, r1: f64, r2: f64, x: &mut f64, y: &mut f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function uses two uniform random numbers between zero and one, r1 and r2, to compute a single random sample from the two-dimensional\n probability distribution p.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":3678},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"integration","qualname":"::types::integration","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","parent":null,"children":[{"krate":0,"index":3679},{"krate":0,"index":3680},{"krate":0,"index":3681},{"krate":0,"index":3682},{"krate":0,"index":3684},{"krate":0,"index":3686},{"krate":0,"index":3688},{"krate":0,"index":3690},{"krate":0,"index":3692},{"krate":0,"index":3694},{"krate":0,"index":3696},{"krate":0,"index":3698},{"krate":0,"index":3700},{"krate":0,"index":3702},{"krate":0,"index":3704},{"krate":0,"index":3710},{"krate":0,"index":3736},{"krate":0,"index":3738},{"krate":0,"index":3743},{"krate":0,"index":3745},{"krate":0,"index":3750},{"krate":0,"index":3752},{"krate":0,"index":3757},{"krate":0,"index":3759},{"krate":0,"index":3765},{"krate":0,"index":3767},{"krate":0,"index":3772},{"krate":0,"index":3774},{"krate":0,"index":3786},{"krate":0,"index":3788},{"krate":0,"index":3793},{"krate":0,"index":3795},{"krate":0,"index":3800},{"krate":0,"index":3802},{"krate":0,"index":3807},{"krate":0,"index":3809},{"krate":0,"index":3811},{"krate":0,"index":3813},{"krate":0,"index":3815},{"krate":0,"index":3816},{"krate":0,"index":3817},{"krate":0,"index":3818},{"krate":0,"index":3819},{"krate":0,"index":3820},{"krate":0,"index":3821},{"krate":0,"index":3822},{"krate":0,"index":3823},{"krate":0,"index":3824},{"krate":0,"index":3826},{"krate":0,"index":3828},{"krate":0,"index":3836},{"krate":0,"index":3838},{"krate":0,"index":3839},{"krate":0,"index":3846},{"krate":0,"index":3854},{"krate":0,"index":3864},{"krate":0,"index":3866},{"krate":0,"index":3868},{"krate":0,"index":3870},{"krate":0,"index":3871},{"krate":0,"index":3877},{"krate":0,"index":3883},{"krate":0,"index":3885},{"krate":0,"index":3887},{"krate":0,"index":3888}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"allow(non_upper_case_globals)","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":600903,"byte_end":600936,"line_start":5,"line_end":5,"column_start":1,"column_end":34}}]},{"kind":"Struct","id":{"krate":0,"index":3702},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":689428,"byte_end":689448,"line_start":1347,"line_end":1347,"column_start":12,"column_end":32},"name":"IntegrationWorkspace","qualname":"::types::integration::IntegrationWorkspace","value":"IntegrationWorkspace {  }","parent":null,"children":[{"krate":0,"index":3703}],"decl_id":null,"docs":" The QAG algorithm is a simple adaptive integration procedure. The integration region is divided into subintervals, and on each iteration\n the subinterval with the largest estimated error is bisected. This reduces the overall error rapidly, as the subintervals become concentrated\n around local difficulties in the integrand. These subintervals are managed by a gsl_integration_workspace struct, which handles the memory\n for the subinterval ranges, results and error estimates.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3711},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":689908,"byte_end":689911,"line_start":1360,"line_end":1360,"column_start":12,"column_end":15},"name":"new","qualname":"<IntegrationWorkspace>::new","value":"fn (n: usize) -> Option<IntegrationWorkspace>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates a workspace sufficient to hold n double precision intervals, their integration results and error estimates. One\n workspace may be used multiple times as all necessary reinitialization is performed automatically by the integration routines.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3712},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":691507,"byte_end":691510,"line_start":1394,"line_end":1394,"column_start":12,"column_end":15},"name":"qag","qualname":"<IntegrationWorkspace>::qag","value":"fn <T> (&mut self, f: ::function<T>, arg: &mut T, a: f64, b: f64, epsabs: f64, epsrel: f64, limit: usize, key: enums::GaussKonrodRule, result: &mut f64, abserr: &mut f64) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":" This function applies an integration rule adaptively until an estimate of the integral of f over (a,b) is achieved within the desired\n absolute and relative error limits, epsabs and epsrel. The function returns the final approximation, result, and an estimate of the\n absolute error, abserr. The integration rule is determined by the value of key, which should be chosen from the following symbolic names,","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3714},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":694174,"byte_end":694178,"line_start":1451,"line_end":1451,"column_start":12,"column_end":16},"name":"qags","qualname":"<IntegrationWorkspace>::qags","value":"fn <T> (&mut self, f: ::function<T>, arg: &mut T, a: f64, b: f64, epsabs: f64, epsrel: f64, limit: usize, result: &mut f64, abserr: &mut f64) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":" This function applies the Gauss-Kronrod 21-point integration rule adaptively until an estimate of the integral of f over (a,b) is achieved\n within the desired absolute and relative error limits, epsabs and epsrel. The results are extrapolated using the epsilon-algorithm, which\n accelerates the convergence of the integral in the presence of discontinuities and integrable singularities. The function returns the\n final approximation from the extrapolation, result, and an estimate of the absolute error, abserr. The subintervals and their results are\n stored in the memory provided by workspace. The maximum number of subintervals is given by limit, which may not exceed the allocated size\n of the workspace.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3716},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":695315,"byte_end":695319,"line_start":1481,"line_end":1481,"column_start":12,"column_end":16},"name":"qagp","qualname":"<IntegrationWorkspace>::qagp","value":"fn <T> (&mut self, f: ::function<T>, arg: &mut T, pts: &mut [f64], epsabs: f64, epsrel: f64, limit: usize, result: &mut f64, abserr: &mut f64) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":" This function applies the adaptive integration algorithm QAGS taking account of the user-supplied locations of singular points. The array\n pts of length npts should contain the endpoints of the integration ranges defined by the integration region and locations of the singularities.\n For example, to integrate over the region (a,b) with break-points at x_1, x_2, x_3 (where a < x_1 < x_2 < x_3 < b) the following pts array\n should be used","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3718},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":696315,"byte_end":696319,"line_start":1505,"line_end":1505,"column_start":12,"column_end":16},"name":"qagi","qualname":"<IntegrationWorkspace>::qagi","value":"fn <T> (&mut self, f: ::function<T>, arg: &mut T, epsabs: f64, epsrel: f64, limit: usize, result: &mut f64, abserr: &mut f64) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the integral of the function f over the infinite interval (-\\infty,+\\infty). The integral is mapped onto the\n semi-open interval (0,1] using the transformation x = (1-t)/t,","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3720},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":697138,"byte_end":697143,"line_start":1529,"line_end":1529,"column_start":12,"column_end":17},"name":"qagiu","qualname":"<IntegrationWorkspace>::qagiu","value":"fn <T> (&mut self, f: ::function<T>, arg: &mut T, a: f64, epsabs: f64, epsrel: f64, limit: usize, result: &mut f64, abserr: &mut f64) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the integral of the function f over the semi-infinite interval (a,+\\infty). The integral is mapped onto the\n semi-open interval (0,1] using the transformation x = a + (1-t)/t,","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3722},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":697976,"byte_end":697981,"line_start":1554,"line_end":1554,"column_start":12,"column_end":17},"name":"qagil","qualname":"<IntegrationWorkspace>::qagil","value":"fn <T> (&mut self, f: ::function<T>, arg: &mut T, b: f64, epsabs: f64, epsrel: f64, limit: usize, result: &mut f64, abserr: &mut f64) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the integral of the function f over the semi-infinite interval (-\\infty,b). The integral is mapped onto the semi-open\n interval (0,1] using the transformation x = b - (1-t)/t,","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3724},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":699073,"byte_end":699077,"line_start":1580,"line_end":1580,"column_start":12,"column_end":16},"name":"qawc","qualname":"<IntegrationWorkspace>::qawc","value":"fn <T> (&mut self, f: ::function<T>, arg: &mut T, a: f64, b: f64, c: f64, epsabs: f64, epsrel: f64, limit: usize, result: &mut f64, abserr: &mut f64) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the Cauchy principal value of the integral of f over (a,b), with a singularity at c,","sig":null,"attributes":[{"value":"allow(unused_assignments)","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":699033,"byte_end":699061,"line_start":1579,"line_end":1579,"column_start":5,"column_end":33}}]},{"kind":"Method","id":{"krate":0,"index":3726},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":704892,"byte_end":704904,"line_start":1751,"line_end":1751,"column_start":12,"column_end":24},"name":"sort_results","qualname":"<IntegrationWorkspace>::sort_results","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3727},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":705853,"byte_end":705858,"line_start":1783,"line_end":1783,"column_start":12,"column_end":17},"name":"qpsrt","qualname":"<IntegrationWorkspace>::qpsrt","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3728},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":708545,"byte_end":708556,"line_start":1850,"line_end":1850,"column_start":12,"column_end":23},"name":"sum_results","qualname":"<IntegrationWorkspace>::sum_results","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3729},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":708937,"byte_end":708945,"line_start":1865,"line_end":1865,"column_start":12,"column_end":20},"name":"retrieve","qualname":"<IntegrationWorkspace>::retrieve","value":"fn (&self, a: &mut f64, b: &mut f64, r: &mut f64, e: &mut f64) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3730},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":709563,"byte_end":709569,"line_start":1882,"line_end":1882,"column_start":12,"column_end":18},"name":"update","qualname":"<IntegrationWorkspace>::update","value":"fn (&mut self, a1: f64, b1: f64, area1: f64, error1: f64, a2: f64, b2: f64, area2: f64, error2: f64) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3731},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":711561,"byte_end":711579,"line_start":1939,"line_end":1939,"column_start":12,"column_end":30},"name":"set_initial_result","qualname":"<IntegrationWorkspace>::set_initial_result","value":"fn (&mut self, result: f64, error: f64) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3732},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":711897,"byte_end":711907,"line_start":1950,"line_end":1950,"column_start":12,"column_end":22},"name":"initialise","qualname":"<IntegrationWorkspace>::initialise","value":"fn (&mut self, a: f64, b: f64) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3734},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":713573,"byte_end":713578,"line_start":1997,"line_end":1997,"column_start":12,"column_end":17},"name":"limit","qualname":"<IntegrationWorkspace>::limit","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3735},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":713650,"byte_end":713654,"line_start":2001,"line_end":2001,"column_start":12,"column_end":16},"name":"size","qualname":"<IntegrationWorkspace>::size","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":3743},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":714698,"byte_end":714718,"line_start":2035,"line_end":2035,"column_start":12,"column_end":32},"name":"IntegrationQawsTable","qualname":"::types::integration::IntegrationQawsTable","value":"IntegrationQawsTable {  }","parent":null,"children":[{"krate":0,"index":3744}],"decl_id":null,"docs":" The QAWS algorithm is designed for integrands with algebraic-logarithmic singularities at the end-points of an integration region. In order\n to work efficiently the algorithm requires a precomputed table of Chebyshev moments.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3746},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":715866,"byte_end":715869,"line_start":2058,"line_end":2058,"column_start":12,"column_end":15},"name":"new","qualname":"<IntegrationQawsTable>::new","value":"fn (alpha: f64, beta: f64, mu: i32, nu: i32) -> Option<IntegrationQawsTable>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates space for a gsl_integration_qaws_table struct describing a singular weight function W(x) with the parameters\n (\\alpha, \\beta, \\mu, \\nu),","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3747},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":716274,"byte_end":716277,"line_start":2071,"line_end":2071,"column_start":12,"column_end":15},"name":"set","qualname":"<IntegrationQawsTable>::set","value":"fn (&mut self, alpha: f64, beta: f64, mu: i32, nu: i32) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":" This function modifies the parameters (\\alpha, \\beta, \\mu, \\nu)\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3748},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":717242,"byte_end":717246,"line_start":2087,"line_end":2087,"column_start":12,"column_end":16},"name":"qaws","qualname":"<IntegrationQawsTable>::qaws","value":"fn <T> (&mut self, f: ::function<T>, arg: &mut T, a: f64, b: f64, epsabs: f64, epsrel: f64, limit: usize, workspace: &mut IntegrationWorkspace, result: &mut f64, abserr: &mut f64) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the integral of the function f(x) over the interval (a,b) with the singular weight function (x-a)^\\alpha\n (b-x)^\\beta \\log^\\mu (x-a) \\log^\\nu (b-x). The parameters of the weight function (\\alpha, \\beta, \\mu, \\nu) are taken from the\n table self. The integral is,","sig":null,"attributes":[{"value":"allow(unused_assignments)","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":717202,"byte_end":717230,"line_start":2086,"line_end":2086,"column_start":5,"column_end":33}}]},{"kind":"Struct","id":{"krate":0,"index":3757},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":724442,"byte_end":724462,"line_start":2290,"line_end":2290,"column_start":12,"column_end":32},"name":"IntegrationQawoTable","qualname":"::types::integration::IntegrationQawoTable","value":"IntegrationQawoTable {  }","parent":null,"children":[{"krate":0,"index":3758}],"decl_id":null,"docs":" The QAWO algorithm is designed for integrands with an oscillatory factor, \\sin(\\omega x) or \\cos(\\omega x). In order to work efficiently\n the algorithm requires a table of Chebyshev moments which must be pre-computed with calls to the functions below.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3760},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":725638,"byte_end":725641,"line_start":2311,"line_end":2311,"column_start":12,"column_end":15},"name":"new","qualname":"<IntegrationQawoTable>::new","value":"fn (omega: f64, l: f64, sine: ::IntegrationQawo, n: usize) -> Option<IntegrationQawoTable>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates space for a gsl_integration_qawo_table struct and its associated workspace describing a sine or cosine weight\n function W(x) with the parameters (\\omega, L),","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3761},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":726088,"byte_end":726091,"line_start":2324,"line_end":2324,"column_start":12,"column_end":15},"name":"set","qualname":"<IntegrationQawoTable>::set","value":"fn (&mut self, omega: f64, l: f64, sine: ::IntegrationQawo) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":" This function changes the parameters omega, L and sine of the existing self workspace.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3762},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":726369,"byte_end":726379,"line_start":2329,"line_end":2329,"column_start":12,"column_end":22},"name":"set_length","qualname":"<IntegrationQawoTable>::set_length","value":"fn (&mut self, l: f64) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":" This function allows the length parameter l of the self workspace to be changed.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3763},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":727558,"byte_end":727562,"line_start":2346,"line_end":2346,"column_start":12,"column_end":16},"name":"qawo","qualname":"<IntegrationQawoTable>::qawo","value":"fn <T> (&mut self, f: ::function<T>, arg: &mut T, a: f64, epsabs: f64, epsrel: f64, limit: usize, workspace: &mut IntegrationWorkspace, result: &mut f64, abserr: &mut f64) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":" This function uses an adaptive algorithm to compute the integral of f over (a,b) with the weight function \\sin(\\omega x) or \\cos(\\omega x)\n defined by the table wf,","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":3772},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":740976,"byte_end":740990,"line_start":2724,"line_end":2724,"column_start":12,"column_end":26},"name":"CquadWorkspace","qualname":"::types::integration::CquadWorkspace","value":"CquadWorkspace {  }","parent":null,"children":[{"krate":0,"index":3773}],"decl_id":null,"docs":" CQUAD is a new doubly-adaptive general-purpose quadrature routine which can handle most types of singularities, non-numerical function\n values such as Inf or NaN, as well as some divergent integrals. It generally requires more function evaluations than the integration\n routines in QUADPACK, yet fails less often for difficult integrands.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3775},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":741443,"byte_end":741446,"line_start":2732,"line_end":2732,"column_start":12,"column_end":15},"name":"new","qualname":"<CquadWorkspace>::new","value":"fn (n: usize) -> Option<CquadWorkspace>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates a workspace sufficient to hold the data for n intervals. The number n is not the maximum number of intervals\n that will be evaluated. If the workspace is full, intervals with smaller error estimates will be discarded. A minimum of 3 intervals\n is required and for most functions, a workspace of size 100 is sufficient.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3776},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":743055,"byte_end":743060,"line_start":2757,"line_end":2757,"column_start":12,"column_end":17},"name":"cquad","qualname":"<CquadWorkspace>::cquad","value":"fn <T> (&mut self, f: ::function<T>, arg: &mut T, a: f64, b: f64, epsabs: f64, epsrel: f64, result: &mut f64, abserr: &mut f64, nevals: &mut usize) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the integral of f over (a,b) within the desired absolute and relative error limits, epsabs and epsrel using\n the CQUAD algorithm. The function returns the final approximation, result, an estimate of the absolute error, abserr, and the number\n of function evaluations required, nevals.","sig":null,"attributes":[{"value":"allow(unused_assignments)","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":743015,"byte_end":743043,"line_start":2756,"line_end":2756,"column_start":5,"column_end":33}}]},{"kind":"Struct","id":{"krate":0,"index":3793},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":765078,"byte_end":765090,"line_start":3268,"line_end":3268,"column_start":12,"column_end":24},"name":"GLFixedTable","qualname":"::types::integration::GLFixedTable","value":"GLFixedTable {  }","parent":null,"children":[{"krate":0,"index":3794}],"decl_id":null,"docs":" The fixed-order Gauss-Legendre integration routines are provided for fast integration of smooth functions with known polynomial order.\n The n-point Gauss-Legendre rule is exact for polynomials of order 2*n-1 or less. For example, these rules are useful when integrating\n basis functions to form mass matrices for the Galerkin method. Unlike other numerical integration routines within the library, these\n routines do not accept absolute or relative error bounds.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3796},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":765480,"byte_end":765483,"line_start":3276,"line_end":3276,"column_start":12,"column_end":15},"name":"new","qualname":"<GLFixedTable>::new","value":"fn (n: usize) -> Option<GLFixedTable>","parent":null,"children":[],"decl_id":null,"docs":" This function determines the Gauss-Legendre abscissae and weights necessary for an n-point fixed order integration scheme. If possible,\n high precision precomputed coefficients are used. If precomputed weights are not available, lower precision coefficients are computed\n on the fly.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3797},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":766023,"byte_end":766028,"line_start":3290,"line_end":3290,"column_start":12,"column_end":17},"name":"point","qualname":"<GLFixedTable>::point","value":"fn (&self, a: f64, b: f64, i: usize, xi: &mut f64, wi: &mut f64) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":" For i in [0, …, t->n - 1], this function obtains the i-th Gauss-Legendre point xi and weight wi on the interval [a,b]. The points\n and weights are ordered by increasing point value. A function f may be integrated on [a,b] by summing wi * f(xi) over i.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3798},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":766329,"byte_end":766336,"line_start":3295,"line_end":3295,"column_start":12,"column_end":19},"name":"glfixed","qualname":"<GLFixedTable>::glfixed","value":"fn <T> (&self, f: ::function<T>, arg: &mut T, a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function applies the Gauss-Legendre integration rule contained in table self and returns the result.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":3815},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":773059,"byte_end":773075,"line_start":3521,"line_end":3521,"column_start":15,"column_end":31},"name":"initialise_table","qualname":"::types::integration::initialise_table","value":"fn (table: *mut ffi::extrapolation_table) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":3816},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":773191,"byte_end":773203,"line_start":3527,"line_end":3527,"column_start":15,"column_end":27},"name":"append_table","qualname":"::types::integration::append_table","value":"fn (table: &mut ffi::extrapolation_table, y: f64) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":3817},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":773360,"byte_end":773375,"line_start":3535,"line_end":3535,"column_start":8,"column_end":23},"name":"append_interval","qualname":"::types::integration::append_interval","value":"fn (w: &mut IntegrationWorkspace, a: f64, b: f64, area: f64, error: f64) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":3818},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":773520,"byte_end":773531,"line_start":3540,"line_end":3540,"column_start":15,"column_end":26},"name":"intern_qelg","qualname":"::types::integration::intern_qelg","value":"fn (table: &mut ffi::extrapolation_table, result: &mut f64, abserr: &mut f64) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":3823},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":778946,"byte_end":778958,"line_start":3726,"line_end":3726,"column_start":15,"column_end":27},"name":"return_error","qualname":"::types::integration::return_error","value":"fn (t_error_type: i32) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":3893},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"interpolation","qualname":"::types::interpolation","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","parent":null,"children":[{"krate":0,"index":3894},{"krate":0,"index":3895},{"krate":0,"index":7013},{"krate":0,"index":7018},{"krate":0,"index":7017},{"krate":0,"index":3896},{"krate":0,"index":3900},{"krate":0,"index":3902},{"krate":0,"index":3907},{"krate":0,"index":3909},{"krate":0,"index":7020},{"krate":0,"index":7023},{"krate":0,"index":7022},{"krate":0,"index":3914},{"krate":0,"index":3922},{"krate":0,"index":3927},{"krate":0,"index":3929},{"krate":0,"index":3942},{"krate":0,"index":3944}],"decl_id":null,"docs":"#Interpolation","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":7013},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":817263,"byte_end":817274,"line_start":46,"line_end":46,"column_start":12,"column_end":23},"name":"InterpAccel","qualname":"::types::interpolation::InterpAccel","value":"InterpAccel { cache, miss_count, hit_count }","parent":null,"children":[{"krate":0,"index":7014},{"krate":0,"index":7015},{"krate":0,"index":7016}],"decl_id":null,"docs":" evaluation accelerator\n","sig":null,"attributes":[{"value":"repr(C)","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":817218,"byte_end":817228,"line_start":44,"line_end":44,"column_start":1,"column_end":11}}]},{"kind":"Field","id":{"krate":0,"index":7014},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":817308,"byte_end":817313,"line_start":48,"line_end":48,"column_start":9,"column_end":14},"name":"cache","qualname":"::types::interpolation::InterpAccel::cache","value":"usize","parent":{"krate":0,"index":7013},"children":[],"decl_id":null,"docs":" cache of index\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":7015},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":817354,"byte_end":817364,"line_start":50,"line_end":50,"column_start":9,"column_end":19},"name":"miss_count","qualname":"::types::interpolation::InterpAccel::miss_count","value":"usize","parent":{"krate":0,"index":7013},"children":[],"decl_id":null,"docs":" keep statistics\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":7016},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":817381,"byte_end":817390,"line_start":51,"line_end":51,"column_start":9,"column_end":18},"name":"hit_count","qualname":"::types::interpolation::InterpAccel::hit_count","value":"usize","parent":{"krate":0,"index":7013},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3897},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":817658,"byte_end":817661,"line_start":57,"line_end":57,"column_start":12,"column_end":15},"name":"new","qualname":"<InterpAccel>::new","value":"fn () -> InterpAccel","parent":null,"children":[],"decl_id":null,"docs":" This function returns a pointer to an accelerator object, which is a kind of iterator for interpolation lookups. It tracks the state\n of lookups, thus allowing for application of various acceleration strategies.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3898},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":818010,"byte_end":818015,"line_start":67,"line_end":67,"column_start":12,"column_end":17},"name":"reset","qualname":"<InterpAccel>::reset","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function reinitializes the accelerator object acc. It should be used when the cached information is no longer applicable—for\n example, when switching to a new dataset.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3899},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":818416,"byte_end":818420,"line_start":75,"line_end":75,"column_start":12,"column_end":16},"name":"find","qualname":"<InterpAccel>::find","value":"fn (&mut self, x_array: &[f64], x: f64) -> usize","parent":null,"children":[],"decl_id":null,"docs":" This function performs a lookup action on the data array x_array of size size, using the given accelerator a. This is how lookups\n are performed during evaluation of an interpolation. The function returns an index i such that x_array[i] <= x < x_array[i+1].\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":3900},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":818585,"byte_end":818591,"line_start":80,"line_end":80,"column_start":12,"column_end":18},"name":"Interp","qualname":"::types::interpolation::Interp","value":"Interp {  }","parent":null,"children":[{"krate":0,"index":3901}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3903},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":818769,"byte_end":818772,"line_start":86,"line_end":86,"column_start":12,"column_end":15},"name":"new","qualname":"<Interp>::new","value":"fn (t: &InterpType, size: usize) -> Option<Interp>","parent":null,"children":[],"decl_id":null,"docs":" This function returns a pointer to a newly allocated interpolation object of type T for size data-points.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3904},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":819461,"byte_end":819465,"line_start":101,"line_end":101,"column_start":12,"column_end":16},"name":"init","qualname":"<Interp>::init","value":"fn (&self, xa: &[f64], ya: &[f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function initializes the interpolation object interp for the data (xa,ya) where xa and ya are arrays of size size. The interpolation\n object (gsl_interp) does not save the data arrays xa and ya and only stores the static state computed from the data. The xa data array\n is always assumed to be strictly ordered, with increasing x values; the behavior for other arrangements is not defined.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3905},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":819996,"byte_end":820000,"line_start":118,"line_end":118,"column_start":12,"column_end":16},"name":"name","qualname":"<Interp>::name","value":"fn (&self) -> String","parent":null,"children":[],"decl_id":null,"docs":" This function returns the name of the interpolation type used by interp. For example,","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3906},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":820494,"byte_end":820502,"line_start":130,"line_end":130,"column_start":12,"column_end":20},"name":"min_size","qualname":"<Interp>::min_size","value":"fn (&self) -> u32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the minimum number of points required by the interpolation object interp or interpolation type T. For example,\n Akima spline interpolation requires a minimum of 5 points.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":7020},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":821234,"byte_end":821244,"line_start":163,"line_end":163,"column_start":12,"column_end":22},"name":"InterpType","qualname":"::types::interpolation::InterpType","value":"InterpType {  }","parent":null,"children":[{"krate":0,"index":7021}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3915},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":821522,"byte_end":821530,"line_start":170,"line_end":170,"column_start":12,"column_end":20},"name":"min_size","qualname":"<InterpType>::min_size","value":"fn (&self) -> u32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the minimum number of points required by the interpolation object interp or interpolation type T. For example,\n Akima spline interpolation requires a minimum of 5 points.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3916},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":821718,"byte_end":821724,"line_start":175,"line_end":175,"column_start":12,"column_end":18},"name":"linear","qualname":"<InterpType>::linear","value":"fn () -> InterpType","parent":null,"children":[],"decl_id":null,"docs":" Linear interpolation. This interpolation method does not require any additional memory.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3917},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":822121,"byte_end":822131,"line_start":182,"line_end":182,"column_start":12,"column_end":22},"name":"polynomial","qualname":"<InterpType>::polynomial","value":"fn () -> InterpType","parent":null,"children":[],"decl_id":null,"docs":" Polynomial interpolation. This method should only be used for interpolating small numbers of points because polynomial interpolation\n introduces large oscillations, even for well-behaved datasets. The number of terms in the interpolating polynomial is equal to the\n number of points.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3918},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":822496,"byte_end":822503,"line_start":188,"line_end":188,"column_start":12,"column_end":19},"name":"cspline","qualname":"<InterpType>::cspline","value":"fn () -> InterpType","parent":null,"children":[],"decl_id":null,"docs":" Cubic spline with natural boundary conditions. The resulting curve is piecewise cubic on each interval, with matching first and second\n derivatives at the supplied data-points. The second derivative is chosen to be zero at the first point and last point.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3919},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":823041,"byte_end":823057,"line_start":196,"line_end":196,"column_start":12,"column_end":28},"name":"cspline_periodic","qualname":"<InterpType>::cspline_periodic","value":"fn () -> InterpType","parent":null,"children":[],"decl_id":null,"docs":" Cubic spline with periodic boundary conditions. The resulting curve is piecewise cubic on each interval, with matching first and second\n derivatives at the supplied data-points. The derivatives at the first and last points are also matched. Note that the last point in\n the data must have the same y-value as the first point, otherwise the resulting periodic interpolation will have a discontinuity at\n the boundary.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3920},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":823287,"byte_end":823292,"line_start":201,"line_end":201,"column_start":12,"column_end":17},"name":"akima","qualname":"<InterpType>::akima","value":"fn () -> InterpType","parent":null,"children":[],"decl_id":null,"docs":" Non-rounded Akima spline with natural boundary conditions. This method uses the non-rounded corner algorithm of Wodicka.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3921},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":823512,"byte_end":823526,"line_start":206,"line_end":206,"column_start":12,"column_end":26},"name":"akima_periodic","qualname":"<InterpType>::akima_periodic","value":"fn () -> InterpType","parent":null,"children":[],"decl_id":null,"docs":" Non-rounded Akima spline with periodic boundary conditions. This method uses the non-rounded corner algorithm of Wodicka.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":3927},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":824160,"byte_end":824166,"line_start":232,"line_end":232,"column_start":12,"column_end":18},"name":"Spline","qualname":"::types::interpolation::Spline","value":"Spline {  }","parent":null,"children":[{"krate":0,"index":3928}],"decl_id":null,"docs":" general interpolation object\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3930},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":824230,"byte_end":824233,"line_start":237,"line_end":237,"column_start":12,"column_end":15},"name":"new","qualname":"<Spline>::new","value":"fn (t: &InterpType, size: usize) -> Option<Spline>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3931},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":824505,"byte_end":824509,"line_start":249,"line_end":249,"column_start":12,"column_end":16},"name":"init","qualname":"<Spline>::init","value":"fn (&self, xa: &[f64], ya: &[f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3932},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":824715,"byte_end":824719,"line_start":255,"line_end":255,"column_start":12,"column_end":16},"name":"name","qualname":"<Spline>::name","value":"fn (&self) -> String","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3933},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":825005,"byte_end":825013,"line_start":265,"line_end":265,"column_start":12,"column_end":20},"name":"min_size","qualname":"<Spline>::min_size","value":"fn (&self) -> u32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3934},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":825105,"byte_end":825109,"line_start":269,"line_end":269,"column_start":12,"column_end":16},"name":"eval","qualname":"<Spline>::eval","value":"fn (&self, x: f64, acc: &mut InterpAccel) -> f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3935},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":825236,"byte_end":825242,"line_start":273,"line_end":273,"column_start":12,"column_end":18},"name":"eval_e","qualname":"<Spline>::eval_e","value":"fn (&self, x: f64, acc: &mut InterpAccel, y: &mut f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3936},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":825416,"byte_end":825426,"line_start":277,"line_end":277,"column_start":12,"column_end":22},"name":"eval_deriv","qualname":"<Spline>::eval_deriv","value":"fn (&self, x: f64, acc: &mut InterpAccel) -> f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3937},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":825559,"byte_end":825571,"line_start":281,"line_end":281,"column_start":12,"column_end":24},"name":"eval_deriv_e","qualname":"<Spline>::eval_deriv_e","value":"fn (&self, x: f64, acc: &mut InterpAccel, d: &mut f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3938},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":825751,"byte_end":825762,"line_start":285,"line_end":285,"column_start":12,"column_end":23},"name":"eval_deriv2","qualname":"<Spline>::eval_deriv2","value":"fn (&self, x: f64, acc: &mut InterpAccel) -> f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3939},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":825896,"byte_end":825909,"line_start":289,"line_end":289,"column_start":12,"column_end":25},"name":"eval_deriv2_e","qualname":"<Spline>::eval_deriv2_e","value":"fn (&self, x: f64, acc: &mut InterpAccel, d2: &mut f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3940},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":826092,"byte_end":826102,"line_start":293,"line_end":293,"column_start":12,"column_end":22},"name":"eval_integ","qualname":"<Spline>::eval_integ","value":"fn (&self, a: f64, b: f64, acc: &mut InterpAccel) -> f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3941},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":826246,"byte_end":826258,"line_start":297,"line_end":297,"column_start":12,"column_end":24},"name":"eval_integ_e","qualname":"<Spline>::eval_integ_e","value":"fn (&self, a: f64, b: f64, acc: &mut InterpAccel, result: &mut f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":3949},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mathieu.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"mathieu","qualname":"::types::mathieu","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mathieu.rs","parent":null,"children":[{"krate":0,"index":3950},{"krate":0,"index":3951},{"krate":0,"index":3952},{"krate":0,"index":3953},{"krate":0,"index":3955},{"krate":0,"index":3969},{"krate":0,"index":3971}],"decl_id":null,"docs":"The routines described in this section compute the angular and radial Mathieu functions, and their characteristic values. Mathieu functions are the solutions of the following two differential equations:","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":3953},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mathieu.rs","byte_start":828338,"byte_end":828354,"line_start":25,"line_end":25,"column_start":12,"column_end":28},"name":"MathieuWorkspace","qualname":"::types::mathieu::MathieuWorkspace","value":"MathieuWorkspace {  }","parent":null,"children":[{"krate":0,"index":3954}],"decl_id":null,"docs":" The Mathieu functions can be computed for a single order or for multiple orders, using array-based routines.\n The array-based routines require a preallocated workspace.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3956},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mathieu.rs","byte_start":828665,"byte_end":828668,"line_start":32,"line_end":32,"column_start":12,"column_end":15},"name":"new","qualname":"<MathieuWorkspace>::new","value":"fn (n: usize, qmax: f64) -> Option<MathieuWorkspace>","parent":null,"children":[],"decl_id":null,"docs":" This function returns a workspace for the array versions of the Mathieu routines.\n The arguments n and qmax specify the maximum order and q-value of Mathieu functions which can be computed with this workspace.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3957},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mathieu.rs","byte_start":829087,"byte_end":829096,"line_start":45,"line_end":45,"column_start":12,"column_end":21},"name":"mathieu_a","qualname":"<MathieuWorkspace>::mathieu_a","value":"fn (n: i32, q: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the characteristic values a_n(q), b_n(q) of the Mathieu functions ce_n(q,x) and se_n(q,x), respectively.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3958},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mathieu.rs","byte_start":829528,"byte_end":829537,"line_start":53,"line_end":53,"column_start":12,"column_end":21},"name":"mathieu_b","qualname":"<MathieuWorkspace>::mathieu_b","value":"fn (n: i32, q: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the characteristic values a_n(q), b_n(q) of the Mathieu functions ce_n(q,x) and se_n(q,x), respectively.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3959},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mathieu.rs","byte_start":830013,"byte_end":830028,"line_start":61,"line_end":61,"column_start":12,"column_end":27},"name":"mathieu_a_array","qualname":"<MathieuWorkspace>::mathieu_a_array","value":"fn (&mut self, order_min: i32, order_max: i32, q: f64, result_array: &mut [f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This routine computes a series of Mathieu characteristic values a_n(q), b_n(q) for n from order_min to order_max inclusive, storing the results in the array result_array.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3960},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mathieu.rs","byte_start":830471,"byte_end":830486,"line_start":68,"line_end":68,"column_start":12,"column_end":27},"name":"mathieu_b_array","qualname":"<MathieuWorkspace>::mathieu_b_array","value":"fn (&mut self, order_min: i32, order_max: i32, q: f64, result_array: &mut [f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This routine computes a series of Mathieu characteristic values a_n(q), b_n(q) for n from order_min to order_max inclusive, storing the results in the array result_array.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3961},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mathieu.rs","byte_start":830849,"byte_end":830859,"line_start":75,"line_end":75,"column_start":12,"column_end":22},"name":"mathieu_ce","qualname":"<MathieuWorkspace>::mathieu_ce","value":"fn (n: i32, q: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the angular Mathieu functions ce_n(q,x) and se_n(q,x), respectively.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3962},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mathieu.rs","byte_start":831267,"byte_end":831277,"line_start":83,"line_end":83,"column_start":12,"column_end":22},"name":"mathieu_se","qualname":"<MathieuWorkspace>::mathieu_se","value":"fn (n: i32, q: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the angular Mathieu functions ce_n(q,x) and se_n(q,x), respectively.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3963},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mathieu.rs","byte_start":831769,"byte_end":831785,"line_start":91,"line_end":91,"column_start":12,"column_end":28},"name":"mathieu_ce_array","qualname":"<MathieuWorkspace>::mathieu_ce_array","value":"fn (&mut self, nmin: i32, nmax: i32, q: f64, x: f64, result_array: &mut [f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This routine computes a series of the angular Mathieu functions ce_n(q,x) and se_n(q,x) of order n from nmin to nmax inclusive, storing the results in the array result_array.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3964},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mathieu.rs","byte_start":832224,"byte_end":832240,"line_start":98,"line_end":98,"column_start":12,"column_end":28},"name":"mathieu_se_array","qualname":"<MathieuWorkspace>::mathieu_se_array","value":"fn (&mut self, nmin: i32, nmax: i32, q: f64, x: f64, result_array: &mut [f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This routine computes a series of the angular Mathieu functions ce_n(q,x) and se_n(q,x) of order n from nmin to nmax inclusive, storing the results in the array result_array.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3965},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mathieu.rs","byte_start":832831,"byte_end":832841,"line_start":107,"line_end":107,"column_start":12,"column_end":22},"name":"mathieu_Mc","qualname":"<MathieuWorkspace>::mathieu_Mc","value":"fn (j: i32, n: i32, q: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the radial j-th kind Mathieu functions Mc_n^{(j)}(q,x) and Ms_n^{(j)}(q,x) of order n.\n \n The allowed values of j are 1 and 2. The functions for j = 3,4 can be computed as M_n^{(3)} = M_n^{(1)} + iM_n^{(2)} and M_n^{(4)} = M_n^{(1)} - iM_n^{(2)}, where M_n^{(j)} = Mc_n^{(j)} or Ms_n^{(j)}.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3966},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mathieu.rs","byte_start":833496,"byte_end":833506,"line_start":117,"line_end":117,"column_start":12,"column_end":22},"name":"mathieu_Ms","qualname":"<MathieuWorkspace>::mathieu_Ms","value":"fn (j: i32, n: i32, q: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the radial j-th kind Mathieu functions Mc_n^{(j)}(q,x) and Ms_n^{(j)}(q,x) of order n.\n \n The allowed values of j are 1 and 2. The functions for j = 3,4 can be computed as M_n^{(3)} = M_n^{(1)} + iM_n^{(2)} and M_n^{(4)} = M_n^{(1)} - iM_n^{(2)}, where M_n^{(j)} = Mc_n^{(j)} or Ms_n^{(j)}.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3967},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mathieu.rs","byte_start":833995,"byte_end":834011,"line_start":125,"line_end":125,"column_start":12,"column_end":28},"name":"mathieu_Mc_array","qualname":"<MathieuWorkspace>::mathieu_Mc_array","value":"fn (&mut self, j: i32, nmin: i32, nmax: i32, q: f64, x: f64, result_array: &mut [f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This routine computes a series of the radial Mathieu functions of kind j, with order from nmin to nmax inclusive, storing the results in the array result_array.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3968},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mathieu.rs","byte_start":834447,"byte_end":834463,"line_start":132,"line_end":132,"column_start":12,"column_end":28},"name":"mathieu_Ms_array","qualname":"<MathieuWorkspace>::mathieu_Ms_array","value":"fn (&mut self, j: i32, nmin: i32, nmax: i32, q: f64, x: f64, result_array: &mut [f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This routine computes a series of the radial Mathieu functions of kind j, with order from nmin to nmax inclusive, storing the results in the array result_array.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":3976},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"matrix","qualname":"::types::matrix","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","parent":null,"children":[{"krate":0,"index":3977},{"krate":0,"index":3978},{"krate":0,"index":3981},{"krate":0,"index":3984},{"krate":0,"index":3985},{"krate":0,"index":3986},{"krate":0,"index":3988},{"krate":0,"index":3995},{"krate":0,"index":3998},{"krate":0,"index":4037},{"krate":0,"index":4039},{"krate":0,"index":4041},{"krate":0,"index":4046},{"krate":0,"index":4049},{"krate":0,"index":4086},{"krate":0,"index":4088},{"krate":0,"index":4090}],"decl_id":null,"docs":"#Matrices","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":3986},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":838118,"byte_end":838128,"line_start":59,"line_end":59,"column_start":12,"column_end":22},"name":"MatrixView","qualname":"::types::matrix::MatrixView","value":"MatrixView {  }","parent":null,"children":[{"krate":0,"index":3987}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3989},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":839484,"byte_end":839495,"line_start":81,"line_end":81,"column_start":12,"column_end":23},"name":"from_matrix","qualname":"<MatrixView>::from_matrix","value":"fn (m: &mut MatrixF64, k1: usize, k2: usize, n1: usize, n2: usize) -> MatrixView","parent":null,"children":[],"decl_id":null,"docs":" These functions return a matrix view of a submatrix of the matrix m. The upper-left element of the submatrix is the element (k1,k2)\n of the original matrix. The submatrix has n1 rows and n2 columns. The physical number of columns in memory given by tda is unchanged.\n Mathematically, the (i,j)-th element of the new matrix is given by,\n \n m'(i,j) = m->data[(k1*m->tda + k2) + i*m->tda + j]\n \n where the index i runs from 0 to n1-1 and the index j runs from 0 to n2-1.\n \n The data pointer of the returned matrix struct is set to null if the combined parameters (i,j,n1,n2,tda) overrun the ends of the original\n matrix.\n \n The new matrix view is only a view of the block underlying the existing matrix, m. The block containing the elements of m is not\n owned by the new matrix view. When the view goes out of scope the original matrix m and its block will continue to exist. The original\n memory can only be deallocated by freeing the original matrix. Of course, the original matrix should not be deallocated while the view\n is still in use.\n \n The function gsl_matrix_const_submatrix is equivalent to gsl_matrix_submatrix but can be used for matrices which are declared const.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3990},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":840585,"byte_end":840595,"line_start":101,"line_end":101,"column_start":12,"column_end":22},"name":"from_array","qualname":"<MatrixView>::from_array","value":"fn (base: &mut [f64], n1: usize, n2: usize) -> MatrixView","parent":null,"children":[],"decl_id":null,"docs":" These functions return a matrix view of the array base. The matrix has n1 rows and n2 columns. The physical number of columns in memory\n is also given by n2. Mathematically, the (i,j)-th element of the new matrix is given by,\n \n m'(i,j) = base[i*n2 + j]\n \n where the index i runs from 0 to n1-1 and the index j runs from 0 to n2-1.\n \n The new matrix is only a view of the array base. When the view goes out of scope the original array base will continue to exist. The\n original memory can only be deallocated by freeing the original array. Of course, the original array should not be deallocated while\n the view is still in use.\n \n The function gsl_matrix_const_view_array is equivalent to gsl_matrix_view_array but can be used for matrices which are declared const.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3991},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":841881,"byte_end":841900,"line_start":124,"line_end":124,"column_start":12,"column_end":31},"name":"from_array_with_tda","qualname":"<MatrixView>::from_array_with_tda","value":"fn (base: &mut [f64], n1: usize, n2: usize, tda: usize) -> MatrixView","parent":null,"children":[],"decl_id":null,"docs":" These functions return a matrix view of the array base with a physical number of columns tda which may differ from the corresponding\n dimension of the matrix. The matrix has n1 rows and n2 columns, and the physical number of columns in memory is given by tda.\n Mathematically, the (i,j)-th element of the new matrix is given by,\n \n m'(i,j) = base[i*tda + j]","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3992},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":843033,"byte_end":843044,"line_start":144,"line_end":144,"column_start":12,"column_end":23},"name":"from_vector","qualname":"<MatrixView>::from_vector","value":"fn (v: &mut VectorF64, n1: usize, n2: usize) -> MatrixView","parent":null,"children":[],"decl_id":null,"docs":" These functions return a matrix view of the vector v. The matrix has n1 rows and n2 columns. The vector must have unit stride. The\n physical number of columns in memory is also given by n2. Mathematically, the (i,j)-th element of the new matrix is given by,\n \n m'(i,j) = v->data[i*n2 + j]\n \n where the index i runs from 0 to n1-1 and the index j runs from 0 to n2-1.\n \n The new matrix is only a view of the vector v. When the view goes out of scope the original vector v will continue to exist. The original\n memory can only be deallocated by freeing the original vector. Of course, the original vector should not be deallocated while the view\n is still in use.\n \n The function gsl_matrix_const_view_vector is equivalent to gsl_matrix_view_vector but can be used for matrices which are declared const.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3993},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":844292,"byte_end":844312,"line_start":166,"line_end":166,"column_start":12,"column_end":32},"name":"from_vector_with_tda","qualname":"<MatrixView>::from_vector_with_tda","value":"fn (v: &mut VectorF64, n1: usize, n2: usize, tda: usize) -> MatrixView","parent":null,"children":[],"decl_id":null,"docs":" These functions return a matrix view of the vector v with a physical number of columns tda which may differ from the corresponding\n matrix dimension. The vector must have unit stride. The matrix has n1 rows and n2 columns, and the physical number of columns in\n memory is given by tda. Mathematically, the (i,j)-th element of the new matrix is given by,\n \n m'(i,j) = v->data[i*tda + j]\n \n where the index i runs from 0 to n1-1 and the index j runs from 0 to n2-1.\n \n The new matrix is only a view of the vector v. When the view goes out of scope the original vector v will continue to exist. The original\n memory can only be deallocated by freeing the original vector. Of course, the original vector should not be deallocated while the view\n is still in use.\n \n The function gsl_matrix_const_view_vector_with_tda is equivalent to gsl_matrix_view_vector_with_tda but can be used for matrices which\n are declared const.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3994},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":844569,"byte_end":844575,"line_start":174,"line_end":174,"column_start":12,"column_end":18},"name":"matrix","qualname":"<MatrixView>::matrix","value":"fn (&mut self) -> MatrixF64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":3995},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":844778,"byte_end":844787,"line_start":184,"line_end":184,"column_start":12,"column_end":21},"name":"MatrixF64","qualname":"::types::matrix::MatrixF64","value":"MatrixF64 {  }","parent":null,"children":[{"krate":0,"index":3996},{"krate":0,"index":3997}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":3999},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":845035,"byte_end":845038,"line_start":197,"line_end":197,"column_start":12,"column_end":15},"name":"new","qualname":"<MatrixF64>::new","value":"fn (n1: usize, n2: usize) -> Option<MatrixF64>","parent":null,"children":[],"decl_id":null,"docs":" Creates a new MatrixF64 with all elements set to zero\n \n Example with n1 = 2 and n2 = 3 :\n \n XX XX XX\n \n XX XX XX\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4000},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":845530,"byte_end":845533,"line_start":212,"line_end":212,"column_start":12,"column_end":15},"name":"get","qualname":"<MatrixF64>::get","value":"fn (&self, y: usize, x: usize) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the (i,j)-th element of the matrix.\n If y or x lie outside the allowed range of 0 to n1-1 and 0 to n2-1 then the error handler is invoked and 0 is returned.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4001},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":845839,"byte_end":845842,"line_start":218,"line_end":218,"column_start":12,"column_end":15},"name":"set","qualname":"<MatrixF64>::set","value":"fn (&mut self, y: usize, x: usize, value: f64) -> &MatrixF64","parent":null,"children":[],"decl_id":null,"docs":" This function sets the value of the (i,j)-th element of the matrix to value.\n If y or x lies outside the allowed range of 0 to n1-1 and 0 to n2-1 then the error handler is invoked.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4002},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":846070,"byte_end":846077,"line_start":224,"line_end":224,"column_start":12,"column_end":19},"name":"set_all","qualname":"<MatrixF64>::set_all","value":"fn (&mut self, x: f64) -> &MatrixF64","parent":null,"children":[],"decl_id":null,"docs":" This function sets all the elements of the matrix to the value x.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4003},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":846268,"byte_end":846276,"line_start":230,"line_end":230,"column_start":12,"column_end":20},"name":"set_zero","qualname":"<MatrixF64>::set_zero","value":"fn (&mut self) -> &MatrixF64","parent":null,"children":[],"decl_id":null,"docs":" This function sets all the elements of the matrix to zero.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4004},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":846640,"byte_end":846652,"line_start":237,"line_end":237,"column_start":12,"column_end":24},"name":"set_identity","qualname":"<MatrixF64>::set_identity","value":"fn (&mut self) -> &MatrixF64","parent":null,"children":[],"decl_id":null,"docs":" This function sets the elements of the matrix to the corresponding elements of the identity matrix, m(i,j) = \\delta(i,j), i.e. a unit diagonal with all off-diagonal elements zero.\n This applies to both square and rectangular matrices.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4005},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":846896,"byte_end":846905,"line_start":243,"line_end":243,"column_start":12,"column_end":21},"name":"copy_from","qualname":"<MatrixF64>::copy_from","value":"fn (&mut self, other: &MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the other matrix into the self matrix. The two matrices must have the same size.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4006},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":847181,"byte_end":847188,"line_start":248,"line_end":248,"column_start":12,"column_end":19},"name":"copy_to","qualname":"<MatrixF64>::copy_to","value":"fn (&self, other: &mut MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the self matrix into the other matrix. The two matrices must have the same size.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4007},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":847468,"byte_end":847472,"line_start":253,"line_end":253,"column_start":12,"column_end":16},"name":"swap","qualname":"<MatrixF64>::swap","value":"fn (&mut self, other: &mut MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function exchanges the elements of the matrices self and other by copying. The two matrices must have the same size.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4008},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":847722,"byte_end":847729,"line_start":258,"line_end":258,"column_start":12,"column_end":19},"name":"get_row","qualname":"<MatrixF64>::get_row","value":"fn (&self, y: usize) -> Option<(VectorF64, enums::Value)>","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the y-th row of the matrix into the returned vector.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4009},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":848190,"byte_end":848197,"line_start":271,"line_end":271,"column_start":12,"column_end":19},"name":"get_col","qualname":"<MatrixF64>::get_col","value":"fn (&self, x: usize) -> Option<(VectorF64, enums::Value)>","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the x-th column of the matrix into the returned vector.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4010},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":848724,"byte_end":848731,"line_start":285,"line_end":285,"column_start":12,"column_end":19},"name":"set_row","qualname":"<MatrixF64>::set_row","value":"fn (&mut self, y: usize, v: &VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the vector v into the y-th row of the matrix.\n The length of the vector must be the same as the length of the row.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4011},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":849101,"byte_end":849108,"line_start":293,"line_end":293,"column_start":12,"column_end":19},"name":"set_col","qualname":"<MatrixF64>::set_col","value":"fn (&mut self, x: usize, v: &VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the vector v into the x-th column of the matrix.\n The length of the vector must be the same as the length of the column.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4012},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":849386,"byte_end":849395,"line_start":300,"line_end":300,"column_start":12,"column_end":21},"name":"swap_rows","qualname":"<MatrixF64>::swap_rows","value":"fn (&mut self, y1: usize, y2: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function exchanges the y1-th and y2-th rows of the matrix in-place.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4013},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":849632,"byte_end":849644,"line_start":305,"line_end":305,"column_start":12,"column_end":24},"name":"swap_columns","qualname":"<MatrixF64>::swap_columns","value":"fn (&mut self, x1: usize, x2: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function exchanges the x1-th and x2-th columns of the matrix in-place.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4014},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":849954,"byte_end":849966,"line_start":311,"line_end":311,"column_start":12,"column_end":24},"name":"swap_row_col","qualname":"<MatrixF64>::swap_row_col","value":"fn (&mut self, i: usize, j: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function exchanges the i-th row and j-th column of the matrix in-place.\n The matrix must be square for this operation to be possible.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4015},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":850348,"byte_end":850364,"line_start":317,"line_end":317,"column_start":12,"column_end":28},"name":"transpose_memcpy","qualname":"<MatrixF64>::transpose_memcpy","value":"fn (&self) -> Option<(MatrixF64, enums::Value)>","parent":null,"children":[],"decl_id":null,"docs":" This function returns the transpose of the matrix by copying the elements into it.\n This function works for all matrices provided that the dimensions of the matrix dest match the transposed dimensions of the matrix.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4016},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":850938,"byte_end":850947,"line_start":331,"line_end":331,"column_start":12,"column_end":21},"name":"transpose","qualname":"<MatrixF64>::transpose","value":"fn (&mut self) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function replaces the matrix m by its transpose by copying the elements of the matrix in-place.\n The matrix must be square for this operation to be possible.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4017},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":851316,"byte_end":851319,"line_start":337,"line_end":337,"column_start":12,"column_end":15},"name":"add","qualname":"<MatrixF64>::add","value":"fn (&mut self, other: &MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function adds the elements of the other matrix to the elements of the self matrix.\n The result self(i,j) <- self(i,j) + other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4018},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":851719,"byte_end":851722,"line_start":343,"line_end":343,"column_start":12,"column_end":15},"name":"sub","qualname":"<MatrixF64>::sub","value":"fn (&mut self, other: &MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function subtracts the elements of the other matrix from the elements of the self matrix.\n The result self(i,j) <- self(i,j) - other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4019},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":852121,"byte_end":852133,"line_start":349,"line_end":349,"column_start":12,"column_end":24},"name":"mul_elements","qualname":"<MatrixF64>::mul_elements","value":"fn (&mut self, other: &MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function multiplies the elements of the self matrix by the elements of the other matrix.\n The result self(i,j) <- self(i,j) * other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4020},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":852538,"byte_end":852550,"line_start":355,"line_end":355,"column_start":12,"column_end":24},"name":"div_elements","qualname":"<MatrixF64>::div_elements","value":"fn (&mut self, other: &MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function divides the elements of the self matrix by the elements of the other matrix.\n The result self(i,j) <- self(i,j) / other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4021},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":852852,"byte_end":852857,"line_start":360,"line_end":360,"column_start":12,"column_end":17},"name":"scale","qualname":"<MatrixF64>::scale","value":"fn (&mut self, x: f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function multiplies the elements of the self matrix by the constant factor x. The result self(i,j) <- x self(i,j) is stored in self.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4022},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":853128,"byte_end":853140,"line_start":365,"line_end":365,"column_start":12,"column_end":24},"name":"add_constant","qualname":"<MatrixF64>::add_constant","value":"fn (&mut self, x: f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function adds the constant value x to the elements of the self matrix. The result self(i,j) <- self(i,j) + x is stored in self.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4023},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":853345,"byte_end":853348,"line_start":370,"line_end":370,"column_start":12,"column_end":15},"name":"max","qualname":"<MatrixF64>::max","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the maximum value in the self matrix.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4024},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":853500,"byte_end":853503,"line_start":375,"line_end":375,"column_start":12,"column_end":15},"name":"min","qualname":"<MatrixF64>::min","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the minimum value in the self matrix.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4025},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":853705,"byte_end":853711,"line_start":380,"line_end":380,"column_start":12,"column_end":18},"name":"minmax","qualname":"<MatrixF64>::minmax","value":"fn (&self, min_out: &mut f64, max_out: &mut f64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function returns the minimum and maximum values in the self matrix, storing them in min_out and max_out.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4026},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":854087,"byte_end":854096,"line_start":386,"line_end":386,"column_start":12,"column_end":21},"name":"max_index","qualname":"<MatrixF64>::max_index","value":"fn (&self) -> (usize, usize)","parent":null,"children":[],"decl_id":null,"docs":" This function returns the indices of the maximum value in the self matrix, storing them in imax and jmax.\n When there are several equal maximum elements then the first element found is returned, searching in row-major order.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4027},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":854544,"byte_end":854553,"line_start":396,"line_end":396,"column_start":12,"column_end":21},"name":"min_index","qualname":"<MatrixF64>::min_index","value":"fn (&self) -> (usize, usize)","parent":null,"children":[],"decl_id":null,"docs":" This function returns the indices of the minimum value in the self matrix, storing them in imin and jmin.\n When there are several equal minimum elements then the first element found is returned, searching in row-major order.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4028},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":855041,"byte_end":855053,"line_start":406,"line_end":406,"column_start":12,"column_end":24},"name":"minmax_index","qualname":"<MatrixF64>::minmax_index","value":"fn (&self) -> (usize, usize, usize, usize)","parent":null,"children":[],"decl_id":null,"docs":" This function returns the indices of the minimum and maximum values in the self matrix, storing them in (imin,jmin) and (imax,jmax).\n When there are several equal minimum or maximum elements then the first elements found are returned, searching in row-major order.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4029},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":855466,"byte_end":855473,"line_start":417,"line_end":417,"column_start":12,"column_end":19},"name":"is_null","qualname":"<MatrixF64>::is_null","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all the elements of the self matrix are stricly zero.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4030},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":855721,"byte_end":855727,"line_start":425,"line_end":425,"column_start":12,"column_end":18},"name":"is_pos","qualname":"<MatrixF64>::is_pos","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all the elements of the self matrix are stricly positive.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4031},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":855974,"byte_end":855980,"line_start":433,"line_end":433,"column_start":12,"column_end":18},"name":"is_neg","qualname":"<MatrixF64>::is_neg","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all the elements of the self matrix are stricly negative.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4032},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":856231,"byte_end":856241,"line_start":441,"line_end":441,"column_start":12,"column_end":22},"name":"is_non_neg","qualname":"<MatrixF64>::is_non_neg","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all the elements of the self matrix are stricly non-negative.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4033},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":856475,"byte_end":856480,"line_start":449,"line_end":449,"column_start":12,"column_end":17},"name":"equal","qualname":"<MatrixF64>::equal","value":"fn (&self, other: &MatrixF64) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all elements of the two matrix are equal.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4034},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":856661,"byte_end":856666,"line_start":456,"line_end":456,"column_start":12,"column_end":17},"name":"size1","qualname":"<MatrixF64>::size1","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4035},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":856822,"byte_end":856827,"line_start":464,"line_end":464,"column_start":12,"column_end":17},"name":"size2","qualname":"<MatrixF64>::size2","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4036},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":856983,"byte_end":856988,"line_start":472,"line_end":472,"column_start":12,"column_end":17},"name":"clone","qualname":"<MatrixF64>::clone","value":"fn (&self) -> Option<MatrixF64>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4046},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":858789,"byte_end":858798,"line_start":544,"line_end":544,"column_start":12,"column_end":21},"name":"MatrixF32","qualname":"::types::matrix::MatrixF32","value":"MatrixF32 {  }","parent":null,"children":[{"krate":0,"index":4047},{"krate":0,"index":4048}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4050},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":859052,"byte_end":859055,"line_start":557,"line_end":557,"column_start":12,"column_end":15},"name":"new","qualname":"<MatrixF32>::new","value":"fn (n1: usize, n2: usize) -> Option<MatrixF32>","parent":null,"children":[],"decl_id":null,"docs":" Creates a new MatrixF64 with all elements set to zero\n \n Example with n1 = 2 and n2 = 3 :\n \n XX XX XX\n \n XX XX XX\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4051},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":859553,"byte_end":859556,"line_start":572,"line_end":572,"column_start":12,"column_end":15},"name":"get","qualname":"<MatrixF32>::get","value":"fn (&self, y: usize, x: usize) -> f32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the (i,j)-th element of the matrix.\n If y or x lie outside the allowed range of 0 to n1-1 and 0 to n2-1 then the error handler is invoked and 0 is returned.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4052},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":859868,"byte_end":859871,"line_start":578,"line_end":578,"column_start":12,"column_end":15},"name":"set","qualname":"<MatrixF32>::set","value":"fn (&mut self, y: usize, x: usize, value: f32) -> &MatrixF32","parent":null,"children":[],"decl_id":null,"docs":" This function sets the value of the (i,j)-th element of the matrix to value.\n If y or x lies outside the allowed range of 0 to n1-1 and 0 to n2-1 then the error handler is invoked.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4053},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":860105,"byte_end":860112,"line_start":584,"line_end":584,"column_start":12,"column_end":19},"name":"set_all","qualname":"<MatrixF32>::set_all","value":"fn (&mut self, x: f32) -> &MatrixF32","parent":null,"children":[],"decl_id":null,"docs":" This function sets all the elements of the matrix to the value x.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4054},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":860309,"byte_end":860317,"line_start":590,"line_end":590,"column_start":12,"column_end":20},"name":"set_zero","qualname":"<MatrixF32>::set_zero","value":"fn (&mut self) -> &MatrixF32","parent":null,"children":[],"decl_id":null,"docs":" This function sets all the elements of the matrix to zero.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4055},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":860687,"byte_end":860699,"line_start":597,"line_end":597,"column_start":12,"column_end":24},"name":"set_identity","qualname":"<MatrixF32>::set_identity","value":"fn (&mut self) -> &MatrixF32","parent":null,"children":[],"decl_id":null,"docs":" This function sets the elements of the matrix to the corresponding elements of the identity matrix, m(i,j) = \\delta(i,j), i.e. a unit diagonal with all off-diagonal elements zero.\n This applies to both square and rectangular matrices.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4056},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":860949,"byte_end":860958,"line_start":603,"line_end":603,"column_start":12,"column_end":21},"name":"copy_from","qualname":"<MatrixF32>::copy_from","value":"fn (&mut self, other: &MatrixF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the other matrix into the self matrix. The two matrices must have the same size.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4057},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":861240,"byte_end":861247,"line_start":608,"line_end":608,"column_start":12,"column_end":19},"name":"copy_to","qualname":"<MatrixF32>::copy_to","value":"fn (&self, other: &mut MatrixF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the self matrix into the other matrix. The two matrices must have the same size.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4058},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":861533,"byte_end":861537,"line_start":613,"line_end":613,"column_start":12,"column_end":16},"name":"swap","qualname":"<MatrixF32>::swap","value":"fn (&mut self, other: &mut MatrixF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function exchanges the elements of the matrices self and other by copying. The two matrices must have the same size.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4059},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":861793,"byte_end":861800,"line_start":618,"line_end":618,"column_start":12,"column_end":19},"name":"get_row","qualname":"<MatrixF32>::get_row","value":"fn (&self, y: usize) -> Option<(VectorF32, enums::Value)>","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the y-th row of the matrix into the returned vector.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4060},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":862273,"byte_end":862280,"line_start":631,"line_end":631,"column_start":12,"column_end":19},"name":"get_col","qualname":"<MatrixF32>::get_col","value":"fn (&self, x: usize) -> Option<(VectorF32, enums::Value)>","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the x-th column of the matrix into the returned vector.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4061},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":862819,"byte_end":862826,"line_start":645,"line_end":645,"column_start":12,"column_end":19},"name":"set_row","qualname":"<MatrixF32>::set_row","value":"fn (&mut self, y: usize, v: &VectorF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the vector v into the y-th row of the matrix.\n The length of the vector must be the same as the length of the row.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4062},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":863202,"byte_end":863209,"line_start":653,"line_end":653,"column_start":12,"column_end":19},"name":"set_col","qualname":"<MatrixF32>::set_col","value":"fn (&mut self, x: usize, v: &VectorF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the vector v into the x-th column of the matrix.\n The length of the vector must be the same as the length of the column.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4063},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":863493,"byte_end":863502,"line_start":660,"line_end":660,"column_start":12,"column_end":21},"name":"swap_rows","qualname":"<MatrixF32>::swap_rows","value":"fn (&mut self, y1: usize, y2: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function exchanges the y1-th and y2-th rows of the matrix in-place.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4064},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":863745,"byte_end":863757,"line_start":665,"line_end":665,"column_start":12,"column_end":24},"name":"swap_columns","qualname":"<MatrixF32>::swap_columns","value":"fn (&mut self, x1: usize, x2: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function exchanges the x1-th and x2-th columns of the matrix in-place.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4065},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":864065,"byte_end":864077,"line_start":670,"line_end":670,"column_start":12,"column_end":24},"name":"swap_row_col","qualname":"<MatrixF32>::swap_row_col","value":"fn (&mut self, i: usize, j: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function exchanges the i-th row and j-th column of the matrix in-place. The matrix must be square for this operation to be possible.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4066},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":864465,"byte_end":864481,"line_start":676,"line_end":676,"column_start":12,"column_end":28},"name":"transpose_memcpy","qualname":"<MatrixF32>::transpose_memcpy","value":"fn (&self) -> Option<(MatrixF32, enums::Value)>","parent":null,"children":[],"decl_id":null,"docs":" This function returns the transpose of the matrix by copying the elements into it.\n This function works for all matrices provided that the dimensions of the matrix dest match the transposed dimensions of the matrix.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4067},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":865131,"byte_end":865140,"line_start":693,"line_end":693,"column_start":12,"column_end":21},"name":"transpose","qualname":"<MatrixF32>::transpose","value":"fn (&self) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function replaces the matrix m by its transpose by copying the elements of the matrix in-place.\n The matrix must be square for this operation to be possible.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4068},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":865511,"byte_end":865514,"line_start":699,"line_end":699,"column_start":12,"column_end":15},"name":"add","qualname":"<MatrixF32>::add","value":"fn (&mut self, other: &MatrixF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function adds the elements of the other matrix to the elements of the self matrix.\n The result self(i,j) <- self(i,j) + other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4069},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":865920,"byte_end":865923,"line_start":705,"line_end":705,"column_start":12,"column_end":15},"name":"sub","qualname":"<MatrixF32>::sub","value":"fn (&mut self, other: &MatrixF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function subtracts the elements of the other matrix from the elements of the self matrix.\n The result self(i,j) <- self(i,j) - other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4070},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":866328,"byte_end":866340,"line_start":711,"line_end":711,"column_start":12,"column_end":24},"name":"mul_elements","qualname":"<MatrixF32>::mul_elements","value":"fn (&mut self, other: &MatrixF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function multiplies the elements of the self matrix by the elements of the other matrix.\n The result self(i,j) <- self(i,j) * other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4071},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":866751,"byte_end":866763,"line_start":717,"line_end":717,"column_start":12,"column_end":24},"name":"div_elements","qualname":"<MatrixF32>::div_elements","value":"fn (&mut self, other: &MatrixF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function divides the elements of the self matrix by the elements of the other matrix.\n The result self(i,j) <- self(i,j) / other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4072},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":867071,"byte_end":867076,"line_start":722,"line_end":722,"column_start":12,"column_end":17},"name":"scale","qualname":"<MatrixF32>::scale","value":"fn (&mut self, x: f32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function multiplies the elements of the self matrix by the constant factor x. The result self(i,j) <- x self(i,j) is stored in self.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4073},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":867353,"byte_end":867365,"line_start":727,"line_end":727,"column_start":12,"column_end":24},"name":"add_constant","qualname":"<MatrixF32>::add_constant","value":"fn (&mut self, x: f32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function adds the constant value x to the elements of the self matrix. The result self(i,j) <- self(i,j) + x is stored in self.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4074},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":867576,"byte_end":867579,"line_start":732,"line_end":732,"column_start":12,"column_end":15},"name":"max","qualname":"<MatrixF32>::max","value":"fn (&self) -> f32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the maximum value in the self matrix.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4075},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":867737,"byte_end":867740,"line_start":737,"line_end":737,"column_start":12,"column_end":15},"name":"min","qualname":"<MatrixF32>::min","value":"fn (&self) -> f32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the minimum value in the self matrix.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4076},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":867948,"byte_end":867954,"line_start":742,"line_end":742,"column_start":12,"column_end":18},"name":"minmax","qualname":"<MatrixF32>::minmax","value":"fn (&self, min_out: &mut f32, max_out: &mut f32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function returns the minimum and maximum values in the self matrix, storing them in min_out and max_out.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4077},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":868336,"byte_end":868345,"line_start":748,"line_end":748,"column_start":12,"column_end":21},"name":"max_index","qualname":"<MatrixF32>::max_index","value":"fn (&self) -> (usize, usize)","parent":null,"children":[],"decl_id":null,"docs":" This function returns the indices of the maximum value in the self matrix, storing them in imax and jmax.\n When there are several equal maximum elements then the first element found is returned, searching in row-major order.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4078},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":868799,"byte_end":868808,"line_start":758,"line_end":758,"column_start":12,"column_end":21},"name":"min_index","qualname":"<MatrixF32>::min_index","value":"fn (&self) -> (usize, usize)","parent":null,"children":[],"decl_id":null,"docs":" This function returns the indices of the minimum value in the self matrix, storing them in imin and jmin.\n When there are several equal minimum elements then the first element found is returned, searching in row-major order.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4079},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":869302,"byte_end":869314,"line_start":768,"line_end":768,"column_start":12,"column_end":24},"name":"minmax_index","qualname":"<MatrixF32>::minmax_index","value":"fn (&self) -> (usize, usize, usize, usize)","parent":null,"children":[],"decl_id":null,"docs":" This function returns the indices of the minimum and maximum values in the self matrix, storing them in (imin,jmin) and (imax,jmax).\n When there are several equal minimum or maximum elements then the first elements found are returned, searching in row-major order.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4080},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":869733,"byte_end":869740,"line_start":779,"line_end":779,"column_start":12,"column_end":19},"name":"is_null","qualname":"<MatrixF32>::is_null","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all the elements of the self matrix are stricly zero.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4081},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":869994,"byte_end":870000,"line_start":787,"line_end":787,"column_start":12,"column_end":18},"name":"is_pos","qualname":"<MatrixF32>::is_pos","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all the elements of the self matrix are stricly positive.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4082},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":870253,"byte_end":870259,"line_start":795,"line_end":795,"column_start":12,"column_end":18},"name":"is_neg","qualname":"<MatrixF32>::is_neg","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all the elements of the self matrix are stricly negative.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4083},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":870516,"byte_end":870526,"line_start":803,"line_end":803,"column_start":12,"column_end":22},"name":"is_non_neg","qualname":"<MatrixF32>::is_non_neg","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all the elements of the self matrix are stricly non-negative.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4084},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":870766,"byte_end":870771,"line_start":811,"line_end":811,"column_start":12,"column_end":17},"name":"equal","qualname":"<MatrixF32>::equal","value":"fn (&self, other: &MatrixF32) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all elements of the two matrix are equal.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4085},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":870958,"byte_end":870963,"line_start":818,"line_end":818,"column_start":12,"column_end":17},"name":"clone","qualname":"<MatrixF32>::clone","value":"fn (&self) -> Option<MatrixF32>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":4095},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"matrix_complex","qualname":"::types::matrix_complex","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","parent":null,"children":[{"krate":0,"index":4096},{"krate":0,"index":4097},{"krate":0,"index":4100},{"krate":0,"index":4103},{"krate":0,"index":4106},{"krate":0,"index":4107},{"krate":0,"index":4108},{"krate":0,"index":4110},{"krate":0,"index":4141},{"krate":0,"index":4143},{"krate":0,"index":4145},{"krate":0,"index":4150},{"krate":0,"index":4152},{"krate":0,"index":4183},{"krate":0,"index":4185},{"krate":0,"index":4187}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4108},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":873048,"byte_end":873064,"line_start":12,"line_end":12,"column_start":12,"column_end":28},"name":"MatrixComplexF64","qualname":"::types::matrix_complex::MatrixComplexF64","value":"MatrixComplexF64 {  }","parent":null,"children":[{"krate":0,"index":4109}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4111},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":873307,"byte_end":873310,"line_start":24,"line_end":24,"column_start":12,"column_end":15},"name":"new","qualname":"<MatrixComplexF64>::new","value":"fn (n1: usize, n2: usize) -> Option<MatrixComplexF64>","parent":null,"children":[],"decl_id":null,"docs":" Creates a new MatrixF64 with all elements set to zero\n \n Example with n1 = 2 and n2 = 3 :\n \n XX XX XX\n \n XX XX XX\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4112},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":873792,"byte_end":873795,"line_start":38,"line_end":38,"column_start":12,"column_end":15},"name":"get","qualname":"<MatrixComplexF64>::get","value":"fn (&self, y: usize, x: usize) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the (i,j)-th element of the matrix.\n If y or x lie outside the allowed range of 0 to n1-1 and 0 to n2-1 then the error handler is invoked and 0 is returned.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4113},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":874139,"byte_end":874142,"line_start":44,"line_end":44,"column_start":12,"column_end":15},"name":"set","qualname":"<MatrixComplexF64>::set","value":"fn (&mut self, y: usize, x: usize, value: &ComplexF64) -> &MatrixComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function sets the value of the (i,j)-th element of the matrix to value.\n If y or x lies outside the allowed range of 0 to n1-1 and 0 to n2-1 then the error handler is invoked.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4114},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":874417,"byte_end":874424,"line_start":50,"line_end":50,"column_start":12,"column_end":19},"name":"set_all","qualname":"<MatrixComplexF64>::set_all","value":"fn (&mut self, x: &ComplexF64) -> &MatrixComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function sets all the elements of the matrix to the value x.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4115},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":874662,"byte_end":874670,"line_start":56,"line_end":56,"column_start":12,"column_end":20},"name":"set_zero","qualname":"<MatrixComplexF64>::set_zero","value":"fn (&mut self) -> &MatrixComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function sets all the elements of the matrix to zero.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4116},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":875049,"byte_end":875061,"line_start":63,"line_end":63,"column_start":12,"column_end":24},"name":"set_identity","qualname":"<MatrixComplexF64>::set_identity","value":"fn (&mut self) -> &MatrixComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function sets the elements of the matrix to the corresponding elements of the identity matrix, m(i,j) = \\delta(i,j), i.e. a unit diagonal with all off-diagonal elements zero.\n This applies to both square and rectangular matrices.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4117},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":875320,"byte_end":875329,"line_start":69,"line_end":69,"column_start":12,"column_end":21},"name":"copy_from","qualname":"<MatrixComplexF64>::copy_from","value":"fn (&mut self, other: &MatrixComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the other matrix into the self matrix. The two matrices must have the same size.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4118},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":875620,"byte_end":875627,"line_start":74,"line_end":74,"column_start":12,"column_end":19},"name":"copy_to","qualname":"<MatrixComplexF64>::copy_to","value":"fn (&self, other: &mut MatrixComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the self matrix into the other matrix. The two matrices must have the same size.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4119},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":875922,"byte_end":875926,"line_start":79,"line_end":79,"column_start":12,"column_end":16},"name":"swap","qualname":"<MatrixComplexF64>::swap","value":"fn (&mut self, other: &mut MatrixComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function exchanges the elements of the matrices self and other by copying. The two matrices must have the same size.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4120},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":876191,"byte_end":876198,"line_start":84,"line_end":84,"column_start":12,"column_end":19},"name":"get_row","qualname":"<MatrixComplexF64>::get_row","value":"fn (&self, y: usize) -> Option<(VectorComplexF64, enums::Value)>","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the y-th row of the matrix into the returned vector.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4121},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":876682,"byte_end":876689,"line_start":97,"line_end":97,"column_start":12,"column_end":19},"name":"get_col","qualname":"<MatrixComplexF64>::get_col","value":"fn (&self, x: usize) -> Option<(VectorComplexF64, enums::Value)>","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the x-th column of the matrix into the returned vector.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4122},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":877239,"byte_end":877246,"line_start":111,"line_end":111,"column_start":12,"column_end":19},"name":"set_row","qualname":"<MatrixComplexF64>::set_row","value":"fn (&mut self, y: usize, v: &VectorComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the vector v into the y-th row of the matrix.\n The length of the vector must be the same as the length of the row.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4123},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":877631,"byte_end":877638,"line_start":119,"line_end":119,"column_start":12,"column_end":19},"name":"set_col","qualname":"<MatrixComplexF64>::set_col","value":"fn (&mut self, x: usize, v: &VectorComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the vector v into the x-th column of the matrix.\n The length of the vector must be the same as the length of the column.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4124},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":877931,"byte_end":877940,"line_start":126,"line_end":126,"column_start":12,"column_end":21},"name":"swap_rows","qualname":"<MatrixComplexF64>::swap_rows","value":"fn (&mut self, y1: usize, y2: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function exchanges the y1-th and y2-th rows of the matrix in-place.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4125},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":878185,"byte_end":878197,"line_start":131,"line_end":131,"column_start":12,"column_end":24},"name":"swap_columns","qualname":"<MatrixComplexF64>::swap_columns","value":"fn (&mut self, x1: usize, x2: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function exchanges the x1-th and x2-th columns of the matrix in-place.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4126},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":878507,"byte_end":878519,"line_start":136,"line_end":136,"column_start":12,"column_end":24},"name":"swap_row_col","qualname":"<MatrixComplexF64>::swap_row_col","value":"fn (&mut self, i: usize, j: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function exchanges the i-th row and j-th column of the matrix in-place. The matrix must be square for this operation to be possible.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4127},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":878909,"byte_end":878925,"line_start":142,"line_end":142,"column_start":12,"column_end":28},"name":"transpose_memcpy","qualname":"<MatrixComplexF64>::transpose_memcpy","value":"fn (&self) -> Option<(MatrixComplexF64, enums::Value)>","parent":null,"children":[],"decl_id":null,"docs":" This function returns the transpose of the matrix by copying the elements into it.\n This function works for all matrices provided that the dimensions of the matrix dest match the transposed dimensions of the matrix.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4128},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":879512,"byte_end":879521,"line_start":156,"line_end":156,"column_start":12,"column_end":21},"name":"transpose","qualname":"<MatrixComplexF64>::transpose","value":"fn (&self) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function replaces the matrix m by its transpose by copying the elements of the matrix in-place.\n The matrix must be square for this operation to be possible.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4129},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":879894,"byte_end":879897,"line_start":162,"line_end":162,"column_start":12,"column_end":15},"name":"add","qualname":"<MatrixComplexF64>::add","value":"fn (&mut self, other: &MatrixComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function adds the elements of the other matrix to the elements of the self matrix.\n The result self(i,j) <- self(i,j) + other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4130},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":880312,"byte_end":880315,"line_start":168,"line_end":168,"column_start":12,"column_end":15},"name":"sub","qualname":"<MatrixComplexF64>::sub","value":"fn (&mut self, other: &MatrixComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function subtracts the elements of the other matrix from the elements of the self matrix.\n The result self(i,j) <- self(i,j) - other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4131},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":880729,"byte_end":880741,"line_start":174,"line_end":174,"column_start":12,"column_end":24},"name":"mul_elements","qualname":"<MatrixComplexF64>::mul_elements","value":"fn (&mut self, other: &MatrixComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function multiplies the elements of the self matrix by the elements of the other matrix.\n The result self(i,j) <- self(i,j) * other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4132},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":881161,"byte_end":881173,"line_start":180,"line_end":180,"column_start":12,"column_end":24},"name":"div_elements","qualname":"<MatrixComplexF64>::div_elements","value":"fn (&mut self, other: &MatrixComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function divides the elements of the self matrix by the elements of the other matrix.\n The result self(i,j) <- self(i,j) / other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4133},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":881490,"byte_end":881495,"line_start":185,"line_end":185,"column_start":12,"column_end":17},"name":"scale","qualname":"<MatrixComplexF64>::scale","value":"fn (&mut self, x: &ComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function multiplies the elements of the self matrix by the constant factor x. The result self(i,j) <- x self(i,j) is stored in self.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4134},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":881826,"byte_end":881838,"line_start":192,"line_end":192,"column_start":12,"column_end":24},"name":"add_constant","qualname":"<MatrixComplexF64>::add_constant","value":"fn (&mut self, x: &ComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function adds the constant value x to the elements of the self matrix. The result self(i,j) <- self(i,j) + x is stored in self.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4135},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":882127,"byte_end":882134,"line_start":199,"line_end":199,"column_start":12,"column_end":19},"name":"is_null","qualname":"<MatrixComplexF64>::is_null","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all the elements of the self matrix are stricly zero.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4136},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":882390,"byte_end":882396,"line_start":207,"line_end":207,"column_start":12,"column_end":18},"name":"is_pos","qualname":"<MatrixComplexF64>::is_pos","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all the elements of the self matrix are stricly positive.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4137},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":882651,"byte_end":882657,"line_start":215,"line_end":215,"column_start":12,"column_end":18},"name":"is_neg","qualname":"<MatrixComplexF64>::is_neg","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all the elements of the self matrix are stricly negative.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4138},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":882916,"byte_end":882926,"line_start":223,"line_end":223,"column_start":12,"column_end":22},"name":"is_non_neg","qualname":"<MatrixComplexF64>::is_non_neg","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all the elements of the self matrix are stricly non-negative.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4139},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":883168,"byte_end":883173,"line_start":231,"line_end":231,"column_start":12,"column_end":17},"name":"equal","qualname":"<MatrixComplexF64>::equal","value":"fn (&self, other: &MatrixComplexF64) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all elements of the two matrix are equal.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4140},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":883369,"byte_end":883374,"line_start":238,"line_end":238,"column_start":12,"column_end":17},"name":"clone","qualname":"<MatrixComplexF64>::clone","value":"fn (&self) -> Option<MatrixComplexF64>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4150},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":885166,"byte_end":885182,"line_start":304,"line_end":304,"column_start":12,"column_end":28},"name":"MatrixComplexF32","qualname":"::types::matrix_complex::MatrixComplexF32","value":"MatrixComplexF32 {  }","parent":null,"children":[{"krate":0,"index":4151}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4153},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":885431,"byte_end":885434,"line_start":316,"line_end":316,"column_start":12,"column_end":15},"name":"new","qualname":"<MatrixComplexF32>::new","value":"fn (n1: usize, n2: usize) -> Option<MatrixComplexF32>","parent":null,"children":[],"decl_id":null,"docs":" Creates a new MatrixF64 with all elements set to zero\n \n Example with n1 = 2 and n2 = 3 :\n \n XX XX XX\n \n XX XX XX\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4154},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":885922,"byte_end":885925,"line_start":330,"line_end":330,"column_start":12,"column_end":15},"name":"get","qualname":"<MatrixComplexF32>::get","value":"fn (&self, y: usize, x: usize) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the (i,j)-th element of the matrix.\n If y or x lie outside the allowed range of 0 to n1-1 and 0 to n2-1 then the error handler is invoked and 0 is returned.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4155},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":886275,"byte_end":886278,"line_start":336,"line_end":336,"column_start":12,"column_end":15},"name":"set","qualname":"<MatrixComplexF32>::set","value":"fn (&mut self, y: usize, x: usize, value: &ComplexF32) -> &MatrixComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function sets the value of the (i,j)-th element of the matrix to value.\n If y or x lies outside the allowed range of 0 to n1-1 and 0 to n2-1 then the error handler is invoked.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4156},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":886559,"byte_end":886566,"line_start":342,"line_end":342,"column_start":12,"column_end":19},"name":"set_all","qualname":"<MatrixComplexF32>::set_all","value":"fn (&mut self, x: &ComplexF32) -> &MatrixComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function sets all the elements of the matrix to the value x.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4157},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":886810,"byte_end":886818,"line_start":348,"line_end":348,"column_start":12,"column_end":20},"name":"set_zero","qualname":"<MatrixComplexF32>::set_zero","value":"fn (&mut self) -> &MatrixComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function sets all the elements of the matrix to zero.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4158},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":887203,"byte_end":887215,"line_start":355,"line_end":355,"column_start":12,"column_end":24},"name":"set_identity","qualname":"<MatrixComplexF32>::set_identity","value":"fn (&mut self) -> &MatrixComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function sets the elements of the matrix to the corresponding elements of the identity matrix, m(i,j) = \\delta(i,j), i.e. a unit diagonal with all off-diagonal elements zero.\n This applies to both square and rectangular matrices.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4159},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":887480,"byte_end":887489,"line_start":361,"line_end":361,"column_start":12,"column_end":21},"name":"copy_from","qualname":"<MatrixComplexF32>::copy_from","value":"fn (&mut self, other: &MatrixComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the other matrix into the self matrix. The two matrices must have the same size.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4160},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":887786,"byte_end":887793,"line_start":366,"line_end":366,"column_start":12,"column_end":19},"name":"copy_to","qualname":"<MatrixComplexF32>::copy_to","value":"fn (&self, other: &mut MatrixComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the self matrix into the other matrix. The two matrices must have the same size.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4161},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":888094,"byte_end":888098,"line_start":371,"line_end":371,"column_start":12,"column_end":16},"name":"swap","qualname":"<MatrixComplexF32>::swap","value":"fn (&mut self, other: &mut MatrixComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function exchanges the elements of the matrices self and other by copying. The two matrices must have the same size.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4162},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":888369,"byte_end":888376,"line_start":376,"line_end":376,"column_start":12,"column_end":19},"name":"get_row","qualname":"<MatrixComplexF32>::get_row","value":"fn (&self, y: usize) -> Option<(VectorComplexF32, enums::Value)>","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the y-th row of the matrix into the returned vector.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4163},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":888872,"byte_end":888879,"line_start":389,"line_end":389,"column_start":12,"column_end":19},"name":"get_col","qualname":"<MatrixComplexF32>::get_col","value":"fn (&self, x: usize) -> Option<(VectorComplexF32, enums::Value)>","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the x-th column of the matrix into the returned vector.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4164},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":889441,"byte_end":889448,"line_start":403,"line_end":403,"column_start":12,"column_end":19},"name":"set_row","qualname":"<MatrixComplexF32>::set_row","value":"fn (&mut self, y: usize, v: &VectorComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the vector v into the y-th row of the matrix.\n The length of the vector must be the same as the length of the row.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4165},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":889839,"byte_end":889846,"line_start":411,"line_end":411,"column_start":12,"column_end":19},"name":"set_col","qualname":"<MatrixComplexF32>::set_col","value":"fn (&mut self, x: usize, v: &VectorComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the vector v into the x-th column of the matrix.\n The length of the vector must be the same as the length of the column.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4166},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":890145,"byte_end":890154,"line_start":418,"line_end":418,"column_start":12,"column_end":21},"name":"swap_rows","qualname":"<MatrixComplexF32>::swap_rows","value":"fn (&self, y1: usize, y2: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function exchanges the y1-th and y2-th rows of the matrix in-place.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4167},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":890401,"byte_end":890413,"line_start":423,"line_end":423,"column_start":12,"column_end":24},"name":"swap_columns","qualname":"<MatrixComplexF32>::swap_columns","value":"fn (&mut self, x1: usize, x2: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function exchanges the x1-th and x2-th columns of the matrix in-place.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4168},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":890729,"byte_end":890741,"line_start":428,"line_end":428,"column_start":12,"column_end":24},"name":"swap_row_col","qualname":"<MatrixComplexF32>::swap_row_col","value":"fn (&mut self, i: usize, j: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function exchanges the i-th row and j-th column of the matrix in-place. The matrix must be square for this operation to be possible.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4169},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":891137,"byte_end":891153,"line_start":434,"line_end":434,"column_start":12,"column_end":28},"name":"transpose_memcpy","qualname":"<MatrixComplexF32>::transpose_memcpy","value":"fn (&self) -> Option<(MatrixComplexF32, enums::Value)>","parent":null,"children":[],"decl_id":null,"docs":" This function returns the transpose of the matrix by copying the elements into it.\n This function works for all matrices provided that the dimensions of the matrix dest match the transposed dimensions of the matrix.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4170},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":891752,"byte_end":891761,"line_start":448,"line_end":448,"column_start":12,"column_end":21},"name":"transpose","qualname":"<MatrixComplexF32>::transpose","value":"fn (&mut self) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function replaces the matrix m by its transpose by copying the elements of the matrix in-place.\n The matrix must be square for this operation to be possible.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4171},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":892144,"byte_end":892147,"line_start":454,"line_end":454,"column_start":12,"column_end":15},"name":"add","qualname":"<MatrixComplexF32>::add","value":"fn (&mut self, other: &MatrixComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function adds the elements of the other matrix to the elements of the self matrix.\n The result self(i,j) <- self(i,j) + other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4172},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":892568,"byte_end":892571,"line_start":460,"line_end":460,"column_start":12,"column_end":15},"name":"sub","qualname":"<MatrixComplexF32>::sub","value":"fn (&mut self, other: &MatrixComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function subtracts the elements of the other matrix from the elements of the self matrix.\n The result self(i,j) <- self(i,j) - other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4173},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":892991,"byte_end":893003,"line_start":466,"line_end":466,"column_start":12,"column_end":24},"name":"mul_elements","qualname":"<MatrixComplexF32>::mul_elements","value":"fn (&mut self, other: &MatrixComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function multiplies the elements of the self matrix by the elements of the other matrix.\n The result self(i,j) <- self(i,j) * other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4174},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":893449,"byte_end":893461,"line_start":474,"line_end":474,"column_start":12,"column_end":24},"name":"div_elements","qualname":"<MatrixComplexF32>::div_elements","value":"fn (&mut self, other: &MatrixComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function divides the elements of the self matrix by the elements of the other matrix.\n The result self(i,j) <- self(i,j) / other(i,j) is stored in self and other remains unchanged. The two matrices must have the same dimensions.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4175},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":893804,"byte_end":893809,"line_start":481,"line_end":481,"column_start":12,"column_end":17},"name":"scale","qualname":"<MatrixComplexF32>::scale","value":"fn (&mut self, x: &ComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function multiplies the elements of the self matrix by the constant factor x. The result self(i,j) <- x self(i,j) is stored in self.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4176},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":894146,"byte_end":894158,"line_start":488,"line_end":488,"column_start":12,"column_end":24},"name":"add_constant","qualname":"<MatrixComplexF32>::add_constant","value":"fn (&mut self, x: &ComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function adds the constant value x to the elements of the self matrix. The result self(i,j) <- self(i,j) + x is stored in self.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4177},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":894453,"byte_end":894460,"line_start":495,"line_end":495,"column_start":12,"column_end":19},"name":"is_null","qualname":"<MatrixComplexF32>::is_null","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all the elements of the self matrix are stricly zero.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4178},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":894722,"byte_end":894728,"line_start":503,"line_end":503,"column_start":12,"column_end":18},"name":"is_pos","qualname":"<MatrixComplexF32>::is_pos","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all the elements of the self matrix are stricly positive.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4179},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":894989,"byte_end":894995,"line_start":511,"line_end":511,"column_start":12,"column_end":18},"name":"is_neg","qualname":"<MatrixComplexF32>::is_neg","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all the elements of the self matrix are stricly negative.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4180},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":895260,"byte_end":895270,"line_start":519,"line_end":519,"column_start":12,"column_end":22},"name":"is_non_neg","qualname":"<MatrixComplexF32>::is_non_neg","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all the elements of the self matrix are stricly non-negative.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4181},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":895518,"byte_end":895523,"line_start":527,"line_end":527,"column_start":12,"column_end":17},"name":"equal","qualname":"<MatrixComplexF32>::equal","value":"fn (&self, other: &MatrixComplexF32) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all elements of the two matrix are equal.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4182},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":895737,"byte_end":895742,"line_start":535,"line_end":535,"column_start":12,"column_end":17},"name":"clone","qualname":"<MatrixComplexF32>::clone","value":"fn (&self) -> Option<MatrixComplexF32>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":4192},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/minimizer.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"minimizer","qualname":"::types::minimizer","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/minimizer.rs","parent":null,"children":[{"krate":0,"index":4193},{"krate":0,"index":4194},{"krate":0,"index":4198},{"krate":0,"index":4199},{"krate":0,"index":4200},{"krate":0,"index":4201},{"krate":0,"index":4203},{"krate":0,"index":4205},{"krate":0,"index":4217},{"krate":0,"index":4230},{"krate":0,"index":4233},{"krate":0,"index":4239},{"krate":0,"index":4244},{"krate":0,"index":4247},{"krate":0,"index":4249},{"krate":0,"index":4251},{"krate":0,"index":4253},{"krate":0,"index":4260},{"krate":0,"index":4262},{"krate":0,"index":4264},{"krate":0,"index":4273},{"krate":0,"index":4275}],"decl_id":null,"docs":"#One dimensional Minimization","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4205},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/minimizer.rs","byte_start":903386,"byte_end":903395,"line_start":107,"line_end":107,"column_start":12,"column_end":21},"name":"Minimizer","qualname":"::types::minimizer::Minimizer","value":"Minimizer {  }","parent":null,"children":[{"krate":0,"index":4207},{"krate":0,"index":4208},{"krate":0,"index":4209},{"krate":0,"index":4210},{"krate":0,"index":4211},{"krate":0,"index":4212},{"krate":0,"index":4213},{"krate":0,"index":4214},{"krate":0,"index":4215},{"krate":0,"index":4216}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4219},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/minimizer.rs","byte_start":904235,"byte_end":904238,"line_start":133,"line_end":133,"column_start":12,"column_end":15},"name":"new","qualname":"<Minimizer<T>>::new","value":"fn (t: &MinimizerType<T>) -> Option<Minimizer<T>>","parent":null,"children":[],"decl_id":null,"docs":" This function returns a pointer to a newly allocated instance of a minimizer of type T. For example, the following code creates an\n instance of a golden section minimizer,","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4220},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/minimizer.rs","byte_start":905110,"byte_end":905113,"line_start":158,"line_end":158,"column_start":12,"column_end":15},"name":"set","qualname":"<Minimizer<T>>::set","value":"fn (&mut self, f: ::function<T>, arg: &mut T, x_minimum: f64, x_lower: f64, x_upper: f64) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":" This function sets, or resets, an existing minimizer s to use the function f and the initial search interval [x_lower, x_upper], with\n a guess for the location of the minimum x_minimum.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4221},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/minimizer.rs","byte_start":905886,"byte_end":905901,"line_start":175,"line_end":175,"column_start":12,"column_end":27},"name":"set_with_values","qualname":"<Minimizer<T>>::set_with_values","value":"fn (&mut self, f: ::function<T>, arg: &mut T, x_minimum: f64, f_minimum: f64, x_lower: f64, f_lower: f64, x_upper: f64, f_upper: f64) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":" This function is equivalent to gsl_min_fminimizer_set but uses the values f_minimum, f_lower and f_upper instead of computing\n f(x_minimum), f(x_lower) and f(x_upper).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4222},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/minimizer.rs","byte_start":907320,"byte_end":907324,"line_start":213,"line_end":213,"column_start":12,"column_end":16},"name":"name","qualname":"<Minimizer<T>>::name","value":"fn (&self) -> String","parent":null,"children":[],"decl_id":null,"docs":" This function returns a pointer to the name of the minimizer. For example,","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4223},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/minimizer.rs","byte_start":907497,"byte_end":907506,"line_start":218,"line_end":218,"column_start":12,"column_end":21},"name":"x_minimum","qualname":"<Minimizer<T>>::x_minimum","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the current estimate of the position of the minimum for the minimizer s.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4224},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/minimizer.rs","byte_start":907665,"byte_end":907672,"line_start":223,"line_end":223,"column_start":12,"column_end":19},"name":"x_lower","qualname":"<Minimizer<T>>::x_lower","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the current upper and lower bound of the interval for the minimizer s.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4225},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/minimizer.rs","byte_start":907833,"byte_end":907840,"line_start":228,"line_end":228,"column_start":12,"column_end":19},"name":"x_upper","qualname":"<Minimizer<T>>::x_upper","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" /// This function returns the current upper and lower bound of the interval for the minimizer s.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4226},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/minimizer.rs","byte_start":908070,"byte_end":908079,"line_start":234,"line_end":234,"column_start":12,"column_end":21},"name":"f_minimum","qualname":"<Minimizer<T>>::f_minimum","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the value of the function at the current estimate of the minimum and at the upper and lower bounds of the\n interval for the minimizer s.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4227},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/minimizer.rs","byte_start":908311,"byte_end":908318,"line_start":240,"line_end":240,"column_start":12,"column_end":19},"name":"f_lower","qualname":"<Minimizer<T>>::f_lower","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the value of the function at the current estimate of the minimum and at the upper and lower bounds of the\n interval for the minimizer s.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4228},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/minimizer.rs","byte_start":908548,"byte_end":908555,"line_start":246,"line_end":246,"column_start":12,"column_end":19},"name":"f_upper","qualname":"<Minimizer<T>>::f_upper","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the value of the function at the current estimate of the minimum and at the upper and lower bounds of the\n interval for the minimizer s.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4229},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/minimizer.rs","byte_start":909267,"byte_end":909274,"line_start":261,"line_end":261,"column_start":12,"column_end":19},"name":"iterate","qualname":"<Minimizer<T>>::iterate","value":"fn (&mut self) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":" This function performs a single iteration of the minimizer s. If the iteration encounters an unexpected problem then an error code\n will be returned,","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4233},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/minimizer.rs","byte_start":909754,"byte_end":909767,"line_start":276,"line_end":276,"column_start":12,"column_end":25},"name":"MinimizerType","qualname":"::types::minimizer::MinimizerType","value":"MinimizerType { name }","parent":null,"children":[{"krate":0,"index":4235},{"krate":0,"index":4236},{"krate":0,"index":4237},{"krate":0,"index":4238}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":4235},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/minimizer.rs","byte_start":909781,"byte_end":909785,"line_start":277,"line_end":277,"column_start":9,"column_end":13},"name":"name","qualname":"::types::minimizer::MinimizerType::name","value":"std::string::String","parent":{"krate":0,"index":4233},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4241},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/minimizer.rs","byte_start":911107,"byte_end":911121,"line_start":294,"line_end":294,"column_start":12,"column_end":26},"name":"golden_section","qualname":"<MinimizerType<T>>::golden_section","value":"fn () -> MinimizerType<T>","parent":null,"children":[],"decl_id":null,"docs":" The golden section algorithm is the simplest method of bracketing the minimum of a function. It is the slowest algorithm provided\n by the library, with linear convergence.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4242},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/minimizer.rs","byte_start":912206,"byte_end":912211,"line_start":311,"line_end":311,"column_start":12,"column_end":17},"name":"brent","qualname":"<MinimizerType<T>>::brent","value":"fn () -> MinimizerType<T>","parent":null,"children":[],"decl_id":null,"docs":" The Brent minimization algorithm combines a parabolic interpolation with the golden section algorithm. This produces a fast algorithm\n which is still robust.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4243},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/minimizer.rs","byte_start":912576,"byte_end":912587,"line_start":321,"line_end":321,"column_start":12,"column_end":23},"name":"quad_golden","qualname":"<MinimizerType<T>>::quad_golden","value":"fn () -> MinimizerType<T>","parent":null,"children":[],"decl_id":null,"docs":" This is a variant of Brent’s algorithm which uses the safeguarded step-length algorithm of Gill and Murray.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":4277},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"monte_carlo","qualname":"::types::monte_carlo","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","parent":null,"children":[{"krate":0,"index":4278},{"krate":0,"index":4279},{"krate":0,"index":4283},{"krate":0,"index":4284},{"krate":0,"index":4285},{"krate":0,"index":4286},{"krate":0,"index":4288},{"krate":0,"index":4293},{"krate":0,"index":4295},{"krate":0,"index":4300},{"krate":0,"index":4302},{"krate":0,"index":4309},{"krate":0,"index":4311},{"krate":0,"index":4316},{"krate":0,"index":4322},{"krate":0,"index":4324},{"krate":0,"index":4333},{"krate":0,"index":4337},{"krate":0,"index":4340},{"krate":0,"index":7025},{"krate":0,"index":7035},{"krate":0,"index":7034},{"krate":0,"index":4343},{"krate":0,"index":4346},{"krate":0,"index":4348},{"krate":0,"index":4353}],"decl_id":null,"docs":"#Monte Carlo Integration","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4286},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":932163,"byte_end":932178,"line_start":93,"line_end":93,"column_start":12,"column_end":27},"name":"PlainMonteCarlo","qualname":"::types::monte_carlo::PlainMonteCarlo","value":"PlainMonteCarlo {  }","parent":null,"children":[{"krate":0,"index":4287}],"decl_id":null,"docs":" The plain Monte Carlo algorithm samples points randomly from the integration region to estimate the integral and its error. Using this algorithm\n the estimate of the integral E(f; N) for N randomly distributed points x_i is given by,","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4289},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":932365,"byte_end":932368,"line_start":99,"line_end":99,"column_start":12,"column_end":15},"name":"new","qualname":"<PlainMonteCarlo>::new","value":"fn (dim: usize) -> Option<PlainMonteCarlo>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates and initializes a workspace for Monte Carlo integration in dim dimensions.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4290},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":932766,"byte_end":932770,"line_start":111,"line_end":111,"column_start":12,"column_end":16},"name":"init","qualname":"<PlainMonteCarlo>::init","value":"fn (&mut self) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":" This function initializes a previously allocated integration state. This allows an existing workspace to be reused for different\n integrations.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4291},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":933698,"byte_end":933707,"line_start":125,"line_end":125,"column_start":12,"column_end":21},"name":"integrate","qualname":"<PlainMonteCarlo>::integrate","value":"fn <F> (&mut self, dim: usize, f: F, xl: &[f64], xu: &[f64], t_calls: usize, r: &mut ::Rng) -> Result<(f64, f64), ::Value>","parent":null,"children":[],"decl_id":null,"docs":" This routines uses the plain Monte Carlo algorithm to integrate the function f over the dim-dimensional hypercubic region defined\n by the lower and upper limits in the arrays xl and xu, each of the same size. The integration uses a fixed number of function calls\n calls, and obtains random sampling points using the random number generator r. A previously allocated workspace s must be supplied.\n The result of the integration is returned in result, with an estimated absolute error abserr.","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4300},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":937907,"byte_end":937922,"line_start":211,"line_end":211,"column_start":12,"column_end":27},"name":"MiserMonteCarlo","qualname":"::types::monte_carlo::MiserMonteCarlo","value":"MiserMonteCarlo {  }","parent":null,"children":[{"krate":0,"index":4301}],"decl_id":null,"docs":" The MISER algorithm of Press and Farrar is based on recursive stratified sampling. This technique aims to reduce the overall integration error\n by concentrating integration points in the regions of highest variance.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4303},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":938181,"byte_end":938184,"line_start":218,"line_end":218,"column_start":12,"column_end":15},"name":"new","qualname":"<MiserMonteCarlo>::new","value":"fn (dim: usize) -> Option<MiserMonteCarlo>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates and initializes a workspace for Monte Carlo integration in dim dimensions. The workspace is used to maintain\n the state of the integration.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4304},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":938598,"byte_end":938602,"line_start":229,"line_end":229,"column_start":12,"column_end":16},"name":"init","qualname":"<MiserMonteCarlo>::init","value":"fn (&mut self) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":" This function initializes a previously allocated integration state. This allows an existing workspace to be reused for different integrations.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4305},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":939525,"byte_end":939534,"line_start":243,"line_end":243,"column_start":12,"column_end":21},"name":"integrate","qualname":"<MiserMonteCarlo>::integrate","value":"fn <F> (&mut self, dim: usize, f: F, xl: &[f64], xu: &[f64], t_calls: usize, r: &mut ::Rng) -> Result<(f64, f64), ::Value>","parent":null,"children":[],"decl_id":null,"docs":" This routines uses the MISER Monte Carlo algorithm to integrate the function f over the dim-dimensional hypercubic region defined by\n the lower and upper limits in the arrays xl and xu, each of size dim. The integration uses a fixed number of function calls calls,\n and obtains random sampling points using the random number generator r. A previously allocated workspace s must be supplied. The result\n of the integration is returned in result, with an estimated absolute error abserr.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4307},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":941326,"byte_end":941336,"line_start":281,"line_end":281,"column_start":12,"column_end":22},"name":"get_params","qualname":"<MiserMonteCarlo>::get_params","value":"fn (&self) -> MiserParams","parent":null,"children":[],"decl_id":null,"docs":" This function copies the parameters of the integrator state into the user-supplied params structure.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4308},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":941796,"byte_end":941806,"line_start":297,"line_end":297,"column_start":12,"column_end":22},"name":"set_params","qualname":"<MiserMonteCarlo>::set_params","value":"fn (&mut self, params: &MiserParams) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function sets the integrator parameters based on values provided in the params structure.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4316},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":942636,"byte_end":942647,"line_start":330,"line_end":330,"column_start":12,"column_end":23},"name":"MiserParams","qualname":"::types::monte_carlo::MiserParams","value":"MiserParams { estimate_frac, min_calls, min_calls_per_bisection, alpha, dither }","parent":null,"children":[{"krate":0,"index":4317},{"krate":0,"index":4318},{"krate":0,"index":4319},{"krate":0,"index":4320},{"krate":0,"index":4321}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"repr(C)","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":942614,"byte_end":942624,"line_start":329,"line_end":329,"column_start":1,"column_end":11}}]},{"kind":"Field","id":{"krate":0,"index":4317},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":942861,"byte_end":942874,"line_start":333,"line_end":333,"column_start":9,"column_end":22},"name":"estimate_frac","qualname":"::types::monte_carlo::MiserParams::estimate_frac","value":"f64","parent":{"krate":0,"index":4316},"children":[],"decl_id":null,"docs":" This parameter specifies the fraction of the currently available number of function calls which\n are allocated to estimating the variance at each recursive step. The default value is 0.1.\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":4318},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":943278,"byte_end":943287,"line_start":338,"line_end":338,"column_start":9,"column_end":18},"name":"min_calls","qualname":"::types::monte_carlo::MiserParams::min_calls","value":"usize","parent":{"krate":0,"index":4316},"children":[],"decl_id":null,"docs":" This parameter specifies the minimum number of function calls required for each estimate of the\n variance. If the number of function calls allocated to the estimate using estimate_frac falls\n below min_calls then min_calls are used instead. This ensures that each estimate maintains a\n reasonable level of accuracy. The default value of min_calls is 16 * dim.\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":4319},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":943684,"byte_end":943707,"line_start":343,"line_end":343,"column_start":9,"column_end":32},"name":"min_calls_per_bisection","qualname":"::types::monte_carlo::MiserParams::min_calls_per_bisection","value":"usize","parent":{"krate":0,"index":4316},"children":[],"decl_id":null,"docs":" This parameter specifies the minimum number of function calls required to proceed with a bisection\n step. When a recursive step has fewer calls available than min_calls_per_bisection it performs\n a plain Monte Carlo estimate of the current sub-region and terminates its branch of the recursion.\n The default value of this parameter is 32 * min_calls.\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":4320},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":944507,"byte_end":944512,"line_start":354,"line_end":354,"column_start":9,"column_end":14},"name":"alpha","qualname":"::types::monte_carlo::MiserParams::alpha","value":"f64","parent":{"krate":0,"index":4316},"children":[],"decl_id":null,"docs":" This parameter controls how the estimated variances for the two sub-regions of a bisection are\n combined when allocating points. With recursive sampling the overall variance should scale better\n than 1/N, since the values from the sub-regions will be obtained using a procedure which explicitly\n minimizes their variance. To accommodate this behavior the MISER algorithm allows the total variance\n to depend on a scaling parameter \\alpha,","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":4321},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":944901,"byte_end":944907,"line_start":359,"line_end":359,"column_start":9,"column_end":15},"name":"dither","qualname":"::types::monte_carlo::MiserParams::dither","value":"f64","parent":{"krate":0,"index":4316},"children":[],"decl_id":null,"docs":" This parameter introduces a random fractional variation of size dither into each bisection, which\n can be used to break the symmetry of integrands which are concentrated near the exact center of\n the hypercubic integration region. The default value of dither is zero, so no variation is introduced.\n If needed, a typical value of dither is 0.1.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4322},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":948659,"byte_end":948674,"line_start":415,"line_end":415,"column_start":12,"column_end":27},"name":"VegasMonteCarlo","qualname":"::types::monte_carlo::VegasMonteCarlo","value":"VegasMonteCarlo {  }","parent":null,"children":[{"krate":0,"index":4323}],"decl_id":null,"docs":" The VEGAS algorithm of Lepage is based on importance sampling. It samples points from the probability\n distribution described by the function |f|, so that the points are concentrated in the regions that\n make the largest contribution to the integral.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4325},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":948933,"byte_end":948936,"line_start":422,"line_end":422,"column_start":12,"column_end":15},"name":"new","qualname":"<VegasMonteCarlo>::new","value":"fn (dim: usize) -> Option<VegasMonteCarlo>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates and initializes a workspace for Monte Carlo integration in dim dimensions.\n The workspace is used to maintain the state of the integration.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4326},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":949358,"byte_end":949362,"line_start":434,"line_end":434,"column_start":12,"column_end":16},"name":"init","qualname":"<VegasMonteCarlo>::init","value":"fn (&mut self) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":" This function initializes a previously allocated integration state. This allows an existing workspace\n to be reused for different integrations.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4327},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":950595,"byte_end":950604,"line_start":452,"line_end":452,"column_start":12,"column_end":21},"name":"integrate","qualname":"<VegasMonteCarlo>::integrate","value":"fn <F> (&mut self, dim: usize, f: F, xl: &[f64], xu: &[f64], t_calls: usize, r: &mut ::Rng) -> Result<(f64, f64), ::Value>","parent":null,"children":[],"decl_id":null,"docs":" This routines uses the VEGAS Monte Carlo algorithm to integrate the function f over the dim-dimensional\n hypercubic region defined by the lower and upper limits in the arrays xl and xu, each of size dim.\n The integration uses a fixed number of function calls calls, and obtains random sampling points using\n the random number generator r. A previously allocated workspace s must be supplied. The result of the\n integration is returned in result, with an estimated absolute error abserr. The result and its error\n estimate are based on a weighted average of independent samples. The chi-squared per degree of freedom\n for the weighted average is returned via the state struct component, s->chisq, and must be consistent\n with 1 for the weighted average to be reliable.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4329},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":952712,"byte_end":952717,"line_start":493,"line_end":493,"column_start":12,"column_end":17},"name":"chisq","qualname":"<VegasMonteCarlo>::chisq","value":"fn (&mut self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the chi-squared per degree of freedom for the weighted estimate of the integral.\n The returned value should be close to 1. A value which differs significantly from 1 indicates that\n the values from different iterations are inconsistent. In this case the weighted error will be\n under-estimated, and further iterations of the algorithm are needed to obtain reliable results.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4330},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":952968,"byte_end":952974,"line_start":499,"line_end":499,"column_start":12,"column_end":18},"name":"runval","qualname":"<VegasMonteCarlo>::runval","value":"fn (&mut self, result: &mut f64, sigma: &mut f64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function returns the raw (unaveraged) values of the integral result and its error sigma from\n the most recent iteration of the algorithm.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4331},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":953165,"byte_end":953175,"line_start":505,"line_end":505,"column_start":12,"column_end":22},"name":"get_params","qualname":"<VegasMonteCarlo>::get_params","value":"fn (&self) -> VegasParams","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4332},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":953391,"byte_end":953401,"line_start":513,"line_end":513,"column_start":12,"column_end":22},"name":"set_params","qualname":"<VegasMonteCarlo>::set_params","value":"fn (&mut self, params: &VegasParams) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4333},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":953564,"byte_end":953575,"line_start":520,"line_end":520,"column_start":12,"column_end":23},"name":"VegasParams","qualname":"::types::monte_carlo::VegasParams","value":"VegasParams {  }","parent":null,"children":[{"krate":0,"index":4335},{"krate":0,"index":4336}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4339},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":955386,"byte_end":955389,"line_start":550,"line_end":550,"column_start":12,"column_end":15},"name":"new","qualname":"<VegasParams>::new","value":"fn (alpha: f64, iterations: usize, stage: i32, mode: ::VegasMode, verbosity: VegasVerbosity, stream: Option<&'a mut ::IOStream>) -> Result<VegasParams, String>","parent":null,"children":[],"decl_id":null,"docs":" alpha: The parameter alpha controls the stiffness of the rebinning algorithm. It is typically\n set between one and two. A value of zero prevents rebinning of the grid. The default\n value is 1.5.","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":7026},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":957608,"byte_end":957611,"line_start":611,"line_end":611,"column_start":5,"column_end":8},"name":"Off","qualname":"::types::monte_carlo::VegasVerbosity::Off","value":"VegasVerbosity::Off","parent":{"krate":0,"index":7025},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":7028},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":957623,"byte_end":957630,"line_start":612,"line_end":612,"column_start":5,"column_end":12},"name":"Summary","qualname":"::types::monte_carlo::VegasVerbosity::Summary","value":"VegasVerbosity::Summary","parent":{"krate":0,"index":7025},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":7030},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":957641,"byte_end":957645,"line_start":613,"line_end":613,"column_start":5,"column_end":9},"name":"Grid","qualname":"::types::monte_carlo::VegasVerbosity::Grid","value":"VegasVerbosity::Grid","parent":{"krate":0,"index":7025},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":7032},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":957656,"byte_end":957665,"line_start":614,"line_end":614,"column_start":5,"column_end":14},"name":"Rebinning","qualname":"::types::monte_carlo::VegasVerbosity::Rebinning","value":"VegasVerbosity::Rebinning","parent":{"krate":0,"index":7025},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":7025},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":957587,"byte_end":957601,"line_start":610,"line_end":610,"column_start":10,"column_end":24},"name":"VegasVerbosity","qualname":"::types::monte_carlo::VegasVerbosity","value":"VegasVerbosity::{Off, Summary, Grid, Rebinning}","parent":null,"children":[{"krate":0,"index":7026},{"krate":0,"index":7028},{"krate":0,"index":7030},{"krate":0,"index":7032}],"decl_id":null,"docs":" The default setting of verbose is `Off`, which turns off all output.\n A verbose value of `Summary` prints summary information about the weighted average\n and final result, while a value of `Grid` also displays the grid coordinates.\n A value of 'Rebinning' prints information from the rebinning procedure for each iteration.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":4354},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"multifit_solver","qualname":"::types::multifit_solver","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","parent":null,"children":[{"krate":0,"index":4355},{"krate":0,"index":4356},{"krate":0,"index":4357},{"krate":0,"index":4358},{"krate":0,"index":4360},{"krate":0,"index":4365},{"krate":0,"index":4367},{"krate":0,"index":4373},{"krate":0,"index":4375},{"krate":0,"index":4380},{"krate":0,"index":4385},{"krate":0,"index":4387},{"krate":0,"index":4398},{"krate":0,"index":4400},{"krate":0,"index":4402},{"krate":0,"index":4405},{"krate":0,"index":4412},{"krate":0,"index":4415},{"krate":0,"index":4416},{"krate":0,"index":4417}],"decl_id":null,"docs":"#Nonlinear Least-Squares Fitting","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4358},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":970773,"byte_end":970792,"line_start":220,"line_end":220,"column_start":12,"column_end":31},"name":"MultiFitFSolverType","qualname":"::types::multifit_solver::MultiFitFSolverType","value":"MultiFitFSolverType {  }","parent":null,"children":[{"krate":0,"index":4359}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4365},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":971410,"byte_end":971425,"line_start":244,"line_end":244,"column_start":12,"column_end":27},"name":"MultiFitFSolver","qualname":"::types::multifit_solver::MultiFitFSolver","value":"MultiFitFSolver {  }","parent":null,"children":[{"krate":0,"index":4366}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4368},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":971917,"byte_end":971920,"line_start":255,"line_end":255,"column_start":12,"column_end":15},"name":"new","qualname":"<MultiFitFSolver>::new","value":"fn (t: &MultiFitFSolverType, n: usize, p: usize) -> Option<MultiFitFSolver>","parent":null,"children":[],"decl_id":null,"docs":" This function returns a pointer to a newly allocated instance of a solver of type T for n\n observations and p parameters. The number of observations n must be greater than or equal to\n parameters p.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4369},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":972255,"byte_end":972258,"line_start":267,"line_end":267,"column_start":12,"column_end":15},"name":"set","qualname":"<MultiFitFSolver>::set","value":"fn (&mut self, f: &mut MultiFitFunction, x: &mut VectorF64) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4370},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":972469,"byte_end":972476,"line_start":273,"line_end":273,"column_start":12,"column_end":19},"name":"iterate","qualname":"<MultiFitFSolver>::iterate","value":"fn (&mut self) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4371},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":972595,"byte_end":972599,"line_start":277,"line_end":277,"column_start":12,"column_end":16},"name":"name","qualname":"<MultiFitFSolver>::name","value":"fn (&self) -> String","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4372},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":972819,"byte_end":972827,"line_start":285,"line_end":285,"column_start":12,"column_end":20},"name":"position","qualname":"<MultiFitFSolver>::position","value":"fn (&self) -> VectorF64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4380},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":973632,"byte_end":973648,"line_start":318,"line_end":318,"column_start":12,"column_end":28},"name":"MultiFitFunction","qualname":"::types::multifit_solver::MultiFitFunction","value":"MultiFitFunction { f, n, p, params }","parent":null,"children":[{"krate":0,"index":4381},{"krate":0,"index":4382},{"krate":0,"index":4383},{"krate":0,"index":4384}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"repr(C)","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":973610,"byte_end":973620,"line_start":317,"line_end":317,"column_start":1,"column_end":11}}]},{"kind":"Field","id":{"krate":0,"index":4381},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":973659,"byte_end":973660,"line_start":319,"line_end":319,"column_start":9,"column_end":10},"name":"f","qualname":"::types::multifit_solver::MultiFitFunction::f","value":"std::option::Option<extern \"C\" fn(*const ffi::linalg::gsl_vector, *mut libc::c_void, *mut ffi::linalg::gsl_vector) -> enums::Value>","parent":{"krate":0,"index":4380},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":4382},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":973837,"byte_end":973838,"line_start":322,"line_end":322,"column_start":9,"column_end":10},"name":"n","qualname":"::types::multifit_solver::MultiFitFunction::n","value":"usize","parent":{"krate":0,"index":4380},"children":[],"decl_id":null,"docs":" number of functions\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":4383},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":973895,"byte_end":973896,"line_start":324,"line_end":324,"column_start":9,"column_end":10},"name":"p","qualname":"::types::multifit_solver::MultiFitFunction::p","value":"usize","parent":{"krate":0,"index":4380},"children":[],"decl_id":null,"docs":" number of independent variables\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":4384},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":973913,"byte_end":973919,"line_start":325,"line_end":325,"column_start":9,"column_end":15},"name":"params","qualname":"::types::multifit_solver::MultiFitFunction::params","value":"*mut libc::c_void","parent":{"krate":0,"index":4380},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4385},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":973948,"byte_end":973965,"line_start":328,"line_end":328,"column_start":12,"column_end":29},"name":"MultiFitFdfSolver","qualname":"::types::multifit_solver::MultiFitFdfSolver","value":"MultiFitFdfSolver {  }","parent":null,"children":[{"krate":0,"index":4386}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4388},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":974274,"byte_end":974277,"line_start":336,"line_end":336,"column_start":12,"column_end":15},"name":"new","qualname":"<MultiFitFdfSolver>::new","value":"fn (_type: &MultiFitFdfSolverType, n: usize, p: usize) -> Option<MultiFitFdfSolver>","parent":null,"children":[],"decl_id":null,"docs":" This function returns a pointer to a newly allocated instance of a solver of type T for n\n observations and p parameters. The number of observations n must be greater than or equal\n to parameters p.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4389},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":974817,"byte_end":974820,"line_start":352,"line_end":352,"column_start":12,"column_end":15},"name":"set","qualname":"<MultiFitFdfSolver>::set","value":"fn (&mut self, f: &mut MultiFitFunctionFdf, x: &::VectorF64) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":" This function initializes, or reinitializes, an existing solver s to use the function f and\n the initial guess x.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4390},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":975048,"byte_end":975049,"line_start":358,"line_end":358,"column_start":12,"column_end":13},"name":"x","qualname":"<MultiFitFdfSolver>::x","value":"fn (&self) -> ::VectorF64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4391},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":975149,"byte_end":975150,"line_start":362,"line_end":362,"column_start":12,"column_end":13},"name":"f","qualname":"<MultiFitFdfSolver>::f","value":"fn (&self) -> ::VectorF64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4392},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":975250,"byte_end":975251,"line_start":366,"line_end":366,"column_start":12,"column_end":13},"name":"J","qualname":"<MultiFitFdfSolver>::J","value":"fn (&self) -> ::MatrixF64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4393},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":975351,"byte_end":975353,"line_start":370,"line_end":370,"column_start":12,"column_end":14},"name":"dx","qualname":"<MultiFitFdfSolver>::dx","value":"fn (&self) -> ::VectorF64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4394},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":975454,"byte_end":975458,"line_start":374,"line_end":374,"column_start":12,"column_end":16},"name":"name","qualname":"<MultiFitFdfSolver>::name","value":"fn (&self) -> String","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4395},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":975936,"byte_end":975943,"line_start":385,"line_end":385,"column_start":12,"column_end":19},"name":"iterate","qualname":"<MultiFitFdfSolver>::iterate","value":"fn (&mut self) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":" This function performs a single iteration of the solver s. If the iteration encounters an\n unexpected problem then an error code will be returned. The solver maintains a current\n estimate of the best-fit parameters at all times.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4396},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":976169,"byte_end":976177,"line_start":390,"line_end":390,"column_start":12,"column_end":20},"name":"position","qualname":"<MultiFitFdfSolver>::position","value":"fn (&self) -> ::VectorF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the current position (i.e. best-fit parameters) s->x of the solver s.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4397},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":976570,"byte_end":976576,"line_start":398,"line_end":398,"column_start":12,"column_end":18},"name":"driver","qualname":"<MultiFitFdfSolver>::driver","value":"fn (&mut self, max_iter: usize, epsabs: f64, epsrel: f64) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":" These functions iterate the solver s for a maximum of maxiter iterations. After each\n iteration, the system is tested for convergence using gsl_multifit_test_delta with the\n error tolerances epsabs and epsrel.\n","sig":null,"attributes":[{"value":"allow(unused_assignments)","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":976530,"byte_end":976558,"line_start":397,"line_end":397,"column_start":5,"column_end":33}}]},{"kind":"Struct","id":{"krate":0,"index":4400},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":977775,"byte_end":977796,"line_start":436,"line_end":436,"column_start":12,"column_end":33},"name":"MultiFitFdfSolverType","qualname":"::types::multifit_solver::MultiFitFdfSolverType","value":"MultiFitFdfSolverType {  }","parent":null,"children":[{"krate":0,"index":4401}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"allow(dead_code)","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":977744,"byte_end":977763,"line_start":435,"line_end":435,"column_start":1,"column_end":20}}]},{"kind":"Method","id":{"krate":0,"index":4403},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":977893,"byte_end":977898,"line_start":441,"line_end":441,"column_start":12,"column_end":17},"name":"lmder","qualname":"<MultiFitFdfSolverType>::lmder","value":"fn () -> MultiFitFdfSolverType","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4404},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":978054,"byte_end":978060,"line_start":447,"line_end":447,"column_start":12,"column_end":18},"name":"lmsder","qualname":"<MultiFitFdfSolverType>::lmsder","value":"fn () -> MultiFitFdfSolverType","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4405},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":978219,"byte_end":978238,"line_start":454,"line_end":454,"column_start":12,"column_end":31},"name":"MultiFitFunctionFdf","qualname":"::types::multifit_solver::MultiFitFunctionFdf","value":"MultiFitFunctionFdf { f, df, fdf, n, p }","parent":null,"children":[{"krate":0,"index":4406},{"krate":0,"index":4407},{"krate":0,"index":4408},{"krate":0,"index":4409},{"krate":0,"index":4410},{"krate":0,"index":4411}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":4406},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":978249,"byte_end":978250,"line_start":455,"line_end":455,"column_start":9,"column_end":10},"name":"f","qualname":"::types::multifit_solver::MultiFitFunctionFdf::f","value":"std::option::Option<std::boxed::Box<(dyn std::ops::Fn(types::vector::VectorF64, types::vector::VectorF64) -> enums::Value + 'static)>>","parent":{"krate":0,"index":4405},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":4407},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":978314,"byte_end":978316,"line_start":456,"line_end":456,"column_start":9,"column_end":11},"name":"df","qualname":"::types::multifit_solver::MultiFitFunctionFdf::df","value":"std::option::Option<std::boxed::Box<(dyn std::ops::Fn(types::vector::VectorF64, types::matrix::MatrixF64) -> enums::Value + 'static)>>","parent":{"krate":0,"index":4405},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":4408},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":978380,"byte_end":978383,"line_start":457,"line_end":457,"column_start":9,"column_end":12},"name":"fdf","qualname":"::types::multifit_solver::MultiFitFunctionFdf::fdf","value":"std::option::Option<std::boxed::Box<(dyn std::ops::Fn(types::vector::VectorF64, types::vector::VectorF64, types::matrix::MatrixF64) -> enums::Value + 'static)>>","parent":{"krate":0,"index":4405},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":4409},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":978460,"byte_end":978461,"line_start":458,"line_end":458,"column_start":9,"column_end":10},"name":"n","qualname":"::types::multifit_solver::MultiFitFunctionFdf::n","value":"usize","parent":{"krate":0,"index":4405},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":4410},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":978478,"byte_end":978479,"line_start":459,"line_end":459,"column_start":9,"column_end":10},"name":"p","qualname":"::types::multifit_solver::MultiFitFunctionFdf::p","value":"usize","parent":{"krate":0,"index":4405},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4413},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":978573,"byte_end":978576,"line_start":464,"line_end":464,"column_start":12,"column_end":15},"name":"new","qualname":"<MultiFitFunctionFdf>::new","value":"fn (n: usize, p: usize) -> MultiFitFunctionFdf","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":4418},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multiset.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"multiset","qualname":"::types::multiset","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multiset.rs","parent":null,"children":[{"krate":0,"index":4419},{"krate":0,"index":4420},{"krate":0,"index":4421},{"krate":0,"index":4422},{"krate":0,"index":4423},{"krate":0,"index":4424},{"krate":0,"index":4427},{"krate":0,"index":4442},{"krate":0,"index":4444}],"decl_id":null,"docs":"#Multisets","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4424},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multiset.rs","byte_start":981186,"byte_end":981194,"line_start":20,"line_end":20,"column_start":12,"column_end":20},"name":"MultiSet","qualname":"::types::multiset::MultiSet","value":"MultiSet {  }","parent":null,"children":[{"krate":0,"index":4425},{"krate":0,"index":4426}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4428},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multiset.rs","byte_start":981671,"byte_end":981674,"line_start":29,"line_end":29,"column_start":12,"column_end":15},"name":"new","qualname":"<MultiSet>::new","value":"fn (n: usize, k: usize) -> Option<MultiSet>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates memory for a new multiset with parameters n, k. The multiset is not initialized and its elements are \n undefined. Use the function gsl_multiset_calloc if you want to create a multiset which is initialized to the lexicographically \n first multiset element. A null pointer is returned if insufficient memory is available to create the multiset.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4429},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multiset.rs","byte_start":982613,"byte_end":982621,"line_start":54,"line_end":54,"column_start":12,"column_end":20},"name":"new_init","qualname":"<MultiSet>::new_init","value":"fn (n: usize, k: usize) -> Option<MultiSet>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates memory for a new multiset with parameters n, k and initializes it to the lexicographically first multiset\n element. A null pointer is returned if insufficient memory is available to create the multiset.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4430},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multiset.rs","byte_start":983442,"byte_end":983452,"line_start":78,"line_end":78,"column_start":12,"column_end":22},"name":"init_first","qualname":"<MultiSet>::init_first","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function initializes the multiset c to the lexicographically first multiset element, i.e. 0 repeated k times.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4431},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multiset.rs","byte_start":983664,"byte_end":983673,"line_start":83,"line_end":83,"column_start":12,"column_end":21},"name":"init_last","qualname":"<MultiSet>::init_last","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function initializes the multiset c to the lexicographically last multiset element, i.e. n-1 repeated k times.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4432},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multiset.rs","byte_start":983890,"byte_end":983894,"line_start":88,"line_end":88,"column_start":12,"column_end":16},"name":"copy","qualname":"<MultiSet>::copy","value":"fn (&self, dest: &mut MultiSet) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the multiset self into the multiset dest. The two multisets must have the same size.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4433},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multiset.rs","byte_start":984227,"byte_end":984230,"line_start":94,"line_end":94,"column_start":12,"column_end":15},"name":"get","qualname":"<MultiSet>::get","value":"fn (&self, i: usize) -> usize","parent":null,"children":[],"decl_id":null,"docs":" This function returns the value of the i-th element of the multiset c. If i lies outside the allowed range of 0 to k-1 then the\n error handler is invoked and 0 is returned.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4434},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multiset.rs","byte_start":984395,"byte_end":984396,"line_start":99,"line_end":99,"column_start":12,"column_end":13},"name":"n","qualname":"<MultiSet>::n","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" This function returns the range (n) of the multiset self.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4435},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multiset.rs","byte_start":984559,"byte_end":984560,"line_start":104,"line_end":104,"column_start":12,"column_end":13},"name":"k","qualname":"<MultiSet>::k","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" This function returns the number of elements (k) in the multiset self.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4436},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multiset.rs","byte_start":984731,"byte_end":984735,"line_start":109,"line_end":109,"column_start":12,"column_end":16},"name":"data","qualname":"<MultiSet>::data","value":"fn <'r> (&'r mut self) -> &'r mut [usize]","parent":null,"children":[],"decl_id":null,"docs":" This function returns a pointer to the array of elements in the multiset self.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4438},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multiset.rs","byte_start":984989,"byte_end":984994,"line_start":115,"line_end":115,"column_start":12,"column_end":17},"name":"valid","qualname":"<MultiSet>::valid","value":"fn (&self) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function checks that the multiset self is valid. The k elements should lie in the range 0 to n-1, with each value occurring in\n nondecreasing order.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4439},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multiset.rs","byte_start":985497,"byte_end":985501,"line_start":122,"line_end":122,"column_start":12,"column_end":16},"name":"next","qualname":"<MultiSet>::next","value":"fn (&mut self) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function advances the multiset self to the next multiset element in lexicographic order and returns ::Value::Success. If no\n further multisets elements are available it returns enums::value::Failure and leaves self unmodified. Starting with the first multiset and\n repeatedly applying this function will iterate through all possible multisets of a given order.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4440},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multiset.rs","byte_start":985871,"byte_end":985875,"line_start":128,"line_end":128,"column_start":12,"column_end":16},"name":"prev","qualname":"<MultiSet>::prev","value":"fn (&mut self) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function steps backwards from the multiset self to the previous multiset element in lexicographic order, returning ::Value::Success.\n If no previous multiset is available it returns enums::value::Failure and leaves self unmodified.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4441},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multiset.rs","byte_start":985993,"byte_end":985998,"line_start":132,"line_end":132,"column_start":12,"column_end":17},"name":"print","qualname":"<MultiSet>::print","value":"fn (&self, writer: &mut Write) -> IoResult<()>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":4449},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/n_tuples.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"n_tuples","qualname":"::types::n_tuples","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/n_tuples.rs","parent":null,"children":[{"krate":0,"index":4450},{"krate":0,"index":4451},{"krate":0,"index":4452},{"krate":0,"index":4455},{"krate":0,"index":4456},{"krate":0,"index":4457},{"krate":0,"index":4458},{"krate":0,"index":4462},{"krate":0,"index":4472},{"krate":0,"index":4475}],"decl_id":null,"docs":"#N-tuples","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4458},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/n_tuples.rs","byte_start":988908,"byte_end":988915,"line_start":38,"line_end":38,"column_start":12,"column_end":19},"name":"NTuples","qualname":"::types::n_tuples::NTuples","value":"NTuples {  }","parent":null,"children":[{"krate":0,"index":4460},{"krate":0,"index":4461}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4464},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/n_tuples.rs","byte_start":989387,"byte_end":989393,"line_start":47,"line_end":47,"column_start":12,"column_end":18},"name":"create","qualname":"<NTuples<T>>::create","value":"fn (filename: &str, data: &mut T) -> Option<NTuples<T>>","parent":null,"children":[],"decl_id":null,"docs":" This function creates a new write-only ntuple file filename for ntuples of size size and returns a pointer to the newly created ntuple\n struct. Any existing file with the same name is truncated to zero length and overwritten. A pointer to memory for the current ntuple\n row ntuple_data must be supplied—this is used to copy ntuples in and out of the file.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4465},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/n_tuples.rs","byte_start":990230,"byte_end":990234,"line_start":67,"line_end":67,"column_start":12,"column_end":16},"name":"open","qualname":"<NTuples<T>>::open","value":"fn (filename: &str, data: &mut T) -> Option<NTuples<T>>","parent":null,"children":[],"decl_id":null,"docs":" This function opens an existing ntuple file filename for reading and returns a pointer to a corresponding ntuple struct. The ntuples\n in the file must have size size. A pointer to memory for the current ntuple row ntuple_data must be supplied—this is used to copy\n ntuples in and out of the file.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4466},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/n_tuples.rs","byte_start":990864,"byte_end":990869,"line_start":85,"line_end":85,"column_start":12,"column_end":17},"name":"write","qualname":"<NTuples<T>>::write","value":"fn (&self) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function writes the current ntuple ntuple->ntuple_data of size ntuple->size to the corresponding file.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4467},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/n_tuples.rs","byte_start":991037,"byte_end":991045,"line_start":90,"line_end":90,"column_start":12,"column_end":20},"name":"bookdata","qualname":"<NTuples<T>>::bookdata","value":"fn (&self) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function is a synonym for NTuples::write.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4468},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/n_tuples.rs","byte_start":991274,"byte_end":991278,"line_start":95,"line_end":95,"column_start":12,"column_end":16},"name":"read","qualname":"<NTuples<T>>::read","value":"fn (&self) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function reads the current row of the ntuple file for ntuple and stores the values in ntuple->data.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4469},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/n_tuples.rs","byte_start":991390,"byte_end":991397,"line_start":99,"line_end":99,"column_start":12,"column_end":19},"name":"project","qualname":"<NTuples<T>>::project","value":"fn <U, V> (&self, h: &mut ::Histogram, value_func: ::value_function<T, U>, value_arg: &mut U, select_func: ::select_function<T, V>, select_arg: &mut V) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":4481},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"ordinary_differential_equations","qualname":"::types::ordinary_differential_equations","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","parent":null,"children":[{"krate":0,"index":4482},{"krate":0,"index":4483},{"krate":0,"index":4486},{"krate":0,"index":4487},{"krate":0,"index":4492},{"krate":0,"index":4497},{"krate":0,"index":4498},{"krate":0,"index":4499},{"krate":0,"index":4501},{"krate":0,"index":4508},{"krate":0,"index":4510},{"krate":0,"index":7037},{"krate":0,"index":7040},{"krate":0,"index":7039},{"krate":0,"index":4515},{"krate":0,"index":4527},{"krate":0,"index":4532},{"krate":0,"index":4534},{"krate":0,"index":4545},{"krate":0,"index":4547},{"krate":0,"index":7042},{"krate":0,"index":7045},{"krate":0,"index":7044},{"krate":0,"index":4552},{"krate":0,"index":4555},{"krate":0,"index":4560},{"krate":0,"index":4562},{"krate":0,"index":4568},{"krate":0,"index":4570},{"krate":0,"index":4575},{"krate":0,"index":4580},{"krate":0,"index":4593}],"decl_id":null,"docs":" Numerical ODE solvers.","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4487},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":996522,"byte_end":996534,"line_start":74,"line_end":74,"column_start":12,"column_end":24},"name":"ODEiv2System","qualname":"::types::ordinary_differential_equations::ODEiv2System","value":"ODEiv2System {  }","parent":null,"children":[{"krate":0,"index":4489},{"krate":0,"index":4490},{"krate":0,"index":4491}],"decl_id":null,"docs":" Description of a system of ODEs.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4494},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":996846,"byte_end":996849,"line_start":82,"line_end":82,"column_start":12,"column_end":15},"name":"new","qualname":"<ODEiv2System>::new","value":"fn (dimension: usize, function: &'a mut FnMut(f64, &[f64], &mut [f64]) -> GSLResult<()>) -> ODEiv2System<'a>","parent":null,"children":[],"decl_id":null,"docs":" Returns a new ODEiv2System with a given dimension and right-hand side.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4495},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":997211,"byte_end":997224,"line_start":93,"line_end":93,"column_start":12,"column_end":25},"name":"with_jacobian","qualname":"<ODEiv2System>::with_jacobian","value":"fn (dimension: usize, function: &'a mut FnMut(f64, &[f64], &mut [f64]) -> GSLResult<()>, jacobian: &'a mut FnMut(f64, &[f64], &mut [f64], &mut [f64]) -> GSLResult<()>) -> ODEiv2System<'a>","parent":null,"children":[],"decl_id":null,"docs":" Returns a new ODEiv2System with a jacobian function provided.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4499},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":999325,"byte_end":999335,"line_start":149,"line_end":149,"column_start":12,"column_end":22},"name":"ODEiv2Step","qualname":"::types::ordinary_differential_equations::ODEiv2Step","value":"ODEiv2Step {  }","parent":null,"children":[{"krate":0,"index":4500}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4502},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":999737,"byte_end":999740,"line_start":157,"line_end":157,"column_start":12,"column_end":15},"name":"new","qualname":"<ODEiv2Step>::new","value":"fn (t: &ODEiv2StepType, dim: usize) -> Option<ODEiv2Step>","parent":null,"children":[],"decl_id":null,"docs":" This function returns a pointer to a newly allocated instance of a stepping function of type T for a system of dim dimensions.\n Please note that if you use a stepper method that requires access to a driver object, it is advisable to use a driver allocation\n method, which automatically allocates a stepper, too.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4503},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1000200,"byte_end":1000205,"line_start":171,"line_end":171,"column_start":12,"column_end":17},"name":"reset","qualname":"<ODEiv2Step>::reset","value":"fn (&mut self) -> GSLResult<()>","parent":null,"children":[],"decl_id":null,"docs":" This function resets the stepping function s. It should be used whenever the next use of s will not be a continuation of a previous\n step.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4504},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1000591,"byte_end":1000595,"line_start":181,"line_end":181,"column_start":12,"column_end":16},"name":"name","qualname":"<ODEiv2Step>::name","value":"fn (&self) -> Option<String>","parent":null,"children":[],"decl_id":null,"docs":" This function returns a pointer to the name of the stepping function. For example,","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4505},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1001045,"byte_end":1001050,"line_start":193,"line_end":193,"column_start":12,"column_end":17},"name":"order","qualname":"<ODEiv2Step>::order","value":"fn (&self) -> u32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the order of the stepping function on the previous step. The order can vary if the stepping function itself is\n adaptive.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4506},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1001488,"byte_end":1001498,"line_start":200,"line_end":200,"column_start":12,"column_end":22},"name":"set_driver","qualname":"<ODEiv2Step>::set_driver","value":"fn (&mut self, d: &ODEiv2Driver) -> GSLResult<()>","parent":null,"children":[],"decl_id":null,"docs":" This function sets a pointer of the driver object d for stepper s, to allow the stepper to access control (and evolve) object through\n the driver object. This is a requirement for some steppers, to get the desired error level for internal iteration of stepper.\n Allocation of a driver object calls this function automatically.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4507},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1003377,"byte_end":1003382,"line_start":219,"line_end":219,"column_start":12,"column_end":17},"name":"apply","qualname":"<ODEiv2Step>::apply","value":"fn (&mut self, t: f64, h: f64, y: &mut [f64], yerr: &mut [f64], dydt_in: &[f64], dydt_out: &mut [f64], sys: &mut ODEiv2System) -> GSLResult<()>","parent":null,"children":[],"decl_id":null,"docs":" This function applies the stepping function s to the system of equations defined by sys, using the step-size h to advance the system\n from time t and state y to time t+h. The new state of the system is stored in y on output, with an estimate of the absolute error\n in each component stored in yerr. If the argument dydt_in is not null it should point an array containing the derivatives for the\n system at time t on input. This is optional as the derivatives will be computed internally if they are not provided, but allows\n the reuse of existing derivative information. On output the new derivatives of the system at time t+h will be stored in dydt_out\n if it is not null.","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":7037},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1004455,"byte_end":1004469,"line_start":256,"line_end":256,"column_start":12,"column_end":26},"name":"ODEiv2StepType","qualname":"::types::ordinary_differential_equations::ODEiv2StepType","value":"ODEiv2StepType {  }","parent":null,"children":[{"krate":0,"index":7038}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4516},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1004601,"byte_end":1004604,"line_start":262,"line_end":262,"column_start":12,"column_end":15},"name":"rk2","qualname":"<ODEiv2StepType>::rk2","value":"fn () -> ODEiv2StepType","parent":null,"children":[],"decl_id":null,"docs":" Explicit embedded Runge-Kutta (2, 3) method.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4517},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1004964,"byte_end":1004967,"line_start":272,"line_end":272,"column_start":12,"column_end":15},"name":"rk4","qualname":"<ODEiv2StepType>::rk4","value":"fn () -> ODEiv2StepType","parent":null,"children":[],"decl_id":null,"docs":" Explicit 4th order (classical) Runge-Kutta. Error estimation is carried out by the step doubling method. For more efficient\n estimate of the error, use the embedded methods described below.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4518},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1005234,"byte_end":1005238,"line_start":281,"line_end":281,"column_start":12,"column_end":16},"name":"rk45","qualname":"<ODEiv2StepType>::rk45","value":"fn () -> ODEiv2StepType","parent":null,"children":[],"decl_id":null,"docs":" Explicit embedded Runge-Kutta-Fehlberg (4, 5) method. This method is a good general-purpose integrator.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4519},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1005458,"byte_end":1005462,"line_start":290,"line_end":290,"column_start":12,"column_end":16},"name":"rkck","qualname":"<ODEiv2StepType>::rkck","value":"fn () -> ODEiv2StepType","parent":null,"children":[],"decl_id":null,"docs":" Explicit embedded Runge-Kutta Cash-Karp (4, 5) method.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4520},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1005686,"byte_end":1005691,"line_start":299,"line_end":299,"column_start":12,"column_end":17},"name":"rk8pd","qualname":"<ODEiv2StepType>::rk8pd","value":"fn () -> ODEiv2StepType","parent":null,"children":[],"decl_id":null,"docs":" Explicit embedded Runge-Kutta Prince-Dormand (8, 9) method.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4521},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1006124,"byte_end":1006130,"line_start":309,"line_end":309,"column_start":12,"column_end":18},"name":"rk1imp","qualname":"<ODEiv2StepType>::rk1imp","value":"fn () -> ODEiv2StepType","parent":null,"children":[],"decl_id":null,"docs":" Implicit Gaussian first order Runge-Kutta. Also known as implicit Euler or backward Euler method. Error estimation is carried out by\n the step doubling method. This algorithm requires the Jacobian and access to the driver object via gsl_odeiv2_step_set_driver.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4522},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1006547,"byte_end":1006553,"line_start":319,"line_end":319,"column_start":12,"column_end":18},"name":"rk2imp","qualname":"<ODEiv2StepType>::rk2imp","value":"fn () -> ODEiv2StepType","parent":null,"children":[],"decl_id":null,"docs":" Implicit Gaussian second order Runge-Kutta. Also known as implicit mid-point rule. Error estimation is carried out by the step doubling\n method. This stepper requires the Jacobian and access to the driver object via gsl_odeiv2_step_set_driver.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4523},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1006930,"byte_end":1006936,"line_start":329,"line_end":329,"column_start":12,"column_end":18},"name":"rk4imp","qualname":"<ODEiv2StepType>::rk4imp","value":"fn () -> ODEiv2StepType","parent":null,"children":[],"decl_id":null,"docs":" Implicit Gaussian 4th order Runge-Kutta. Error estimation is carried out by the step doubling method. This algorithm requires the\n Jacobian and access to the driver object via gsl_odeiv2_step_set_driver.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4524},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1007254,"byte_end":1007259,"line_start":339,"line_end":339,"column_start":12,"column_end":17},"name":"bsimp","qualname":"<ODEiv2StepType>::bsimp","value":"fn () -> ODEiv2StepType","parent":null,"children":[],"decl_id":null,"docs":" Implicit Bulirsch-Stoer method of Bader and Deuflhard. The method is generally suitable for stiff problems. This stepper requires\n the Jacobian.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4525},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1007788,"byte_end":1007795,"line_start":350,"line_end":350,"column_start":12,"column_end":19},"name":"msadams","qualname":"<ODEiv2StepType>::msadams","value":"fn () -> ODEiv2StepType","parent":null,"children":[],"decl_id":null,"docs":" A variable-coefficient linear multistep Adams method in Nordsieck form. This stepper uses explicit Adams-Bashforth (predictor) and\n implicit Adams-Moulton (corrector) methods in P(EC)^m functional iteration mode. Method order varies dynamically between 1 and 12.\n This stepper requires the access to the driver object via gsl_odeiv2_step_set_driver.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4526},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1008479,"byte_end":1008484,"line_start":362,"line_end":362,"column_start":12,"column_end":17},"name":"msbdf","qualname":"<ODEiv2StepType>::msbdf","value":"fn () -> ODEiv2StepType","parent":null,"children":[],"decl_id":null,"docs":" A variable-coefficient linear multistep backward differentiation formula (BDF) method in Nordsieck form. This stepper uses the explicit\n BDF formula as predictor and implicit BDF formula as corrector. A modified Newton iteration method is used to solve the system of\n non-linear equations. Method order varies dynamically between 1 and 5. The method is generally suitable for stiff problems. This\n stepper requires the Jacobian and the access to the driver object via gsl_odeiv2_step_set_driver.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4532},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1009202,"byte_end":1009215,"line_start":391,"line_end":391,"column_start":12,"column_end":25},"name":"ODEiv2Control","qualname":"::types::ordinary_differential_equations::ODEiv2Control","value":"ODEiv2Control {  }","parent":null,"children":[{"krate":0,"index":4533}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4535},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1010687,"byte_end":1010699,"line_start":416,"line_end":416,"column_start":12,"column_end":24},"name":"standard_new","qualname":"<ODEiv2Control>::standard_new","value":"fn (eps_abs: f64, eps_rel: f64, a_y: f64, a_dydt: f64) -> Option<ODEiv2Control>","parent":null,"children":[],"decl_id":null,"docs":" The standard control object is a four parameter heuristic based on absolute and relative errors eps_abs and eps_rel, and scaling\n factors a_y and a_dydt for the system state y(t) and derivatives y'(t) respectively.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4536},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1011319,"byte_end":1011324,"line_start":430,"line_end":430,"column_start":12,"column_end":17},"name":"y_new","qualname":"<ODEiv2Control>::y_new","value":"fn (eps_abs: f64, eps_rel: f64) -> Option<ODEiv2Control>","parent":null,"children":[],"decl_id":null,"docs":" This function creates a new control object which will keep the local error on each step within an absolute error of eps_abs and relative\n error of eps_rel with respect to the solution y_i(t). This is equivalent to the standard control object with a_y=1 and a_dydt=0.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4537},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1011929,"byte_end":1011935,"line_start":445,"line_end":445,"column_start":12,"column_end":18},"name":"yp_new","qualname":"<ODEiv2Control>::yp_new","value":"fn (eps_abs: f64, eps_rel: f64) -> Option<ODEiv2Control>","parent":null,"children":[],"decl_id":null,"docs":" This function creates a new control object which will keep the local error on each step within an absolute error of eps_abs and relative\n error of eps_rel with respect to the derivatives of the solution y'_i(t). This is equivalent to the standard control object with\n a_y=0 and a_dydt=1.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4538},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1012710,"byte_end":1012720,"line_start":463,"line_end":463,"column_start":12,"column_end":22},"name":"scaled_new","qualname":"<ODEiv2Control>::scaled_new","value":"fn (eps_abs: f64, eps_rel: f64, a_y: f64, a_dydt: f64, scale_abs: &[f64]) -> Option<ODEiv2Control>","parent":null,"children":[],"decl_id":null,"docs":" This function creates a new control object which uses the same algorithm as gsl_odeiv2_control_standard_new but with an absolute error\n which is scaled for each component by the array scale_abs. The formula for D_i for this control object is,","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4539},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1013393,"byte_end":1013398,"line_start":477,"line_end":477,"column_start":12,"column_end":17},"name":"alloc","qualname":"<ODEiv2Control>::alloc","value":"fn (t: &ODEiv2ControlType) -> Option<ODEiv2Control>","parent":null,"children":[],"decl_id":null,"docs":" This function returns a pointer to a newly allocated instance of a control function of type T. This function is only needed for\n defining new types of control functions. For most purposes the standard control functions described above should be sufficient.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4540},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1013907,"byte_end":1013911,"line_start":491,"line_end":491,"column_start":12,"column_end":16},"name":"init","qualname":"<ODEiv2Control>::init","value":"fn (&mut self, eps_abs: f64, eps_rel: f64, a_y: f64, a_dydt: f64) -> GSLResult<()>","parent":null,"children":[],"decl_id":null,"docs":" This function initializes the control function c with the parameters eps_abs (absolute error), eps_rel (relative error), a_y\n (scaling factor for y) and a_dydt (scaling factor for derivatives).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4541},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1014807,"byte_end":1014814,"line_start":502,"line_end":502,"column_start":12,"column_end":19},"name":"hadjust","qualname":"<ODEiv2Control>::hadjust","value":"fn (&mut self, s: &ODEiv2Step, y: &[f64], yerr: &[f64], dydt: &[f64], h: &mut f64) -> ::ODEiv","parent":null,"children":[],"decl_id":null,"docs":" This function adjusts the step-size h using the control function c, and the current values of y, yerr and dydt. The stepping function\n step is also needed to determine the order of the method. If the error in the y-values yerr is found to be too large then the step-size\n h is reduced and the function returns ODEiv::Dec. If the error is sufficiently small then h may be increased and\n ODEiv::Inc is returned. The function returns ODEiv::Nil if the step-size is unchanged. The goal of the function is to estimate\n the largest step-size which satisfies the user-specified accuracy requirements for the current point.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4542},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1015293,"byte_end":1015297,"line_start":512,"line_end":512,"column_start":12,"column_end":16},"name":"name","qualname":"<ODEiv2Control>::name","value":"fn (&self) -> Option<String>","parent":null,"children":[],"decl_id":null,"docs":" This function returns a pointer to the name of the control function. For example,","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4543},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1015799,"byte_end":1015807,"line_start":524,"line_end":524,"column_start":12,"column_end":20},"name":"errlevel","qualname":"<ODEiv2Control>::errlevel","value":"fn (&mut self, y: f64, dydt: f64, h: f64, ind: usize, errlev: &mut f64) -> GSLResult<()>","parent":null,"children":[],"decl_id":null,"docs":" This function calculates the desired error level of the ind-th component to errlev. It requires the value (y) and value of the derivative\n (dydt) of the component, and the current step size h.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4544},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1016137,"byte_end":1016147,"line_start":531,"line_end":531,"column_start":12,"column_end":22},"name":"set_driver","qualname":"<ODEiv2Control>::set_driver","value":"fn (&mut self, d: &ODEiv2Driver) -> GSLResult<()>","parent":null,"children":[],"decl_id":null,"docs":" This function sets a pointer of the driver object d for control object c.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":7042},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1016998,"byte_end":1017015,"line_start":566,"line_end":566,"column_start":12,"column_end":29},"name":"ODEiv2ControlType","qualname":"::types::ordinary_differential_equations::ODEiv2ControlType","value":"ODEiv2ControlType {  }","parent":null,"children":[{"krate":0,"index":7043}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4553},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1017100,"byte_end":1017106,"line_start":571,"line_end":571,"column_start":12,"column_end":18},"name":"scaled","qualname":"<ODEiv2ControlType>::scaled","value":"fn () -> ODEiv2ControlType","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4554},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1017273,"byte_end":1017281,"line_start":579,"line_end":579,"column_start":12,"column_end":20},"name":"standard","qualname":"<ODEiv2ControlType>::standard","value":"fn () -> ODEiv2ControlType","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4560},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1018050,"byte_end":1018062,"line_start":608,"line_end":608,"column_start":12,"column_end":24},"name":"ODEiv2Evolve","qualname":"::types::ordinary_differential_equations::ODEiv2Evolve","value":"ODEiv2Evolve {  }","parent":null,"children":[{"krate":0,"index":4561}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4563},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1018261,"byte_end":1018264,"line_start":614,"line_end":614,"column_start":12,"column_end":15},"name":"new","qualname":"<ODEiv2Evolve>::new","value":"fn (dim: usize) -> Option<ODEiv2Evolve>","parent":null,"children":[],"decl_id":null,"docs":" This function returns a pointer to a newly allocated instance of an evolution function for a system of dim dimensions.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4564},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1020307,"byte_end":1020312,"line_start":644,"line_end":644,"column_start":12,"column_end":17},"name":"apply","qualname":"<ODEiv2Evolve>::apply","value":"fn (&mut self, c: &ODEiv2Control, s: &ODEiv2Step, sys: &mut ODEiv2System, t: &mut f64, t1: f64, h: &mut f64, y: &mut [f64]) -> GSLResult<()>","parent":null,"children":[],"decl_id":null,"docs":" This function advances the system (e, sys) from time t and position y using the stepping function step. The new time and position\n are stored in t and y on output.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4565},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1021090,"byte_end":1021106,"line_start":656,"line_end":656,"column_start":12,"column_end":28},"name":"apply_fixed_step","qualname":"<ODEiv2Evolve>::apply_fixed_step","value":"fn (&mut self, c: &ODEiv2Control, s: &ODEiv2Step, sys: &mut ODEiv2System, t: &mut f64, h: f64, y: &mut [f64]) -> GSLResult<()>","parent":null,"children":[],"decl_id":null,"docs":" This function advances the ODE-system (e, sys, con) from time t and position y using the stepping function step by a specified step\n size h. If the local error estimated by the stepping function exceeds the desired error level, the step is not taken and the function\n returns enums::value::Failure. Otherwise the value returned by user function is returned.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4566},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1021652,"byte_end":1021657,"line_start":667,"line_end":667,"column_start":12,"column_end":17},"name":"reset","qualname":"<ODEiv2Evolve>::reset","value":"fn (&mut self) -> GSLResult<()>","parent":null,"children":[],"decl_id":null,"docs":" This function resets the evolution function e. It should be used whenever the next use of e will not be a continuation of a previous\n step.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4567},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1022309,"byte_end":1022319,"line_start":676,"line_end":676,"column_start":12,"column_end":22},"name":"set_driver","qualname":"<ODEiv2Evolve>::set_driver","value":"fn (&mut self, d: &ODEiv2Driver) -> GSLResult<()>","parent":null,"children":[],"decl_id":null,"docs":" This function sets a pointer of the driver object d for evolve object e.","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4575},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1023125,"byte_end":1023137,"line_start":708,"line_end":708,"column_start":12,"column_end":24},"name":"ODEiv2Driver","qualname":"::types::ordinary_differential_equations::ODEiv2Driver","value":"ODEiv2Driver {  }","parent":null,"children":[{"krate":0,"index":4577},{"krate":0,"index":4578},{"krate":0,"index":4579}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4582},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1023935,"byte_end":1023946,"line_start":722,"line_end":722,"column_start":12,"column_end":23},"name":"alloc_y_new","qualname":"<ODEiv2Driver>::alloc_y_new","value":"fn (sys: &'a mut ODEiv2System, t: &ODEiv2StepType, hstart: f64, epsabs: f64, epsrel: f64) -> Option<ODEiv2Driver<'a>>","parent":null,"children":[],"decl_id":null,"docs":" These functions return a pointer to a newly allocated instance of a driver object. The functions automatically allocate and initialise\n the evolve, control and stepper objects for ODE system sys using stepper type T. The initial step size is given in hstart. The rest\n of the arguments follow the syntax and semantics of the control functions with same name (gsl_odeiv2_control_*_new).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4583},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1024910,"byte_end":1024922,"line_start":741,"line_end":741,"column_start":12,"column_end":24},"name":"alloc_yp_new","qualname":"<ODEiv2Driver>::alloc_yp_new","value":"fn (sys: &'a mut ODEiv2System, t: &ODEiv2StepType, hstart: f64, epsabs: f64, epsrel: f64) -> Option<ODEiv2Driver<'a>>","parent":null,"children":[],"decl_id":null,"docs":" These functions return a pointer to a newly allocated instance of a driver object. The functions automatically allocate and initialise\n the evolve, control and stepper objects for ODE system sys using stepper type T. The initial step size is given in hstart. The rest\n of the arguments follow the syntax and semantics of the control functions with same name (gsl_odeiv2_control_*_new).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4584},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1025887,"byte_end":1025905,"line_start":760,"line_end":760,"column_start":12,"column_end":30},"name":"alloc_standard_new","qualname":"<ODEiv2Driver>::alloc_standard_new","value":"fn (sys: &'a mut ODEiv2System, t: &ODEiv2StepType, hstart: f64, epsabs: f64, epsrel: f64, a_y: f64, a_dydt: f64) -> Option<ODEiv2Driver<'a>>","parent":null,"children":[],"decl_id":null,"docs":" These functions return a pointer to a newly allocated instance of a driver object. The functions automatically allocate and initialise\n the evolve, control and stepper objects for ODE system sys using stepper type T. The initial step size is given in hstart. The rest\n of the arguments follow the syntax and semantics of the control functions with same name (gsl_odeiv2_control_*_new).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4585},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1026920,"byte_end":1026936,"line_start":780,"line_end":780,"column_start":12,"column_end":28},"name":"alloc_scaled_new","qualname":"<ODEiv2Driver>::alloc_scaled_new","value":"fn (sys: &'a mut ODEiv2System, t: &ODEiv2StepType, hstart: f64, epsabs: f64, epsrel: f64, a_y: f64, a_dydt: f64, scale_abs: &[f64]) -> Option<ODEiv2Driver<'a>>","parent":null,"children":[],"decl_id":null,"docs":" These functions return a pointer to a newly allocated instance of a driver object. The functions automatically allocate and initialise\n the evolve, control and stepper objects for ODE system sys using stepper type T. The initial step size is given in hstart. The rest\n of the arguments follow the syntax and semantics of the control functions with same name (gsl_odeiv2_control_*_new).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4586},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1027692,"byte_end":1027700,"line_start":799,"line_end":799,"column_start":12,"column_end":20},"name":"set_hmin","qualname":"<ODEiv2Driver>::set_hmin","value":"fn (&mut self, hmin: f64) -> GSLResult<()>","parent":null,"children":[],"decl_id":null,"docs":" The function sets a minimum for allowed step size hmin for driver self. Default value is 0.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4587},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1027970,"byte_end":1027978,"line_start":804,"line_end":804,"column_start":12,"column_end":20},"name":"set_hmax","qualname":"<ODEiv2Driver>::set_hmax","value":"fn (&mut self, hmax: f64) -> GSLResult<()>","parent":null,"children":[],"decl_id":null,"docs":" The function sets a maximum for allowed step size hmax for driver self. Default value is ::DBL_MAX.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4588},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1028270,"byte_end":1028278,"line_start":809,"line_end":809,"column_start":12,"column_end":20},"name":"set_nmax","qualname":"<ODEiv2Driver>::set_nmax","value":"fn (&mut self, nmax: usize) -> GSLResult<()>","parent":null,"children":[],"decl_id":null,"docs":" The function sets a maximum for allowed number of steps nmax for driver self. Default value of 0 sets no limit for steps.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4589},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1029221,"byte_end":1029226,"line_start":821,"line_end":821,"column_start":12,"column_end":17},"name":"apply","qualname":"<ODEiv2Driver>::apply","value":"fn (&mut self, t: &mut f64, t1: f64, y: &mut [f64]) -> GSLResult<()>","parent":null,"children":[],"decl_id":null,"docs":" This function evolves the driver system d from t to t1. Initially vector y should contain the values of dependent variables at\n point t. If the function is unable to complete the calculation, an error code from gsl_odeiv2_evolve_apply is returned, and t and\n y contain the values from last successful step.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4590},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1029697,"byte_end":1029713,"line_start":827,"line_end":827,"column_start":12,"column_end":28},"name":"apply_fixed_step","qualname":"<ODEiv2Driver>::apply_fixed_step","value":"fn (&mut self, t: &mut f64, h: f64, n: usize, y: &mut [f64]) -> GSLResult<()>","parent":null,"children":[],"decl_id":null,"docs":" This function evolves the driver system d from t with n steps of size h. If the function is unable to complete the calculation, an\n error code from gsl_odeiv2_evolve_apply_fixed_step is returned, and t and y contain the values from last successful step.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4591},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1030001,"byte_end":1030006,"line_start":832,"line_end":832,"column_start":12,"column_end":17},"name":"reset","qualname":"<ODEiv2Driver>::reset","value":"fn (&mut self) -> GSLResult<()>","parent":null,"children":[],"decl_id":null,"docs":" This function resets the evolution and stepper objects.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4592},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1030330,"byte_end":1030342,"line_start":838,"line_end":838,"column_start":12,"column_end":24},"name":"reset_hstart","qualname":"<ODEiv2Driver>::reset_hstart","value":"fn (&mut self, hstart: f64) -> GSLResult<()>","parent":null,"children":[],"decl_id":null,"docs":" The routine resets the evolution and stepper objects and sets new initial step size to hstart. This function can be used e.g. to\n change the direction of integration.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":4596},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"permutation","qualname":"::types::permutation","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","parent":null,"children":[{"krate":0,"index":4597},{"krate":0,"index":4599},{"krate":0,"index":4600},{"krate":0,"index":4601},{"krate":0,"index":4602},{"krate":0,"index":4605},{"krate":0,"index":4606},{"krate":0,"index":4609},{"krate":0,"index":4634},{"krate":0,"index":4636},{"krate":0,"index":4641}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4606},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":1031325,"byte_end":1031336,"line_start":12,"line_end":12,"column_start":12,"column_end":23},"name":"Permutation","qualname":"::types::permutation::Permutation","value":"Permutation {  }","parent":null,"children":[{"krate":0,"index":4607},{"krate":0,"index":4608}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4610},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":1033839,"byte_end":1033842,"line_start":46,"line_end":46,"column_start":12,"column_end":15},"name":"new","qualname":"<Permutation>::new","value":"fn (n: usize) -> Option<Permutation>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates memory for a new permutation of size n. The permutation is not initialized and its elements are undefined.\n Use the function gsl_permutation_calloc if you want to create a permutation which is initialized to the identity. A null pointer is\n returned if insufficient memory is available to create the permutation.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4611},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":1034420,"byte_end":1034433,"line_start":63,"line_end":63,"column_start":12,"column_end":25},"name":"new_with_init","qualname":"<Permutation>::new_with_init","value":"fn (n: usize) -> Option<Permutation>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates memory for a new permutation of size n and initializes it to the identity. A null pointer is returned if\n insufficient memory is available to create the permutation.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4612},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":1034898,"byte_end":1034902,"line_start":79,"line_end":79,"column_start":12,"column_end":16},"name":"init","qualname":"<Permutation>::init","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function initializes the permutation p to the identity, i.e. (0,1,2,…,n-1).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4613},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":1035125,"byte_end":1035129,"line_start":84,"line_end":84,"column_start":12,"column_end":16},"name":"copy","qualname":"<Permutation>::copy","value":"fn (&self, dest: &mut Permutation) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the permutation src into the permutation dest. The two permutations must have the same size.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4614},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":1035471,"byte_end":1035474,"line_start":90,"line_end":90,"column_start":12,"column_end":15},"name":"get","qualname":"<Permutation>::get","value":"fn (&self, i: usize) -> usize","parent":null,"children":[],"decl_id":null,"docs":" This function returns the value of the i-th element of the permutation p. If i lies outside the allowed range of 0 to n-1 then\n the error handler is invoked and 0 is returned.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4615},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":1035657,"byte_end":1035661,"line_start":95,"line_end":95,"column_start":12,"column_end":16},"name":"swap","qualname":"<Permutation>::swap","value":"fn (&mut self, i: usize, j: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function exchanges the i-th and j-th elements of the permutation p.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4616},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":1035869,"byte_end":1035873,"line_start":100,"line_end":100,"column_start":12,"column_end":16},"name":"size","qualname":"<Permutation>::size","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" This function returns the size of the permutation p.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4617},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":1036050,"byte_end":1036054,"line_start":105,"line_end":105,"column_start":12,"column_end":16},"name":"data","qualname":"<Permutation>::data","value":"fn <'r> (&'r mut self) -> &'r mut [usize]","parent":null,"children":[],"decl_id":null,"docs":" This function returns a pointer to the array of elements in the permutation p.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4619},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":1036277,"byte_end":1036285,"line_start":110,"line_end":110,"column_start":12,"column_end":20},"name":"is_valid","qualname":"<Permutation>::is_valid","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function checks that the permutation p is valid. The n elements should contain each of the numbers 0 to n-1 once and only once.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4620},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":1036527,"byte_end":1036534,"line_start":118,"line_end":118,"column_start":12,"column_end":19},"name":"reverse","qualname":"<Permutation>::reverse","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function reverses the elements of the permutation p.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4621},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":1036714,"byte_end":1036721,"line_start":123,"line_end":123,"column_start":12,"column_end":19},"name":"inverse","qualname":"<Permutation>::inverse","value":"fn (&self, inv: &mut Permutation) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the inverse of the permutation p, storing the result in inv.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4622},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":1037239,"byte_end":1037243,"line_start":130,"line_end":130,"column_start":12,"column_end":16},"name":"next","qualname":"<Permutation>::next","value":"fn (&mut self) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function advances the permutation p to the next permutation in lexicographic order and returns GSL_SUCCESS. If no further\n permutations are available it returns GSL_FAILURE and leaves p unmodified. Starting with the identity permutation and repeatedly\n applying this function will iterate through all possible permutations of a given order.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4623},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":1037596,"byte_end":1037600,"line_start":136,"line_end":136,"column_start":12,"column_end":16},"name":"prev","qualname":"<Permutation>::prev","value":"fn (&mut self) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function steps backwards from the permutation p to the previous permutation in lexicographic order, returning GSL_SUCCESS.\n If no previous permutation is available it returns GSL_FAILURE and leaves p unmodified.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4624},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":1037815,"byte_end":1037822,"line_start":141,"line_end":141,"column_start":12,"column_end":19},"name":"permute","qualname":"<Permutation>::permute","value":"fn (&mut self, data: &mut [f64], stride: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function applies the permutation to the array data of size n with stride stride.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4625},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":1038154,"byte_end":1038169,"line_start":148,"line_end":148,"column_start":12,"column_end":27},"name":"permute_inverse","qualname":"<Permutation>::permute_inverse","value":"fn (&mut self, data: &mut [f64], stride: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function applies the inverse of the permutation p to the array data of size n with stride stride.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4626},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":1038741,"byte_end":1038755,"line_start":157,"line_end":157,"column_start":12,"column_end":26},"name":"permute_vector","qualname":"<Permutation>::permute_vector","value":"fn (&mut self, v: &mut VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function applies the permutation p to the elements of the vector v, considered as a row-vector acted on by a permutation\n matrix from the right, v' = v P. The j-th column of the permutation matrix P is given by the p_j-th column of the identity matrix.\n The permutation p and the vector v must have the same length.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4627},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":1039367,"byte_end":1039389,"line_start":164,"line_end":164,"column_start":12,"column_end":34},"name":"permute_vector_inverse","qualname":"<Permutation>::permute_vector_inverse","value":"fn (&self, v: &mut VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function applies the inverse of the permutation p to the elements of the vector v, considered as a row-vector acted on by an inverse permutation\n matrix from the right, v' = v P^T. Note that for permutation matrices the inverse is the same as the transpose. The j-th column of the permutation\n matrix P is given by the p_j-th column of the identity matrix. The permutation p and the vector v must have the same length.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4628},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":1039763,"byte_end":1039766,"line_start":172,"line_end":172,"column_start":12,"column_end":15},"name":"mul","qualname":"<Permutation>::mul","value":"fn (&mut self, pa: &Permutation, pb: &Permutation) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function combines the two permutations pa and pb into a single permutation p, where p = pa * pb. The permutation p is equivalent to applying pb\n first and then pa.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4629},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":1040048,"byte_end":1040067,"line_start":177,"line_end":177,"column_start":12,"column_end":31},"name":"linear_to_canonical","qualname":"<Permutation>::linear_to_canonical","value":"fn (&self, q: &mut Permutation) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the canonical form of the permutation self and stores it in the output argument q.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4630},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":1040354,"byte_end":1040373,"line_start":182,"line_end":182,"column_start":12,"column_end":31},"name":"canonical_to_linear","qualname":"<Permutation>::canonical_to_linear","value":"fn (&self, p: &mut Permutation) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function converts the self permutation in canonical form back into linear form storing it in the output argument p.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4631},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":1040828,"byte_end":1040838,"line_start":188,"line_end":188,"column_start":12,"column_end":22},"name":"inversions","qualname":"<Permutation>::inversions","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" This function counts the number of inversions in the self permutation. An inversion is any pair of elements that are not in order. For example, the\n permutation 2031 has three inversions, corresponding to the pairs (2,0) (2,1) and (3,1). The identity permutation has no inversions.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4632},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":1041031,"byte_end":1041044,"line_start":193,"line_end":193,"column_start":12,"column_end":25},"name":"linear_cycles","qualname":"<Permutation>::linear_cycles","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" This function counts the number of cycles in the self permutation, given in linear form.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4633},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":1041243,"byte_end":1041259,"line_start":198,"line_end":198,"column_start":12,"column_end":28},"name":"canonical_cycles","qualname":"<Permutation>::canonical_cycles","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" This function counts the number of cycles in the self permutation, given in canonical form.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":4643},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/polynomial.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"polynomial","qualname":"::types::polynomial","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/polynomial.rs","parent":null,"children":[{"krate":0,"index":4644},{"krate":0,"index":4645},{"krate":0,"index":4646},{"krate":0,"index":4648},{"krate":0,"index":4651},{"krate":0,"index":4653}],"decl_id":null,"docs":"#General Polynomial Equations","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4646},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/polynomial.rs","byte_start":1042864,"byte_end":1042875,"line_start":15,"line_end":15,"column_start":12,"column_end":23},"name":"PolyComplex","qualname":"::types::polynomial::PolyComplex","value":"PolyComplex {  }","parent":null,"children":[{"krate":0,"index":4647}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4649},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/polynomial.rs","byte_start":1043328,"byte_end":1043331,"line_start":25,"line_end":25,"column_start":12,"column_end":15},"name":"new","qualname":"<PolyComplex>::new","value":"fn (n: usize) -> Option<PolyComplex>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates space for a gsl_poly_complex_workspace struct and a workspace suitable for solving a polynomial with n coefficients\n using the routine gsl_poly_complex_solve.\n \n The function returns a pointer to the newly allocated gsl_poly_complex_workspace if no errors were detected, and a null pointer in the case\n of error.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4650},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/polynomial.rs","byte_start":1044669,"byte_end":1044674,"line_start":46,"line_end":46,"column_start":12,"column_end":17},"name":"solve","qualname":"<PolyComplex>::solve","value":"fn (&mut self, a: &[f64], z: &mut [f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the roots of the general polynomial P(x) = a_0 + a_1 x + a_2 x^2 + ... + a_{n-1} x^{n-1} using balanced-QR reduction\n of the companion matrix. The parameter n specifies the length of the coefficient array. The coefficient of the highest order term must be\n non-zero. The function requires a workspace w of the appropriate size. The n-1 roots are returned in the packed complex array z of length\n 2(n-1), alternating real and imaginary parts.\n \n The function returns Success if all the roots are found. If the QR reduction does not converge, the error handler is invoked with an error\n code of Failed. Note that due to finite precision, roots of higher multiplicity are returned as a cluster of simple roots with reduced\n accuracy. The solution of polynomials with higher-order roots requires specialized algorithms that take the multiplicity structure into\n account (see e.g. Z. Zeng, Algorithm 835, ACM Transactions on Mathematical Software, Volume 30, Issue 2 (2004), pp 218–236).\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":4658},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/qrng.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"qrng","qualname":"::types::qrng","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/qrng.rs","parent":null,"children":[{"krate":0,"index":4659},{"krate":0,"index":4660},{"krate":0,"index":4661},{"krate":0,"index":4662},{"krate":0,"index":4663},{"krate":0,"index":4666},{"krate":0,"index":4675},{"krate":0,"index":4677},{"krate":0,"index":4679},{"krate":0,"index":7047},{"krate":0,"index":7050},{"krate":0,"index":7049},{"krate":0,"index":4684},{"krate":0,"index":4689}],"decl_id":null,"docs":"#Quasi-Random Sequences","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4663},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/qrng.rs","byte_start":1046608,"byte_end":1046612,"line_start":26,"line_end":26,"column_start":12,"column_end":16},"name":"QRng","qualname":"::types::qrng::QRng","value":"QRng {  }","parent":null,"children":[{"krate":0,"index":4664},{"krate":0,"index":4665}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4667},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/qrng.rs","byte_start":1047002,"byte_end":1047005,"line_start":35,"line_end":35,"column_start":12,"column_end":15},"name":"new","qualname":"<QRng>::new","value":"fn (t: &QRngType, d: u32) -> Option<QRng>","parent":null,"children":[],"decl_id":null,"docs":" This function returns a pointer to a newly-created instance of a quasi-random sequence generator of type T and dimension d. If\n there is insufficient memory to create the generator then the function returns a null pointer and the error handler is invoked\n with an error code of ::NoMem.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4668},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/qrng.rs","byte_start":1047505,"byte_end":1047509,"line_start":50,"line_end":50,"column_start":12,"column_end":16},"name":"init","qualname":"<QRng>::init","value":"fn (&mut self) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function reinitializes the generator self to its starting point. Note that quasi-random sequences do not use a seed and always\n produce the same set of values.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4669},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/qrng.rs","byte_start":1047817,"byte_end":1047820,"line_start":56,"line_end":56,"column_start":12,"column_end":15},"name":"get","qualname":"<QRng>::get","value":"fn (&self, x: &mut [f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function stores the next point from the sequence generator self in the array x. The space available for x must match the\n dimension of the generator. The point x will lie in the range 0 < x_i < 1 for each x_i.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4670},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/qrng.rs","byte_start":1048030,"byte_end":1048034,"line_start":61,"line_end":61,"column_start":12,"column_end":16},"name":"name","qualname":"<QRng>::name","value":"fn (&self) -> Option<String>","parent":null,"children":[],"decl_id":null,"docs":" This function returns a pointer to the name of the generator.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4671},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/qrng.rs","byte_start":1048401,"byte_end":1048405,"line_start":72,"line_end":72,"column_start":12,"column_end":16},"name":"size","qualname":"<QRng>::size","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" These functions return a pointer to the state of generator r and its size.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4672},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/qrng.rs","byte_start":1048571,"byte_end":1048576,"line_start":77,"line_end":77,"column_start":12,"column_end":17},"name":"state","qualname":"<QRng>::state","value":"fn <'r> (&'r mut self) -> &'r mut [c_char]","parent":null,"children":[],"decl_id":null,"docs":" These functions return a pointer to the state of generator r and its size.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4674},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/qrng.rs","byte_start":1049048,"byte_end":1049052,"line_start":88,"line_end":88,"column_start":12,"column_end":16},"name":"copy","qualname":"<QRng>::copy","value":"fn (&self, dest: &mut QRng) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the quasi-random sequence generator src into the pre-existing generator dest, making dest into an exact copy\n of src. The two generators must be of the same type.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":7047},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/qrng.rs","byte_start":1050040,"byte_end":1050048,"line_start":129,"line_end":129,"column_start":12,"column_end":20},"name":"QRngType","qualname":"::types::qrng::QRngType","value":"QRngType {  }","parent":null,"children":[{"krate":0,"index":7048}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4685},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/qrng.rs","byte_start":1050282,"byte_end":1050296,"line_start":136,"line_end":136,"column_start":12,"column_end":26},"name":"niederreiter_2","qualname":"<QRngType>::niederreiter_2","value":"fn () -> QRngType","parent":null,"children":[],"decl_id":null,"docs":" This generator uses the algorithm described in Bratley, Fox, Niederreiter, ACM Trans. Model. Comp. Sim. 2, 195 (1992). It is valid\n up to 12 dimensions.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4686},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/qrng.rs","byte_start":1050609,"byte_end":1050614,"line_start":146,"line_end":146,"column_start":12,"column_end":17},"name":"sobol","qualname":"<QRngType>::sobol","value":"fn () -> QRngType","parent":null,"children":[],"decl_id":null,"docs":" This generator uses the Sobol sequence described in Antonov, Saleev, USSR Comput. Maths. Math. Phys. 19, 252 (1980). It is valid\n up to 40 dimensions.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4687},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/qrng.rs","byte_start":1051029,"byte_end":1051035,"line_start":156,"line_end":156,"column_start":12,"column_end":18},"name":"halton","qualname":"<QRngType>::halton","value":"fn () -> QRngType","parent":null,"children":[],"decl_id":null,"docs":" These generators use the Halton and reverse Halton sequences described in J.H. Halton, Numerische Mathematik 2, 84-90 (1960) and\n B. Vandewoestyne and R. Cools Computational and Applied Mathematics 189, 1&2, 341-361 (2006). They are valid up to 1229 dimensions.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4688},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/qrng.rs","byte_start":1051174,"byte_end":1051187,"line_start":164,"line_end":164,"column_start":12,"column_end":25},"name":"reversehalton","qualname":"<QRngType>::reversehalton","value":"fn () -> QRngType","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":4694},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ran_discrete.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"ran_discrete","qualname":"::types::ran_discrete","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ran_discrete.rs","parent":null,"children":[{"krate":0,"index":4695},{"krate":0,"index":4696},{"krate":0,"index":4697},{"krate":0,"index":4699},{"krate":0,"index":4703},{"krate":0,"index":4705}],"decl_id":null,"docs":"Given K discrete events with different probabilities P[k], produce a random value k consistent with its probability.","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4697},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ran_discrete.rs","byte_start":1054189,"byte_end":1054200,"line_start":25,"line_end":25,"column_start":12,"column_end":23},"name":"RanDiscrete","qualname":"::types::ran_discrete::RanDiscrete","value":"RanDiscrete {  }","parent":null,"children":[{"krate":0,"index":4698}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4700},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ran_discrete.rs","byte_start":1054749,"byte_end":1054752,"line_start":33,"line_end":33,"column_start":12,"column_end":15},"name":"new","qualname":"<RanDiscrete>::new","value":"fn (P: &[f64]) -> Option<RanDiscrete>","parent":null,"children":[],"decl_id":null,"docs":" This function returns a pointer to a structure that contains the lookup table for the discrete random number generator. The array P[] contains the probabilities of the discrete events;\n these array elements must all be positive, but they needn’t add up to one (so you can think of them more generally as “weights”)—the preprocessor will normalize appropriately.\n This return value is used as an argument for the gsl_ran_discrete function below.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4701},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ran_discrete.rs","byte_start":1055145,"byte_end":1055153,"line_start":46,"line_end":46,"column_start":12,"column_end":20},"name":"discrete","qualname":"<RanDiscrete>::discrete","value":"fn (&self, r: &mut Rng) -> usize","parent":null,"children":[],"decl_id":null,"docs":" After the new, above, has been called, you use this function to get the discrete random numbers.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4702},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ran_discrete.rs","byte_start":1055614,"byte_end":1055626,"line_start":52,"line_end":52,"column_start":12,"column_end":24},"name":"discrete_pdf","qualname":"<RanDiscrete>::discrete_pdf","value":"fn (&self, k: usize) -> f64","parent":null,"children":[],"decl_id":null,"docs":" Returns the probability P[k] of observing the variable k. Since P[k] is not stored as part of the lookup table, it must be recomputed; this computation takes O(K),\n so if K is large and you care about the original array P[k] used to create the lookup table, then you should just keep this original array P[k] around.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":4710},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/result.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"result","qualname":"::types::result","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/result.rs","parent":null,"children":[{"krate":0,"index":4711},{"krate":0,"index":7052},{"krate":0,"index":7056},{"krate":0,"index":7055},{"krate":0,"index":4712},{"krate":0,"index":4714},{"krate":0,"index":7058},{"krate":0,"index":7063},{"krate":0,"index":7062},{"krate":0,"index":4716},{"krate":0,"index":4718}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":7052},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/result.rs","byte_start":1056724,"byte_end":1056730,"line_start":10,"line_end":10,"column_start":12,"column_end":18},"name":"Result","qualname":"::types::result::Result","value":"Result { val, err }","parent":null,"children":[{"krate":0,"index":7053},{"krate":0,"index":7054}],"decl_id":null,"docs":" The error handling form of the special functions always calculate an error estimate along with the value of the result.\n Therefore, structures are provided for amalgamating a value and error estimate.\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":7053},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/result.rs","byte_start":1056769,"byte_end":1056772,"line_start":12,"line_end":12,"column_start":9,"column_end":12},"name":"val","qualname":"::types::result::Result::val","value":"f64","parent":{"krate":0,"index":7052},"children":[],"decl_id":null,"docs":" Contains the value.\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":7054},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/result.rs","byte_start":1056852,"byte_end":1056855,"line_start":14,"line_end":14,"column_start":9,"column_end":12},"name":"err","qualname":"::types::result::Result::err","value":"f64","parent":{"krate":0,"index":7052},"children":[],"decl_id":null,"docs":" Contains an estimate of the absolute error in the value.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4715},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/result.rs","byte_start":1056976,"byte_end":1056979,"line_start":24,"line_end":24,"column_start":12,"column_end":15},"name":"new","qualname":"<Result>::new","value":"fn () -> Result","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":7058},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/result.rs","byte_start":1057378,"byte_end":1057387,"line_start":35,"line_end":35,"column_start":12,"column_end":21},"name":"ResultE10","qualname":"::types::result::ResultE10","value":"ResultE10 { val, err, e10 }","parent":null,"children":[{"krate":0,"index":7059},{"krate":0,"index":7060},{"krate":0,"index":7061}],"decl_id":null,"docs":" In some cases, an overflow or underflow can be detected and handled by a function.\n In this case, it may be possible to return a scaling exponent as well as an error/value pair in order to save the result from exceeding the dynamic range of the built-in types.\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":7059},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/result.rs","byte_start":1057426,"byte_end":1057429,"line_start":37,"line_end":37,"column_start":9,"column_end":12},"name":"val","qualname":"::types::result::ResultE10::val","value":"f64","parent":{"krate":0,"index":7058},"children":[],"decl_id":null,"docs":" Contains the value.\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":7060},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/result.rs","byte_start":1057509,"byte_end":1057512,"line_start":39,"line_end":39,"column_start":9,"column_end":12},"name":"err","qualname":"::types::result::ResultE10::err","value":"f64","parent":{"krate":0,"index":7058},"children":[],"decl_id":null,"docs":" Contains an estimate of the absolute error in the value.\n","sig":null,"attributes":[]},{"kind":"Field","id":{"krate":0,"index":7061},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/result.rs","byte_start":1057612,"byte_end":1057615,"line_start":41,"line_end":41,"column_start":9,"column_end":12},"name":"e10","qualname":"::types::result::ResultE10::e10","value":"i32","parent":{"krate":0,"index":7058},"children":[],"decl_id":null,"docs":" Exponent field such that the actual result is obtained as result * 10^(e10).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4719},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/result.rs","byte_start":1057747,"byte_end":1057750,"line_start":51,"line_end":51,"column_start":12,"column_end":15},"name":"new","qualname":"<ResultE10>::new","value":"fn () -> ResultE10","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":4720},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"rng","qualname":"::types::rng","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","parent":null,"children":[{"krate":0,"index":4721},{"krate":0,"index":4722},{"krate":0,"index":4723},{"krate":0,"index":4724},{"krate":0,"index":4726},{"krate":0,"index":4742},{"krate":0,"index":4744},{"krate":0,"index":4746},{"krate":0,"index":7065},{"krate":0,"index":7068},{"krate":0,"index":7067},{"krate":0,"index":4751},{"krate":0,"index":4758},{"krate":0,"index":4763},{"krate":0,"index":4764},{"krate":0,"index":4780},{"krate":0,"index":4788}],"decl_id":null,"docs":"#Random Number Generation","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4724},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1063945,"byte_end":1063948,"line_start":77,"line_end":77,"column_start":12,"column_end":15},"name":"Rng","qualname":"::types::rng::Rng","value":"Rng {  }","parent":null,"children":[{"krate":0,"index":4725}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4727},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1064845,"byte_end":1064848,"line_start":92,"line_end":92,"column_start":12,"column_end":15},"name":"new","qualname":"<Rng>::new","value":"fn (T: &RngType) -> Option<Rng>","parent":null,"children":[],"decl_id":null,"docs":" This function returns a pointer to a newly-created instance of a random number generator of type T. For example, the following code creates an instance of the Tausworthe generator,\n \n ```Rust\n let r = Rng::new(gsl_rng_taus);\n ```\n \n If there is insufficient memory to create the generator then the function returns a null pointer and the error handler is invoked with an error code of GSL_ENOMEM.\n \n The generator is automatically initialized with the default seed, gsl_rng_default_seed. This is zero by default but can be changed either directly or by using the environment variable\n GSL_RNG_SEED (see [`Random number environment variables`](https://www.gnu.org/software/gsl/manual/html_node/Random-number-environment-variables.html#Random-number-environment-variables)).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4728},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1066114,"byte_end":1066117,"line_start":111,"line_end":111,"column_start":12,"column_end":15},"name":"set","qualname":"<Rng>::set","value":"fn (&mut self, s: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function initializes (or ‘seeds’) the random number generator. If the generator is seeded with the same value of s on two different runs, the same stream of random numbers will be generated by successive calls to the routines below.\n If different values of s >= 1 are supplied, then the generated streams of random numbers should be completely different. If the seed s is zero then the standard seed from the original implementation is used instead.\n For example, the original Fortran source code for the ranlux generator used a seed of 314159265, and so choosing s equal to zero reproduces this when using gsl_rng_ranlux.\n \n When using multiple seeds with the same generator, choose seed values greater than zero to avoid collisions with the default setting.\n \n Note that the most generators only accept 32-bit seeds, with higher values being reduced modulo 2^32. For generators with smaller ranges the maximum seed value will typically be lower.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4729},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1066526,"byte_end":1066529,"line_start":117,"line_end":117,"column_start":12,"column_end":15},"name":"get","qualname":"<Rng>::get","value":"fn (&mut self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random integer from the generator r. The minimum and maximum values depend on the algorithm used, but all integers in the range [min,max] are equally likely.\n The values of min and max can be determined using the auxiliary functions gsl_rng_max (r) and gsl_rng_min (r).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4730},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1067135,"byte_end":1067142,"line_start":124,"line_end":124,"column_start":12,"column_end":19},"name":"uniform","qualname":"<Rng>::uniform","value":"fn (&mut self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns a double precision floating point number uniformly distributed in the range [0,1). The range includes 0.0 but excludes 1.0.\n The value is typically obtained by dividing the result of gsl_rng_get(r) by gsl_rng_max(r) + 1.0 in double precision.\n Some generators compute this ratio internally so that they can provide floating point numbers with more than 32 bits of randomness (the maximum number of bits that can be portably represented in a single unsigned long int).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4731},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1067587,"byte_end":1067598,"line_start":131,"line_end":131,"column_start":12,"column_end":23},"name":"uniform_pos","qualname":"<Rng>::uniform_pos","value":"fn (&mut self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns a positive double precision floating point number uniformly distributed in the range (0,1), excluding both 0.0 and 1.0.\n The number is obtained by sampling the generator with the algorithm of gsl_rng_uniform until a non-zero value is obtained.\n You can use this function if you need to avoid a singularity at 0.0.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4732},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1068801,"byte_end":1068812,"line_start":143,"line_end":143,"column_start":12,"column_end":23},"name":"uniform_int","qualname":"<Rng>::uniform_int","value":"fn (&mut self, n: usize) -> usize","parent":null,"children":[],"decl_id":null,"docs":" This function returns a random integer from 0 to n-1 inclusive by scaling down and/or discarding samples from the generator r.\n All integers in the range [0,n-1] are produced with equal probability. For generators with a non-zero minimum value an offset is applied so that zero is returned with the correct probability.\n \n Note that this function is designed for sampling from ranges smaller than the range of the underlying generator. The parameter n must be less than or equal to the range of the generator r.\n If n is larger than the range of the generator then the function calls the error handler with an error code of GSL_EINVAL and returns zero.\n \n In particular, this function is not intended for generating the full range of unsigned integer values [0,2^32-1].\n Instead choose a generator with the maximal integer range and zero minimum value, such as gsl_rng_ranlxd1, gsl_rng_mt19937 or gsl_rng_taus, and sample it directly using gsl_rng_get. The range of each generator can be found using the auxiliary functions described in the next section.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4733},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1069186,"byte_end":1069194,"line_start":154,"line_end":154,"column_start":12,"column_end":20},"name":"get_name","qualname":"<Rng>::get_name","value":"fn (&self) -> String","parent":null,"children":[],"decl_id":null,"docs":" This function returns a pointer to the name of the generator. For example,\n \n ```Rust\n println!(\"r is a '{}' generator\", r.get_name());\n ```\n \n would print something like \"r is a 'taus' generator\".\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4734},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1069483,"byte_end":1069486,"line_start":163,"line_end":163,"column_start":12,"column_end":15},"name":"max","qualname":"<Rng>::max","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" This function returns the largest value that the get function can return.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4735},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1069806,"byte_end":1069809,"line_start":169,"line_end":169,"column_start":12,"column_end":15},"name":"min","qualname":"<Rng>::min","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" This function returns the smallest value that gsl_rng_get can return. Usually this value is zero.\n There are some generators with algorithms that cannot return zero, and for these generators the minimum value is 1.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4736},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1070259,"byte_end":1070264,"line_start":180,"line_end":180,"column_start":12,"column_end":17},"name":"state","qualname":"<Rng>::state","value":"fn <'r, T> (&self) -> &'r mut T","parent":null,"children":[],"decl_id":null,"docs":" This function returns a pointer to the state of generator r. You can use this information to access the state directly. For example, the following code will write the state of a generator to a stream,\n \n ```C\n void * state = gsl_rng_state (r);\n size_t n = gsl_rng_size (r);\n fwrite (state, n, 1, stream);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4739},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1070564,"byte_end":1070568,"line_start":185,"line_end":185,"column_start":12,"column_end":16},"name":"copy","qualname":"<Rng>::copy","value":"fn (&self, other: &mut Rng) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the random number generator src into the pre-existing generator dest, making dest into an exact copy of src. The two generators must be of the same type.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4740},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1071064,"byte_end":1071068,"line_start":196,"line_end":196,"column_start":12,"column_end":16},"name":"size","qualname":"<Rng>::size","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" This function returns the size of the state of generator r. You can use this information to access the state directly. For example, the following code will write the state of a generator to a stream,\n \n ```C\n void * state = gsl_rng_state (r);\n size_t n = gsl_rng_size (r);\n fwrite (state, n, 1, stream);\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4741},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1071187,"byte_end":1071199,"line_start":201,"line_end":201,"column_start":12,"column_end":24},"name":"default_seed","qualname":"<Rng>::default_seed","value":"fn () -> usize","parent":null,"children":[],"decl_id":null,"docs":" Equivalent to DefaultRngSeed\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":7065},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1072054,"byte_end":1072061,"line_start":241,"line_end":241,"column_start":12,"column_end":19},"name":"RngType","qualname":"::types::rng::RngType","value":"RngType {  }","parent":null,"children":[{"krate":0,"index":7066}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4752},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1072158,"byte_end":1072162,"line_start":247,"line_end":247,"column_start":12,"column_end":16},"name":"name","qualname":"<RngType>::name","value":"fn (&self) -> String","parent":null,"children":[],"decl_id":null,"docs":" wrapper for name element\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4753},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1072433,"byte_end":1072436,"line_start":256,"line_end":256,"column_start":12,"column_end":15},"name":"max","qualname":"<RngType>::max","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" wrapper for max element\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4754},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1072631,"byte_end":1072634,"line_start":265,"line_end":265,"column_start":12,"column_end":15},"name":"min","qualname":"<RngType>::min","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" wrapper for min element\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4755},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1072830,"byte_end":1072834,"line_start":274,"line_end":274,"column_start":12,"column_end":16},"name":"size","qualname":"<RngType>::size","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" wrapper for size element\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4756},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1073531,"byte_end":1073542,"line_start":293,"line_end":293,"column_start":12,"column_end":23},"name":"types_setup","qualname":"<RngType>::types_setup","value":"fn () -> Vec<RngType>","parent":null,"children":[],"decl_id":null,"docs":" This function returns a pointer to an array of all the available generator types, terminated by a null pointer.\n The function should be called once at the start of the program, if needed. The following code fragment shows how to iterate over the array of generator types to print the names of the available algorithms,\n \n ```Rust\n let t = RngType::types_setup ();\n \n println!(\"Available generators:\");\n for tmp in t.iter() {\n     println!(\"{}\", tmp.name);\n }\n ```\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4757},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1074935,"byte_end":1074944,"line_start":326,"line_end":326,"column_start":12,"column_end":21},"name":"env_setup","qualname":"<RngType>::env_setup","value":"fn () -> Option<RngType>","parent":null,"children":[],"decl_id":null,"docs":" This function reads the environment variables GSL_RNG_TYPE and GSL_RNG_SEED and uses their values to set the corresponding library variables gsl_rng_default and gsl_rng_default_seed. These global variables are defined as follows,\n \n ```C\n extern const gsl_rng_type *gsl_rng_default\n extern unsigned long int gsl_rng_default_seed\n ```\n \n The environment variable GSL_RNG_TYPE should be the name of a generator, such as taus or mt19937. The environment variable GSL_RNG_SEED should contain the desired seed value.\n It is converted to an unsigned long int using the C library function strtoul.\n \n If you don’t specify a generator for GSL_RNG_TYPE then gsl_rng_mt19937 is used as the default. The initial value of gsl_rng_default_seed is zero.\n See rng example in examples folder for more details.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4763},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1075600,"byte_end":1075607,"line_start":357,"line_end":357,"column_start":8,"column_end":15},"name":"default","qualname":"::types::rng::default","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":4764},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1076389,"byte_end":1076399,"line_start":367,"line_end":367,"column_start":9,"column_end":19},"name":"algorithms","qualname":"::types::rng::algorithms","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","parent":null,"children":[{"krate":0,"index":4765},{"krate":0,"index":4766},{"krate":0,"index":4767},{"krate":0,"index":4768},{"krate":0,"index":4769},{"krate":0,"index":4770},{"krate":0,"index":4771},{"krate":0,"index":4772},{"krate":0,"index":4773},{"krate":0,"index":4774},{"krate":0,"index":4775},{"krate":0,"index":4776},{"krate":0,"index":4777},{"krate":0,"index":4778},{"krate":0,"index":4779}],"decl_id":null,"docs":" The functions described above make no reference to the actual algorithm used. This is deliberate so that you can switch algorithms without having\n to change any of your application source code. The library provides a large number of generators of different types, including simulation quality\n generators, generators provided for compatibility with other libraries and historical generators from the past.\n \n The following generators are recommended for use in simulation. They have extremely long periods, low correlation and pass most statistical tests.\n For the most reliable source of uncorrelated numbers, the second-generation RANLUX generators have the strongest proof of randomness.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4767},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1077814,"byte_end":1077821,"line_start":385,"line_end":385,"column_start":12,"column_end":19},"name":"mt19937","qualname":"::types::rng::algorithms::mt19937","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" The MT19937 generator of Makoto Matsumoto and Takuji Nishimura is a variant of the twisted generalized feedback shift-register algorithm, and\n is known as the “Mersenne Twister” generator. It has a Mersenne prime period of 2^19937 - 1 (about 10^6000) and is equi-distributed in 623 dimensions.\n It has passed the DIEHARD statistical tests. It uses 624 words of state per generator and is comparable in speed to the other generators. The original\n generator used a default seed of 4357 and choosing s equal to zero in gsl_rng_set reproduces this. Later versions switched to 5489 as the default seed,\n you can choose this explicitly via gsl_rng_set instead if you require it.\n \n For more information see,\n \n Makoto Matsumoto and Takuji Nishimura, “Mersenne Twister: A 623-dimensionally equidistributed uniform pseudorandom number generator”. ACM Transactions\n on Modeling and Computer Simulation, Vol. 8, No. 1 (Jan. 1998), Pages 3–30\n \n The generator gsl_rng_mt19937 uses the second revision of the seeding procedure published by the two authors above in 2002. The original seeding\n procedures could cause spurious artifacts for some seed values. They are still available through the alternative generators gsl_rng_mt19937_1999 and\n gsl_rng_mt19937_1998.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4768},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1078798,"byte_end":1078805,"line_start":396,"line_end":396,"column_start":12,"column_end":19},"name":"ranlxs0","qualname":"::types::rng::algorithms::ranlxs0","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" The generator ranlxs0 is a second-generation version of the RANLUX algorithm of Lüscher, which produces “luxury random numbers”. This generator\n provides single precision output (24 bits) at three luxury levels ranlxs0, ranlxs1 and ranlxs2, in increasing order of strength. It uses double-precision\n floating point arithmetic internally and can be significantly faster than the integer version of ranlux, particularly on 64-bit architectures. The period\n of the generator is about 10^171. The algorithm has mathematically proven properties and can provide truly decorrelated numbers at a known level of\n randomness. The higher luxury levels provide increased decorrelation between samples as an additional safety margin.\n \n Note that the range of allowed seeds for this generator is [0,2^31-1]. Higher seed values are wrapped modulo 2^31.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4769},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1079782,"byte_end":1079789,"line_start":407,"line_end":407,"column_start":12,"column_end":19},"name":"ranlxs1","qualname":"::types::rng::algorithms::ranlxs1","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" The generator ranlxs0 is a second-generation version of the RANLUX algorithm of Lüscher, which produces “luxury random numbers”. This generator\n provides single precision output (24 bits) at three luxury levels ranlxs0, ranlxs1 and ranlxs2, in increasing order of strength. It uses double-precision\n floating point arithmetic internally and can be significantly faster than the integer version of ranlux, particularly on 64-bit architectures. The period\n of the generator is about 10^171. The algorithm has mathematically proven properties and can provide truly decorrelated numbers at a known level of\n randomness. The higher luxury levels provide increased decorrelation between samples as an additional safety margin.\n \n Note that the range of allowed seeds for this generator is [0,2^31-1]. Higher seed values are wrapped modulo 2^31.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4770},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1080766,"byte_end":1080773,"line_start":418,"line_end":418,"column_start":12,"column_end":19},"name":"ranlxs2","qualname":"::types::rng::algorithms::ranlxs2","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" The generator ranlxs0 is a second-generation version of the RANLUX algorithm of Lüscher, which produces “luxury random numbers”. This generator\n provides single precision output (24 bits) at three luxury levels ranlxs0, ranlxs1 and ranlxs2, in increasing order of strength. It uses double-precision\n floating point arithmetic internally and can be significantly faster than the integer version of ranlux, particularly on 64-bit architectures. The period\n of the generator is about 10^171. The algorithm has mathematically proven properties and can provide truly decorrelated numbers at a known level of\n randomness. The higher luxury levels provide increased decorrelation between samples as an additional safety margin.\n \n Note that the range of allowed seeds for this generator is [0,2^31-1]. Higher seed values are wrapped modulo 2^31.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4771},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1081050,"byte_end":1081057,"line_start":424,"line_end":424,"column_start":12,"column_end":19},"name":"ranlxd1","qualname":"::types::rng::algorithms::ranlxd1","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" This generator produces double precision output (48 bits) from the RANLXS generator. The library provides two luxury levels ranlxd1 and ranlxd2,\n in increasing order of strength.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4772},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1081334,"byte_end":1081341,"line_start":430,"line_end":430,"column_start":12,"column_end":19},"name":"ranlxd2","qualname":"::types::rng::algorithms::ranlxd2","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" This generator produces double precision output (48 bits) from the RANLXS generator. The library provides two luxury levels ranlxd1 and ranlxd2,\n in increasing order of strength.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4773},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1082773,"byte_end":1082779,"line_start":446,"line_end":446,"column_start":12,"column_end":18},"name":"ranlux","qualname":"::types::rng::algorithms::ranlux","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" The ranlux generator is an implementation of the original algorithm developed by Lüscher. It uses a lagged-fibonacci-with-skipping algorithm to\n produce “luxury random numbers”. It is a 24-bit generator, originally designed for single-precision IEEE floating point numbers. This\n implementation is based on integer arithmetic, while the second-generation versions RANLXS and RANLXD described above provide floating-point\n implementations which will be faster on many platforms. The period of the generator is about 10^171. The algorithm has mathematically proven\n properties and it can provide truly decorrelated numbers at a known level of randomness. The default level of decorrelation recommended by\n Lüscher is provided by gsl_rng_ranlux, while gsl_rng_ranlux389 gives the highest level of randomness, with all 24 bits decorrelated. Both\n types of generator use 24 words of state per generator.\n \n For more information see,\n \n M. Lüscher, “A portable high-quality random number generator for lattice field theory calculations”, Computer Physics Communications, 79 (1994) 100–110.\n F. James, “RANLUX: A Fortran implementation of the high-quality pseudo-random number generator of Lüscher”, Computer Physics Communications, 79 (1994) 111–114\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4774},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1084210,"byte_end":1084219,"line_start":462,"line_end":462,"column_start":12,"column_end":21},"name":"ranlux389","qualname":"::types::rng::algorithms::ranlux389","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" The ranlux generator is an implementation of the original algorithm developed by Lüscher. It uses a lagged-fibonacci-with-skipping algorithm to\n produce “luxury random numbers”. It is a 24-bit generator, originally designed for single-precision IEEE floating point numbers. This\n implementation is based on integer arithmetic, while the second-generation versions RANLXS and RANLXD described above provide floating-point\n implementations which will be faster on many platforms. The period of the generator is about 10^171. The algorithm has mathematically proven\n properties and it can provide truly decorrelated numbers at a known level of randomness. The default level of decorrelation recommended by\n Lüscher is provided by gsl_rng_ranlux, while gsl_rng_ranlux389 gives the highest level of randomness, with all 24 bits decorrelated. Both\n types of generator use 24 words of state per generator.\n \n For more information see,\n \n M. Lüscher, “A portable high-quality random number generator for lattice field theory calculations”, Computer Physics Communications, 79 (1994) 100–110.\n F. James, “RANLUX: A Fortran implementation of the high-quality pseudo-random number generator of Lüscher”, Computer Physics Communications, 79 (1994) 111–114\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4775},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1085133,"byte_end":1085137,"line_start":480,"line_end":480,"column_start":12,"column_end":16},"name":"cmrg","qualname":"::types::rng::algorithms::cmrg","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" This is a combined multiple recursive generator by L’Ecuyer. Its sequence is,\n \n z_n = (x_n - y_n) mod m_1\n \n where the two underlying generators x_n and y_n are,\n \n x_n = (a_1 x_{n-1} + a_2 x_{n-2} + a_3 x_{n-3}) mod m_1\n y_n = (b_1 y_{n-1} + b_2 y_{n-2} + b_3 y_{n-3}) mod m_2\n \n with coefficients a_1 = 0, a_2 = 63308, a_3 = -183326, b_1 = 86098, b_2 = 0, b_3 = -539608, and moduli m_1 = 2^31 - 1 = 2147483647 and m_2 = 2145483479.\n \n \n P. L’Ecuyer, “Combined Multiple Recursive Random Number Generators”, Operations Research, 44, 5 (1996), 816–822.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4776},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1085830,"byte_end":1085833,"line_start":493,"line_end":493,"column_start":12,"column_end":15},"name":"mrg","qualname":"::types::rng::algorithms::mrg","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" This is a fifth-order multiple recursive generator by L’Ecuyer, Blouin and Coutre. Its sequence is,\n \n x_n = (a_1 x_{n-1} + a_5 x_{n-5}) mod m\n \n with a_1 = 107374182, a_2 = a_3 = a_4 = 0, a_5 = 104480 and m = 2^31 - 1.\n \n The period of this generator is about 10^46. It uses 5 words of state per generator. More information can be found in the following paper,\n \n P. L’Ecuyer, F. Blouin, and R. Coutre, “A search for good multiple recursive random number generators”, ACM Transactions on Modeling and Computer Simulation 3, 87–98 (1993).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4777},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1087262,"byte_end":1087266,"line_start":519,"line_end":519,"column_start":12,"column_end":16},"name":"taus","qualname":"::types::rng::algorithms::taus","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" This is a maximally equidistributed combined Tausworthe generator by L’Ecuyer. The sequence is,\n \n x_n = (s1_n ^^ s2_n ^^ s3_n) \n \n where,\n \n s1_{n+1} = (((s1_n&4294967294)<<12)^^(((s1_n<<13)^^s1_n)>>19))\n s2_{n+1} = (((s2_n&4294967288)<< 4)^^(((s2_n<< 2)^^s2_n)>>25))\n s3_{n+1} = (((s3_n&4294967280)<<17)^^(((s3_n<< 3)^^s3_n)>>11))\n \n computed modulo 2^32. In the formulas above ^^ denotes “exclusive-or”. Note that the algorithm relies on the properties of 32-bit\n unsigned integers and has been implemented using a bitmask of 0xFFFFFFFF to make it work on 64 bit machines.\n \n The period of this generator is 2^88 (about 10^26). It uses 3 words of state per generator. For more information see,\n \n P. L’Ecuyer, “Maximally Equidistributed Combined Tausworthe Generators”, Mathematics of Computation, 65, 213 (1996), 203–213.\n \n The generator gsl_rng_taus2 uses the same algorithm as gsl_rng_taus but with an improved seeding procedure described in the paper,\n \n P. L’Ecuyer, “Tables of Maximally Equidistributed Combined LFSR Generators”, Mathematics of Computation, 68, 225 (1999), 261–269\n \n The generator gsl_rng_taus2 should now be used in preference to gsl_rng_taus.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4778},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1088696,"byte_end":1088701,"line_start":545,"line_end":545,"column_start":12,"column_end":17},"name":"taus2","qualname":"::types::rng::algorithms::taus2","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" This is a maximally equidistributed combined Tausworthe generator by L’Ecuyer. The sequence is,\n \n x_n = (s1_n ^^ s2_n ^^ s3_n) \n \n where,\n \n s1_{n+1} = (((s1_n&4294967294)<<12)^^(((s1_n<<13)^^s1_n)>>19))\n s2_{n+1} = (((s2_n&4294967288)<< 4)^^(((s2_n<< 2)^^s2_n)>>25))\n s3_{n+1} = (((s3_n&4294967280)<<17)^^(((s3_n<< 3)^^s3_n)>>11))\n \n computed modulo 2^32. In the formulas above ^^ denotes “exclusive-or”. Note that the algorithm relies on the properties of 32-bit\n unsigned integers and has been implemented using a bitmask of 0xFFFFFFFF to make it work on 64 bit machines.\n \n The period of this generator is 2^88 (about 10^26). It uses 3 words of state per generator. For more information see,\n \n P. L’Ecuyer, “Maximally Equidistributed Combined Tausworthe Generators”, Mathematics of Computation, 65, 213 (1996), 203–213.\n \n The generator gsl_rng_taus2 uses the same algorithm as gsl_rng_taus but with an improved seeding procedure described in the paper,\n \n P. L’Ecuyer, “Tables of Maximally Equidistributed Combined LFSR Generators”, Mathematics of Computation, 68, 225 (1999), 261–269\n \n The generator gsl_rng_taus2 should now be used in preference to gsl_rng_taus.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4779},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1090722,"byte_end":1090727,"line_start":572,"line_end":572,"column_start":12,"column_end":17},"name":"gfsr4","qualname":"::types::rng::algorithms::gfsr4","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" The gfsr4 generator is like a lagged-fibonacci generator, and produces each number as an xor’d sum of four previous values.\n \n r_n = r_{n-A} ^^ r_{n-B} ^^ r_{n-C} ^^ r_{n-D}\n \n Ziff (ref below) notes that “it is now widely known” that two-tap registers (such as R250, which is described below) have serious\n flaws, the most obvious one being the three-point correlation that comes from the definition of the generator. Nice mathematical\n properties can be derived for GFSR’s, and numerics bears out the claim that 4-tap GFSR’s with appropriately chosen offsets are as\n random as can be measured, using the author’s test.\n \n This implementation uses the values suggested the example on p392 of Ziff’s article: A=471, B=1586, C=6988, D=9689.\n \n If the offsets are appropriately chosen (such as the one ones in this implementation), then the sequence is said to be maximal;\n that means that the period is 2^D - 1, where D is the longest lag. (It is one less than 2^D because it is not permitted to have all\n zeros in the ra[] array.) For this implementation with D=9689 that works out to about 10^2917.\n \n Note that the implementation of this generator using a 32-bit integer amounts to 32 parallel implementations of one-bit generators.\n One consequence of this is that the period of this 32-bit generator is the same as for the one-bit generator. Moreover, this\n independence means that all 32-bit patterns are equally likely, and in particular that 0 is an allowed random value. (We are grateful\n to Heiko Bauke for clarifying for us these properties of GFSR random number generators.)\n \n For more information see,\n \n Robert M. Ziff, “Four-tap shift-register-sequence random-number generators”, Computers in Physics, 12(4), Jul/Aug 1998, pp 385–392.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":4780},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1091474,"byte_end":1091478,"line_start":582,"line_end":582,"column_start":9,"column_end":13},"name":"unix","qualname":"::types::rng::unix","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","parent":null,"children":[{"krate":0,"index":4781},{"krate":0,"index":4782},{"krate":0,"index":4783},{"krate":0,"index":4784},{"krate":0,"index":4785},{"krate":0,"index":4786},{"krate":0,"index":4787}],"decl_id":null,"docs":" The standard Unix random number generators rand, random and rand48 are provided as part of GSL. Although these generators are widely\n available individually often they aren’t all available on the same platform. This makes it difficult to write portable code using them\n and so we have included the complete set of Unix generators in GSL for convenience. Note that these generators don’t produce high-quality\n randomness and aren’t suitable for work requiring accurate statistics. However, if you won’t be measuring statistical quantities and just\n want to introduce some variation into your program then these generators are quite acceptable.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4783},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1091827,"byte_end":1091831,"line_start":592,"line_end":592,"column_start":12,"column_end":16},"name":"rand","qualname":"::types::rng::unix::rand","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" This is the BSD rand generator. Its sequence is\n \n x_{n+1} = (a x_n + c) mod m\n \n with a = 1103515245, c = 12345 and m = 2^31. The seed specifies the initial value, x_1. The period of this generator is 2^31, and it\n uses 1 word of storage per generator.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4784},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1093332,"byte_end":1093342,"line_start":614,"line_end":614,"column_start":12,"column_end":22},"name":"random_bsd","qualname":"::types::rng::unix::random_bsd","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" These generators implement the random family of functions, a set of linear feedback shift register generators originally used in BSD\n Unix. There are several versions of random in use today: the original BSD version (e.g. on SunOS4), a libc5 version (found on older\n GNU/Linux systems) and a glibc2 version. Each version uses a different seeding procedure, and thus produces different sequences.\n \n The original BSD routines accepted a variable length buffer for the generator state, with longer buffers providing higher-quality\n randomness. The random function implemented algorithms for buffer lengths of 8, 32, 64, 128 and 256 bytes, and the algorithm with the\n largest length that would fit into the user-supplied buffer was used. To support these algorithms additional generators are available\n with the following names,\n \n * gsl_rng_random8_bsd\n * gsl_rng_random32_bsd\n * gsl_rng_random64_bsd\n * gsl_rng_random128_bsd\n * gsl_rng_random256_bsd\n \n where the numeric suffix indicates the buffer length. The original BSD random function used a 128-byte default buffer and so\n gsl_rng_random_bsd has been made equivalent to gsl_rng_random128_bsd. Corresponding versions of the libc5 and glibc2 generators are\n also available, with the names gsl_rng_random8_libc5, gsl_rng_random8_glibc2, etc.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4785},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1094849,"byte_end":1094861,"line_start":636,"line_end":636,"column_start":12,"column_end":24},"name":"random_libc5","qualname":"::types::rng::unix::random_libc5","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" These generators implement the random family of functions, a set of linear feedback shift register generators originally used in BSD\n Unix. There are several versions of random in use today: the original BSD version (e.g. on SunOS4), a libc5 version (found on older\n GNU/Linux systems) and a glibc2 version. Each version uses a different seeding procedure, and thus produces different sequences.\n \n The original BSD routines accepted a variable length buffer for the generator state, with longer buffers providing higher-quality\n randomness. The random function implemented algorithms for buffer lengths of 8, 32, 64, 128 and 256 bytes, and the algorithm with the\n largest length that would fit into the user-supplied buffer was used. To support these algorithms additional generators are available\n with the following names,\n \n * gsl_rng_random8_bsd\n * gsl_rng_random32_bsd\n * gsl_rng_random64_bsd\n * gsl_rng_random128_bsd\n * gsl_rng_random256_bsd\n \n where the numeric suffix indicates the buffer length. The original BSD random function used a 128-byte default buffer and so\n gsl_rng_random_bsd has been made equivalent to gsl_rng_random128_bsd. Corresponding versions of the libc5 and glibc2 generators are\n also available, with the names gsl_rng_random8_libc5, gsl_rng_random8_glibc2, etc.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4786},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1096370,"byte_end":1096382,"line_start":658,"line_end":658,"column_start":12,"column_end":24},"name":"random_glic2","qualname":"::types::rng::unix::random_glic2","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" These generators implement the random family of functions, a set of linear feedback shift register generators originally used in BSD\n Unix. There are several versions of random in use today: the original BSD version (e.g. on SunOS4), a libc5 version (found on older\n GNU/Linux systems) and a glibc2 version. Each version uses a different seeding procedure, and thus produces different sequences.\n \n The original BSD routines accepted a variable length buffer for the generator state, with longer buffers providing higher-quality\n randomness. The random function implemented algorithms for buffer lengths of 8, 32, 64, 128 and 256 bytes, and the algorithm with the\n largest length that would fit into the user-supplied buffer was used. To support these algorithms additional generators are available\n with the following names,\n \n * gsl_rng_random8_bsd\n * gsl_rng_random32_bsd\n * gsl_rng_random64_bsd\n * gsl_rng_random128_bsd\n * gsl_rng_random256_bsd\n \n where the numeric suffix indicates the buffer length. The original BSD random function used a 128-byte default buffer and so\n gsl_rng_random_bsd has been made equivalent to gsl_rng_random128_bsd. Corresponding versions of the libc5 and glibc2 generators are\n also available, with the names gsl_rng_random8_libc5, gsl_rng_random8_glibc2, etc.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4787},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1097372,"byte_end":1097378,"line_start":671,"line_end":671,"column_start":12,"column_end":18},"name":"rand48","qualname":"::types::rng::unix::rand48","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" This is the Unix rand48 generator. Its sequence is\n \n x_{n+1} = (a x_n + c) mod m\n defined on 48-bit unsigned integers with a = 25214903917, c = 11 and m = 2^48. The seed specifies the upper 32 bits of the initial\n value, x_1, with the lower 16 bits set to 0x330E. The function gsl_rng_get returns the upper 32 bits from each term of the sequence.\n This does not have a direct parallel in the original rand48 functions, but forcing the result to type long int reproduces the output\n of mrand48. The function gsl_rng_uniform uses the full 48 bits of internal state to return the double precision number x_n/m, which\n is equivalent to the function drand48. Note that some versions of the GNU C Library contained a bug in mrand48 function which caused\n it to produce different results (only the lower 16-bits of the return value were set).\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":4788},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1098482,"byte_end":1098487,"line_start":686,"line_end":686,"column_start":9,"column_end":14},"name":"other","qualname":"::types::rng::other","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","parent":null,"children":[{"krate":0,"index":4789},{"krate":0,"index":4790},{"krate":0,"index":4791},{"krate":0,"index":4792},{"krate":0,"index":4793},{"krate":0,"index":4794},{"krate":0,"index":4795},{"krate":0,"index":4796},{"krate":0,"index":4797},{"krate":0,"index":4798},{"krate":0,"index":4799},{"krate":0,"index":4800},{"krate":0,"index":4801},{"krate":0,"index":4802},{"krate":0,"index":4803},{"krate":0,"index":4804},{"krate":0,"index":4805},{"krate":0,"index":4806},{"krate":0,"index":4807},{"krate":0,"index":4808},{"krate":0,"index":4809},{"krate":0,"index":4810},{"krate":0,"index":4811},{"krate":0,"index":4812}],"decl_id":null,"docs":" ##Other random number generators\n \n The generators in this section are provided for compatibility with existing libraries. If you are converting an existing program to use GSL then \n you can select these generators to check your new implementation against the original one, using the same random number generator. After verifying \n that your new program reproduces the original results you can then switch to a higher-quality generator.\n \n Note that most of the generators in this section are based on single linear congruence relations, which are the least sophisticated type of generator. \n In particular, linear congruences have poor properties when used with a non-prime modulus, as several of these routines do (e.g. with a power of two modulus, \n 2^31 or 2^32). This leads to periodicity in the least significant bits of each number, with only the higher bits having any randomness. \n Thus if you want to produce a random bitstream it is best to avoid using the least significant bits.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4791},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1099901,"byte_end":1099905,"line_start":704,"line_end":704,"column_start":12,"column_end":16},"name":"ranf","qualname":"::types::rng::other::ranf","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" This is the CRAY random number generator RANF. Its sequence is\n \n x_{n+1} = (a x_n) mod m\n defined on 48-bit unsigned integers with a = 44485709377909 and m = 2^48. The seed specifies the lower 32 bits of the initial value, x_1, with the lowest bit set to prevent the seed taking an even value. The upper 16 bits of x_1 are set to 0. A consequence of this procedure is that the pairs of seeds 2 and 3, 4 and 5, etc. produce the same sequences.\n \n The generator compatible with the CRAY MATHLIB routine RANF. It produces double precision floating point numbers which should be identical to those from the original RANF.\n \n There is a subtlety in the implementation of the seeding. The initial state is reversed through one step, by multiplying by the modular inverse of a mod m. This is done for compatibility with the original CRAY implementation.\n \n Note that you can only seed the generator with integers up to 2^32, while the original CRAY implementation uses non-portable wide integers which can cover all 2^48 states of the generator.\n \n The function gsl_rng_get returns the upper 32 bits from each term of the sequence. The function gsl_rng_uniform uses the full 48 bits to return the double precision number x_n/m.\n \n The period of this generator is 2^46.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4792},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1100235,"byte_end":1100241,"line_start":710,"line_end":710,"column_start":12,"column_end":18},"name":"ranmar","qualname":"::types::rng::other::ranmar","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" This is the RANMAR lagged-fibonacci generator of Marsaglia, Zaman and Tsang. It is a 24-bit generator, originally designed for single-precision IEEE floating point numbers. \n It was included in the CERNLIB high-energy physics library.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4793},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1100851,"byte_end":1100855,"line_start":722,"line_end":722,"column_start":12,"column_end":16},"name":"r250","qualname":"::types::rng::other::r250","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" This is the shift-register generator of Kirkpatrick and Stoll. The sequence is based on the recurrence\n \n x_n = x_{n-103} ^^ x_{n-250}\n where ^^ denotes “exclusive-or”, defined on 32-bit words. The period of this generator is about 2^250 and it uses 250 words of state per generator.\n \n For more information see,\n \n S. Kirkpatrick and E. Stoll, “A very fast shift-register sequence random number generator”, Journal of Computational Physics, 40, 517–526 (1981)\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4794},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1101453,"byte_end":1101458,"line_start":732,"line_end":732,"column_start":12,"column_end":17},"name":"tt800","qualname":"::types::rng::other::tt800","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" This is an earlier version of the twisted generalized feedback shift-register generator, and has been superseded by the development of MT19937. However, it is\n still an acceptable generator in its own right. It has a period of 2^800 and uses 33 words of storage per generator.\n \n For more information see,\n \n Makoto Matsumoto and Yoshiharu Kurita, “Twisted GFSR Generators II”, ACM Transactions on Modelling and Computer Simulation, Vol. 4, No. 3, 1994, pages 254–266.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4795},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1101825,"byte_end":1101828,"line_start":741,"line_end":741,"column_start":12,"column_end":15},"name":"vax","qualname":"::types::rng::other::vax","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" This is the VAX generator MTH$RANDOM. Its sequence is,\n \n x_{n+1} = (a x_n + c) mod m\n \n with a = 69069, c = 1 and m = 2^32. The seed specifies the initial value, x_1. The period of this generator is 2^32 and it uses 1 word of storage per generator.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4796},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1102146,"byte_end":1102156,"line_start":750,"line_end":750,"column_start":12,"column_end":22},"name":"transputer","qualname":"::types::rng::other::transputer","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" This is the random number generator from the INMOS Transputer Development system. Its sequence is,\n \n x_{n+1} = (a x_n) mod m\n \n with a = 1664525 and m = 2^32. The seed specifies the initial value, x_1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4797},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1102527,"byte_end":1102532,"line_start":759,"line_end":759,"column_start":12,"column_end":17},"name":"randu","qualname":"::types::rng::other::randu","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" This is the IBM RANDU generator. Its sequence is\n \n x_{n+1} = (a x_n) mod m\n \n with a = 65539 and m = 2^31. The seed specifies the initial value, x_1. The period of this generator was only 2^29. It has become a textbook example of a poor generator.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4798},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1103412,"byte_end":1103418,"line_start":774,"line_end":774,"column_start":12,"column_end":18},"name":"minstd","qualname":"::types::rng::other::minstd","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" This is Park and Miller’s “minimal standard” MINSTD generator, a simple linear congruence which takes care to avoid the major pitfalls of such algorithms. Its sequence is,\n \n x_{n+1} = (a x_n) mod m\n \n with a = 16807 and m = 2^31 - 1 = 2147483647. The seed specifies the initial value, x_1. The period of this generator is about 2^31.\n \n This generator was used in the IMSL Library (subroutine RNUN) and in MATLAB (the RAND function) in the past. It is also sometimes known by the acronym \"GGL\" (I'm not sure what that stands for).\n \n For more information see,\n \n Park and Miller, \"Random Number Generators: Good ones are hard to find\", Communications of the ACM, October 1988, Volume 31, No 10, pages 1192–1201.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4799},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1103721,"byte_end":1103724,"line_start":780,"line_end":780,"column_start":12,"column_end":15},"name":"uni","qualname":"::types::rng::other::uni","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" This is a reimplementation of the 16-bit SLATEC random number generator RUNIF. A generalization of the generator to 32 bits is provided by gsl_rng_uni32.\n The original source code is available from NETLIB.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4800},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1104024,"byte_end":1104029,"line_start":786,"line_end":786,"column_start":12,"column_end":17},"name":"uni32","qualname":"::types::rng::other::uni32","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" This is a reimplementation of the 16-bit SLATEC random number generator RUNIF. A generalization of the generator to 32 bits is provided by gsl_rng_uni32.\n The original source code is available from NETLIB.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4801},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1104233,"byte_end":1104239,"line_start":791,"line_end":791,"column_start":12,"column_end":18},"name":"slatec","qualname":"::types::rng::other::slatec","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" This is the SLATEC random number generator RAND. It is ancient. The original source code is available from NETLIB.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4802},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1104727,"byte_end":1104730,"line_start":803,"line_end":803,"column_start":12,"column_end":15},"name":"zuf","qualname":"::types::rng::other::zuf","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" This is the ZUFALL lagged Fibonacci series generator of Peterson. Its sequence is,\n \n t = u_{n-273} + u_{n-607}\n u_n  = t - floor(t)\n \n The original source code is available from NETLIB. For more information see,\n \n W. Petersen, “Lagged Fibonacci Random Number Generators for the NEC SX-3”, International Journal of High Speed Computing (1994).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4803},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1105084,"byte_end":1105093,"line_start":812,"line_end":812,"column_start":12,"column_end":21},"name":"knuthran2","qualname":"::types::rng::other::knuthran2","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" This is a second-order multiple recursive generator described by Knuth in Seminumerical Algorithms, 3rd Ed., page 108. Its sequence is,\n \n x_n = (a_1 x_{n-1} + a_2 x_{n-2}) mod m\n \n with a_1 = 271828183, a_2 = 314159269, and m = 2^31 - 1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4804},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1105520,"byte_end":1105532,"line_start":819,"line_end":819,"column_start":12,"column_end":24},"name":"knuthran2002","qualname":"::types::rng::other::knuthran2002","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" This is a second-order multiple recursive generator described by Knuth in Seminumerical Algorithms, 3rd Ed., Section 3.6. Knuth provides\n its C code. The updated routine gsl_rng_knuthran2002 is from the revised 9th printing and corrects some weaknesses in the earlier version,\n which is implemented as gsl_rng_knuthran.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4805},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1105962,"byte_end":1105970,"line_start":826,"line_end":826,"column_start":12,"column_end":20},"name":"knuthran","qualname":"::types::rng::other::knuthran","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" This is a second-order multiple recursive generator described by Knuth in Seminumerical Algorithms, 3rd Ed., Section 3.6. Knuth provides\n its C code. The updated routine gsl_rng_knuthran2002 is from the revised 9th printing and corrects some weaknesses in the earlier version,\n which is implemented as gsl_rng_knuthran.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4806},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1106546,"byte_end":1106554,"line_start":837,"line_end":837,"column_start":12,"column_end":20},"name":"borosh13","qualname":"::types::rng::other::borosh13","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" This multiplicative generator is taken from Knuth’s Seminumerical Algorithms, 3rd Ed., pages 106–108. Their sequence is,\n \n x_{n+1} = (a x_n) mod m\n \n where the seed specifies the initial value, x_1. The parameters a and m are as follows, Borosh-Niederreiter: a = 1812433253,\n m = 2^32, Fishman18: a = 62089911, m = 2^31 - 1, Fishman20: a = 48271, m = 2^31 - 1, L’Ecuyer: a = 40692, m = 2^31 - 249,\n Waterman: a = 1566083941, m = 2^32.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4807},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1107130,"byte_end":1107139,"line_start":848,"line_end":848,"column_start":12,"column_end":21},"name":"fishman18","qualname":"::types::rng::other::fishman18","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" This multiplicative generator is taken from Knuth’s Seminumerical Algorithms, 3rd Ed., pages 106–108. Their sequence is,\n \n x_{n+1} = (a x_n) mod m\n \n where the seed specifies the initial value, x_1. The parameters a and m are as follows, Borosh-Niederreiter: a = 1812433253,\n m = 2^32, Fishman18: a = 62089911, m = 2^31 - 1, Fishman20: a = 48271, m = 2^31 - 1, L’Ecuyer: a = 40692, m = 2^31 - 249,\n Waterman: a = 1566083941, m = 2^32.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4808},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1107716,"byte_end":1107725,"line_start":859,"line_end":859,"column_start":12,"column_end":21},"name":"fishman20","qualname":"::types::rng::other::fishman20","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" This multiplicative generator is taken from Knuth’s Seminumerical Algorithms, 3rd Ed., pages 106–108. Their sequence is,\n \n x_{n+1} = (a x_n) mod m\n \n where the seed specifies the initial value, x_1. The parameters a and m are as follows, Borosh-Niederreiter: a = 1812433253,\n m = 2^32, Fishman18: a = 62089911, m = 2^31 - 1, Fishman20: a = 48271, m = 2^31 - 1, L’Ecuyer: a = 40692, m = 2^31 - 249,\n Waterman: a = 1566083941, m = 2^32.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4809},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1108302,"byte_end":1108311,"line_start":870,"line_end":870,"column_start":12,"column_end":21},"name":"lecuyer21","qualname":"::types::rng::other::lecuyer21","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" This multiplicative generator is taken from Knuth’s Seminumerical Algorithms, 3rd Ed., pages 106–108. Their sequence is,\n \n x_{n+1} = (a x_n) mod m\n \n where the seed specifies the initial value, x_1. The parameters a and m are as follows, Borosh-Niederreiter: a = 1812433253,\n m = 2^32, Fishman18: a = 62089911, m = 2^31 - 1, Fishman20: a = 48271, m = 2^31 - 1, L’Ecuyer: a = 40692, m = 2^31 - 249,\n Waterman: a = 1566083941, m = 2^32.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4810},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1108888,"byte_end":1108898,"line_start":881,"line_end":881,"column_start":12,"column_end":22},"name":"waterman14","qualname":"::types::rng::other::waterman14","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" This multiplicative generator is taken from Knuth’s Seminumerical Algorithms, 3rd Ed., pages 106–108. Their sequence is,\n \n x_{n+1} = (a x_n) mod m\n \n where the seed specifies the initial value, x_1. The parameters a and m are as follows, Borosh-Niederreiter: a = 1812433253,\n m = 2^32, Fishman18: a = 62089911, m = 2^31 - 1, Fishman20: a = 48271, m = 2^31 - 1, L’Ecuyer: a = 40692, m = 2^31 - 249,\n Waterman: a = 1566083941, m = 2^32.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4811},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1109328,"byte_end":1109337,"line_start":890,"line_end":890,"column_start":12,"column_end":21},"name":"fishman2x","qualname":"::types::rng::other::fishman2x","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" This is the L’Ecuyer–Fishman random number generator. It is taken from Knuth’s Seminumerical Algorithms, 3rd Ed., page 108. Its sequence is,\n \n z_{n+1} = (x_n - y_n) mod m\n \n with m = 2^31 - 1. x_n and y_n are given by the fishman20 and lecuyer21 algorithms. The seed specifies the initial value, x_1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":4812},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1109693,"byte_end":1109700,"line_start":899,"line_end":899,"column_start":12,"column_end":19},"name":"coveyou","qualname":"::types::rng::other::coveyou","value":"fn () -> RngType","parent":null,"children":[],"decl_id":null,"docs":" This is the Coveyou random number generator. It is taken from Knuth’s Seminumerical Algorithms, 3rd Ed., Section 3.2.2. Its sequence is,\n \n x_{n+1} = (x_n (x_n + 1)) mod m\n \n with m = 2^32. The seed specifies the initial value, x_1.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":4813},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"roots","qualname":"::types::roots","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","parent":null,"children":[{"krate":0,"index":4814},{"krate":0,"index":4815},{"krate":0,"index":4817},{"krate":0,"index":4822},{"krate":0,"index":4826},{"krate":0,"index":4827},{"krate":0,"index":4829},{"krate":0,"index":4837},{"krate":0,"index":4839},{"krate":0,"index":4841},{"krate":0,"index":4846},{"krate":0,"index":4850},{"krate":0,"index":4851},{"krate":0,"index":4853},{"krate":0,"index":4859}],"decl_id":null,"docs":"# One dimensional Root-Finding","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4815},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1112729,"byte_end":1112744,"line_start":54,"line_end":54,"column_start":12,"column_end":27},"name":"RootFSolverType","qualname":"::types::roots::RootFSolverType","value":"RootFSolverType {  }","parent":null,"children":[{"krate":0,"index":4816}],"decl_id":null,"docs":" The root bracketing algorithms described in this section require an initial interval which is\n guaranteed to contain a root—if a and b are the endpoints of the interval then f (a) must\n differ in sign from f (b). This ensures that the function crosses zero at least once in the\n interval. If a valid initial interval is used then these algorithm cannot fail, provided the\n function is well-behaved.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4823},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1114003,"byte_end":1114012,"line_start":86,"line_end":86,"column_start":12,"column_end":21},"name":"bisection","qualname":"<RootFSolverType>::bisection","value":"fn () -> RootFSolverType","parent":null,"children":[],"decl_id":null,"docs":" The bisection algorithm is the simplest method of bracketing the roots of a function.\n It is the slowest algorithm provided by the library, with linear convergence.\n On each iteration, the interval is bisected and the value of the function at the midpoint\n is calculated. The sign of this value is used to determine which half of the interval does\n not contain a root. That half is discarded to give a new, smaller interval containing\n the root. This procedure can be continued indefinitely until the interval is sufficiently\n small.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4824},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1114953,"byte_end":1114958,"line_start":102,"line_end":102,"column_start":12,"column_end":17},"name":"brent","qualname":"<RootFSolverType>::brent","value":"fn () -> RootFSolverType","parent":null,"children":[],"decl_id":null,"docs":" The false position algorithm is a method of finding roots based on linear interpolation.\n Its convergence is linear, but it is usually faster than bisection.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4825},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1116062,"byte_end":1116070,"line_start":120,"line_end":120,"column_start":12,"column_end":20},"name":"falsepos","qualname":"<RootFSolverType>::falsepos","value":"fn () -> RootFSolverType","parent":null,"children":[],"decl_id":null,"docs":" The Brent-Dekker method (referred to here as Brent’s method) combines an interpo-\n lation strategy with the bisection algorithm. This produces a fast algorithm which is\n still robust.\n On each iteration Brent’s method approximates the function using an interpolating\n curve. On the first iteration this is a linear interpolation of the two endpoints. For\n subsequent iterations the algorithm uses an inverse quadratic fit to the last three\n points, for higher accuracy. The intercept of the interpolating curve with the x-axis\n is taken as a guess for the root. If it lies within the bounds of the current interval\n then the interpolating point is accepted, and used to generate a smaller interval. If\n the interpolating point is not accepted then the algorithm falls back to an ordinary\n bisection step.","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4827},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1116231,"byte_end":1116242,"line_start":127,"line_end":127,"column_start":12,"column_end":23},"name":"RootFSolver","qualname":"::types::roots::RootFSolver","value":"RootFSolver {  }","parent":null,"children":[{"krate":0,"index":4828}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4830},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1116599,"byte_end":1116602,"line_start":137,"line_end":137,"column_start":12,"column_end":15},"name":"new","qualname":"<RootFSolver>::new","value":"fn (t: &RootFSolverType) -> Option<RootFSolver>","parent":null,"children":[],"decl_id":null,"docs":" This function returns a pointer to a newly allocated instance of a solver of type T.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4831},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1117022,"byte_end":1117025,"line_start":149,"line_end":149,"column_start":12,"column_end":15},"name":"set","qualname":"<RootFSolver>::set","value":"fn (&mut self, f: &mut RootFunction, x_lower: f64, x_upper: f64) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":" This function initializes, or reinitializes, an existing solver s to use the function f and\n the initial search interval [x lower, x upper].\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4832},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1117926,"byte_end":1117933,"line_start":165,"line_end":165,"column_start":12,"column_end":19},"name":"iterate","qualname":"<RootFSolver>::iterate","value":"fn (&mut self) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":" The following function drives the iteration of each algorithm. Each function performs one\n iteration to update the state of any solver of the corresponding type. The same func-\n tion works for all solvers so that different methods can be substituted at runtime without\n modifications to the code.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4833},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1118086,"byte_end":1118090,"line_start":170,"line_end":170,"column_start":12,"column_end":16},"name":"name","qualname":"<RootFSolver>::name","value":"fn (&self) -> String","parent":null,"children":[],"decl_id":null,"docs":" Returns the solver type name.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4834},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1118387,"byte_end":1118391,"line_start":179,"line_end":179,"column_start":12,"column_end":16},"name":"root","qualname":"<RootFSolver>::root","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the current estimate of the root for the solver s.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4835},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1118561,"byte_end":1118568,"line_start":184,"line_end":184,"column_start":12,"column_end":19},"name":"x_lower","qualname":"<RootFSolver>::x_lower","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" These functions return the current bracketing interval for the solver s.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4836},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1118741,"byte_end":1118748,"line_start":189,"line_end":189,"column_start":12,"column_end":19},"name":"x_upper","qualname":"<RootFSolver>::x_upper","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" These functions return the current bracketing interval for the solver s.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4839},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1119520,"byte_end":1119537,"line_start":211,"line_end":211,"column_start":12,"column_end":29},"name":"RootFdfSolverType","qualname":"::types::roots::RootFdfSolverType","value":"RootFdfSolverType {  }","parent":null,"children":[{"krate":0,"index":4840}],"decl_id":null,"docs":" The root polishing algorithms described in this section require an initial guess for the\n location of the root. There is no absolute guarantee of convergence—the function must be\n suitable for this technique and the initial guess must be sufficiently close to the root\n for it to work. When these conditions are satisfied then convergence is quadratic.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4847},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1120447,"byte_end":1120453,"line_start":238,"line_end":238,"column_start":12,"column_end":18},"name":"newton","qualname":"<RootFdfSolverType>::newton","value":"fn () -> RootFdfSolverType","parent":null,"children":[],"decl_id":null,"docs":" Newton’s Method is the standard root-polishing algorithm. The algorithm begins\n with an initial guess for the location of the root. On each iteration, a line tangent to\n the function f is drawn at that position. The point where this line crosses the x-axis\n becomes the new guess.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4848},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1120723,"byte_end":1120729,"line_start":244,"line_end":244,"column_start":12,"column_end":18},"name":"secant","qualname":"<RootFdfSolverType>::secant","value":"fn () -> RootFdfSolverType","parent":null,"children":[],"decl_id":null,"docs":" The secant method is a simplified version of Newton’s method which does not require\n the computation of the derivative on every step.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4849},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1121032,"byte_end":1121042,"line_start":250,"line_end":250,"column_start":12,"column_end":22},"name":"steffenson","qualname":"<RootFdfSolverType>::steffenson","value":"fn () -> RootFdfSolverType","parent":null,"children":[],"decl_id":null,"docs":" The Steffenson Method 1 provides the fastest convergence of all the routines. It com-\n bines the basic Newton algorithm with an Aitken “delta-squared” acceleration.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4851},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1121218,"byte_end":1121231,"line_start":257,"line_end":257,"column_start":12,"column_end":25},"name":"RootFdfSolver","qualname":"::types::roots::RootFdfSolver","value":"RootFdfSolver {  }","parent":null,"children":[{"krate":0,"index":4852}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4854},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1121616,"byte_end":1121619,"line_start":267,"line_end":267,"column_start":12,"column_end":15},"name":"new","qualname":"<RootFdfSolver>::new","value":"fn (t: &RootFdfSolverType) -> Option<RootFdfSolver>","parent":null,"children":[],"decl_id":null,"docs":" This function returns a pointer to a newly allocated instance of a derivative-based\n solver of type T.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4855},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1122040,"byte_end":1122043,"line_start":279,"line_end":279,"column_start":12,"column_end":15},"name":"set","qualname":"<RootFdfSolver>::set","value":"fn (&mut self, f: &mut RootFunctionFdf, root: f64) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":" This function initializes, or reinitializes, an existing solver s to use the function and\n derivative fdf and the initial guess root.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4856},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1122923,"byte_end":1122930,"line_start":295,"line_end":295,"column_start":12,"column_end":19},"name":"iterate","qualname":"<RootFdfSolver>::iterate","value":"fn (&mut self) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":" The following function drives the iteration of each algorithm. Each function performs one\n iteration to update the state of any solver of the corresponding type. The same func-\n tion works for all solvers so that different methods can be substituted at runtime without\n modifications to the code.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4857},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1123085,"byte_end":1123089,"line_start":300,"line_end":300,"column_start":12,"column_end":16},"name":"name","qualname":"<RootFdfSolver>::name","value":"fn (&self) -> String","parent":null,"children":[],"decl_id":null,"docs":" Returns the solver type name.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4858},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1123388,"byte_end":1123392,"line_start":309,"line_end":309,"column_start":12,"column_end":16},"name":"root","qualname":"<RootFdfSolver>::root","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the current estimate of the root for the solver s.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":4861},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/series_acceleration.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"series_acceleration","qualname":"::types::series_acceleration","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/series_acceleration.rs","parent":null,"children":[{"krate":0,"index":4862},{"krate":0,"index":4863},{"krate":0,"index":4864},{"krate":0,"index":4866},{"krate":0,"index":4872},{"krate":0,"index":4874},{"krate":0,"index":4879},{"krate":0,"index":4881},{"krate":0,"index":4887},{"krate":0,"index":4889}],"decl_id":null,"docs":"#Series Acceleration","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4864},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/series_acceleration.rs","byte_start":1126933,"byte_end":1126948,"line_start":56,"line_end":56,"column_start":12,"column_end":27},"name":"LevinUWorkspace","qualname":"::types::series_acceleration::LevinUWorkspace","value":"LevinUWorkspace {  }","parent":null,"children":[{"krate":0,"index":4865}],"decl_id":null,"docs":" Workspace for Levin U Transform with error estimation\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4867},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/series_acceleration.rs","byte_start":1127154,"byte_end":1127157,"line_start":62,"line_end":62,"column_start":12,"column_end":15},"name":"new","qualname":"<LevinUWorkspace>::new","value":"fn (n: usize) -> Option<LevinUWorkspace>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates a workspace for a Levin u-transform of n terms. The size of the workspace is O(2n^2 + 3n).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4868},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/series_acceleration.rs","byte_start":1128106,"byte_end":1128111,"line_start":79,"line_end":79,"column_start":12,"column_end":17},"name":"accel","qualname":"<LevinUWorkspace>::accel","value":"fn (&mut self, array: &[f64], sum_accel: &mut f64, abserr: &mut f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function takes the terms of a series in array of size array_size and computes the extrapolated limit of the series using a\n Levin u-transform. Additional working space must be provided in w. The extrapolated sum is stored in sum_accel, with an estimate\n of the absolute error stored in abserr. The actual term-by-term sum is returned in w->sum_plain. The algorithm calculates the\n truncation error (the difference between two successive extrapolations) and round-off error (propagated from the individual terms)\n to choose an optimal number of terms for the extrapolation. All the terms of the series passed in through array should be non-zero.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4869},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/series_acceleration.rs","byte_start":1128364,"byte_end":1128373,"line_start":85,"line_end":85,"column_start":12,"column_end":21},"name":"sum_plain","qualname":"<LevinUWorkspace>::sum_plain","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4870},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/series_acceleration.rs","byte_start":1128447,"byte_end":1128457,"line_start":89,"line_end":89,"column_start":12,"column_end":22},"name":"terms_used","qualname":"<LevinUWorkspace>::terms_used","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4871},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/series_acceleration.rs","byte_start":1128534,"byte_end":1128538,"line_start":93,"line_end":93,"column_start":12,"column_end":16},"name":"size","qualname":"<LevinUWorkspace>::size","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4879},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/series_acceleration.rs","byte_start":1129591,"byte_end":1129611,"line_start":128,"line_end":128,"column_start":12,"column_end":32},"name":"LevinUTruncWorkspace","qualname":"::types::series_acceleration::LevinUTruncWorkspace","value":"LevinUTruncWorkspace {  }","parent":null,"children":[{"krate":0,"index":4880}],"decl_id":null,"docs":" The following functions perform the same calculation without estimating the errors. They require O(N) storage instead of O(N^2).\n This may be useful for summing many similar series where the size of the error has already been estimated reliably and is not\n expected to change.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4882},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/series_acceleration.rs","byte_start":1129846,"byte_end":1129849,"line_start":134,"line_end":134,"column_start":12,"column_end":15},"name":"new","qualname":"<LevinUTruncWorkspace>::new","value":"fn (n: usize) -> Option<LevinUTruncWorkspace>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates a workspace for a Levin u-transform of n terms, without error estimation. The size of the workspace is O(3n).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4883},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/series_acceleration.rs","byte_start":1130874,"byte_end":1130879,"line_start":152,"line_end":152,"column_start":12,"column_end":17},"name":"accel","qualname":"<LevinUTruncWorkspace>::accel","value":"fn (&mut self, array: &[f64], sum_accel: &mut f64, abserr_trunc: &mut f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function takes the terms of a series in array of size array_size and computes the extrapolated limit of the series using a\n Levin u-transform. Additional working space must be provided in w. The extrapolated sum is stored in sum_accel. The actual\n term-by-term sum is returned in w->sum_plain. The algorithm terminates when the difference between two successive extrapolations\n reaches a minimum or is sufficiently small. The difference between these two values is used as estimate of the error and is stored\n in abserr_trunc. To improve the reliability of the algorithm the extrapolated values are replaced by moving averages when\n calculating the truncation error, smoothing out any fluctuations.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4884},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/series_acceleration.rs","byte_start":1131145,"byte_end":1131154,"line_start":158,"line_end":158,"column_start":12,"column_end":21},"name":"sum_plain","qualname":"<LevinUTruncWorkspace>::sum_plain","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4885},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/series_acceleration.rs","byte_start":1131228,"byte_end":1131238,"line_start":162,"line_end":162,"column_start":12,"column_end":22},"name":"terms_used","qualname":"<LevinUTruncWorkspace>::terms_used","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4886},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/series_acceleration.rs","byte_start":1131315,"byte_end":1131319,"line_start":166,"line_end":166,"column_start":12,"column_end":16},"name":"size","qualname":"<LevinUTruncWorkspace>::size","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":4894},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/siman.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"siman","qualname":"::types::siman","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/siman.rs","parent":null,"children":[{"krate":0,"index":4895},{"krate":0,"index":4896},{"krate":0,"index":4904},{"krate":0,"index":4906},{"krate":0,"index":4908},{"krate":0,"index":4910},{"krate":0,"index":4912},{"krate":0,"index":4913},{"krate":0,"index":4918},{"krate":0,"index":4926}],"decl_id":null,"docs":"# 25 Simulated Annealing","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4896},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/siman.rs","byte_start":1134061,"byte_end":1134073,"line_start":40,"line_end":40,"column_start":12,"column_end":24},"name":"SimAnnealing","qualname":"::types::siman::SimAnnealing","value":"SimAnnealing {  }","parent":null,"children":[{"krate":0,"index":4898},{"krate":0,"index":4899},{"krate":0,"index":4900},{"krate":0,"index":4901},{"krate":0,"index":4902},{"krate":0,"index":4903}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4915},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/siman.rs","byte_start":1134752,"byte_end":1134755,"line_start":63,"line_end":63,"column_start":12,"column_end":15},"name":"new","qualname":"<SimAnnealing<T>>::new","value":"fn (x0_p: T, ef: gsl_siman_Efunc_t<T>, take_step: gsl_siman_step_t<T>, distance: gsl_siman_metric_t<T>, print_pos: Option<gsl_siman_print_t<T>>, params: SimAnnealingParams) -> SimAnnealing<T>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4916},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/siman.rs","byte_start":1140767,"byte_end":1140772,"line_start":227,"line_end":227,"column_start":12,"column_end":17},"name":"solve","qualname":"<SimAnnealing<T>>::solve","value":"fn (&self, rng: &mut ::Rng) -> T","parent":null,"children":[],"decl_id":null,"docs":" This function performs a simulated annealing search through a given space. The space\n is specified by providing the functions Ef and distance. The simulated annealing steps\n are generated using the random number generator `rng` and the function `take_step`.","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4917},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/siman.rs","byte_start":1146861,"byte_end":1146871,"line_start":399,"line_end":399,"column_start":12,"column_end":22},"name":"solve_many","qualname":"<SimAnnealing<T>>::solve_many","value":"fn (&self, rng: &mut ::Rng) -> T","parent":null,"children":[],"decl_id":null,"docs":" Like the function solve, but performs multiple runs and returns the best result.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4918},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/siman.rs","byte_start":1149299,"byte_end":1149317,"line_start":469,"line_end":469,"column_start":12,"column_end":30},"name":"SimAnnealingParams","qualname":"::types::siman::SimAnnealingParams","value":"SimAnnealingParams {  }","parent":null,"children":[{"krate":0,"index":4919},{"krate":0,"index":4920},{"krate":0,"index":4921},{"krate":0,"index":4922},{"krate":0,"index":4923},{"krate":0,"index":4924},{"krate":0,"index":4925}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4927},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/siman.rs","byte_start":1150048,"byte_end":1150051,"line_start":489,"line_end":489,"column_start":12,"column_end":15},"name":"new","qualname":"<SimAnnealingParams>::new","value":"fn (n_tries: usize, iters: usize, step_size: f64, k: f64, t_initial: f64, mut_t: f64, t_min: f64) -> SimAnnealingParams","parent":null,"children":[],"decl_id":null,"docs":" These are the parameters that control a run of the simulated annealing algorithm.\n This structure contains all the information needed to control the search,\n beyond the energy function, the step function and the initial guess.","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":4928},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"vector","qualname":"::types::vector","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","parent":null,"children":[{"krate":0,"index":4929},{"krate":0,"index":4930},{"krate":0,"index":4933},{"krate":0,"index":4934},{"krate":0,"index":4935},{"krate":0,"index":4937},{"krate":0,"index":4943},{"krate":0,"index":4946},{"krate":0,"index":4978},{"krate":0,"index":4980},{"krate":0,"index":4982},{"krate":0,"index":4987},{"krate":0,"index":4990},{"krate":0,"index":5022},{"krate":0,"index":5024},{"krate":0,"index":5026}],"decl_id":null,"docs":"#Vectors","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4935},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1152032,"byte_end":1152042,"line_start":38,"line_end":38,"column_start":12,"column_end":22},"name":"VectorView","qualname":"::types::vector::VectorView","value":"VectorView {  }","parent":null,"children":[{"krate":0,"index":4936}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4938},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1153263,"byte_end":1153274,"line_start":59,"line_end":59,"column_start":12,"column_end":23},"name":"from_vector","qualname":"<VectorView>::from_vector","value":"fn (v: &VectorF64, offset: usize, n: usize) -> VectorView","parent":null,"children":[],"decl_id":null,"docs":" These functions return a vector view of a subvector of another vector v. The start of the new vector is offset by offset elements\n from the start of the original vector. The new vector has n elements. Mathematically, the i-th element of the new vector v’ is given by,\n \n v'(i) = v->data[(offset + i)*v->stride]\n \n where the index i runs from 0 to n-1.\n \n The data pointer of the returned vector struct is set to null if the combined parameters (offset,n) overrun the end of the original\n vector.\n \n The new vector is only a view of the block underlying the original vector, v. The block containing the elements of v is not owned by\n the new vector. When the view goes out of scope the original vector v and its block will continue to exist. The original memory can\n only be deallocated by freeing the original vector. Of course, the original vector should not be deallocated while the view is still\n in use.\n \n The function gsl_vector_const_subvector is equivalent to gsl_vector_subvector but can be used for vectors which are declared const.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4939},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1155008,"byte_end":1155031,"line_start":92,"line_end":92,"column_start":12,"column_end":35},"name":"from_vector_with_stride","qualname":"<VectorView>::from_vector_with_stride","value":"fn (v: &VectorF64, offset: usize, stride: usize, n: usize) -> VectorView","parent":null,"children":[],"decl_id":null,"docs":" These functions return a vector view of a subvector of another vector v with an additional stride argument. The subvector is formed\n in the same way as for gsl_vector_subvector but the new vector has n elements with a step-size of stride from one element to the\n next in the original vector. Mathematically, the i-th element of the new vector v’ is given by,\n \n v'(i) = v->data[(offset + i*stride)*v->stride]\n where the index i runs from 0 to n-1.\n \n Note that subvector views give direct access to the underlying elements of the original vector. For example, the following code will\n zero the even elements of the vector v of length n, while leaving the odd elements untouched,\n \n ```C\n gsl_vector_view v_even \n   = gsl_vector_subvector_with_stride (v, 0, 2, n/2);\n gsl_vector_set_zero (&v_even.vector);\n ```\n A vector view can be passed to any subroutine which takes a vector argument just as a directly allocated vector would be, using &view.vector.\n For example, the following code computes the norm of the odd elements of v using the BLAS routine DNRM2,\n \n ```C\n gsl_vector_view v_odd \n   = gsl_vector_subvector_with_stride (v, 1, 2, n/2);\n double r = gsl_blas_dnrm2 (&v_odd.vector);\n ```\n The function gsl_vector_const_subvector_with_stride is equivalent to gsl_vector_subvector_with_stride but can be used for vectors which\n are declared const.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4940},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1156062,"byte_end":1156072,"line_start":112,"line_end":112,"column_start":12,"column_end":22},"name":"from_array","qualname":"<VectorView>::from_array","value":"fn (base: &mut [f64]) -> VectorView","parent":null,"children":[],"decl_id":null,"docs":" These functions return a vector view of an array. The start of the new vector is given by base and has n elements. Mathematically,\n the i-th element of the new vector v’ is given by,\n \n v'(i) = base[i]\n \n where the index i runs from 0 to n-1.\n \n The array containing the elements of v is not owned by the new vector view. When the view goes out of scope the original array will\n continue to exist. The original memory can only be deallocated by freeing the original pointer base. Of course, the original array\n should not be deallocated while the view is still in use.\n \n The function gsl_vector_const_view_array is equivalent to gsl_vector_view_array but can be used for arrays which are declared const.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4941},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1157175,"byte_end":1157197,"line_start":133,"line_end":133,"column_start":12,"column_end":34},"name":"from_array_with_stride","qualname":"<VectorView>::from_array_with_stride","value":"fn (base: &mut [f64], stride: usize) -> VectorView","parent":null,"children":[],"decl_id":null,"docs":" These functions return a vector view of an array base with an additional stride argument. The subvector is formed in the same way as\n for gsl_vector_view_array but the new vector has n elements with a step-size of stride from one element to the next in the original\n array. Mathematically, the i-th element of the new vector v’ is given by,\n \n v'(i) = base[i*stride]\n \n where the index i runs from 0 to n-1.\n \n Note that the view gives direct access to the underlying elements of the original array. A vector view can be passed to any subroutine\n which takes a vector argument just as a directly allocated vector would be, using &view.vector.\n \n The function gsl_vector_const_view_array_with_stride is equivalent to gsl_vector_view_array_with_stride but can be used for arrays\n which are declared const.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4942},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1157437,"byte_end":1157443,"line_start":141,"line_end":141,"column_start":12,"column_end":18},"name":"vector","qualname":"<VectorView>::vector","value":"fn (&mut self) -> VectorF64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4943},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1157645,"byte_end":1157654,"line_start":151,"line_end":151,"column_start":12,"column_end":21},"name":"VectorF32","qualname":"::types::vector::VectorF32","value":"VectorF32 {  }","parent":null,"children":[{"krate":0,"index":4944},{"krate":0,"index":4945}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4947},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1157806,"byte_end":1157809,"line_start":158,"line_end":158,"column_start":12,"column_end":15},"name":"new","qualname":"<VectorF32>::new","value":"fn (size: usize) -> Option<VectorF32>","parent":null,"children":[],"decl_id":null,"docs":" create a new VectorF32 with all elements set to zero\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4948},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1158103,"byte_end":1158113,"line_start":171,"line_end":171,"column_start":12,"column_end":22},"name":"from_slice","qualname":"<VectorF32>::from_slice","value":"fn (slice: &[f32]) -> Option<VectorF32>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4949},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1158598,"byte_end":1158601,"line_start":191,"line_end":191,"column_start":12,"column_end":15},"name":"len","qualname":"<VectorF32>::len","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4950},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1158919,"byte_end":1158922,"line_start":200,"line_end":200,"column_start":12,"column_end":15},"name":"get","qualname":"<VectorF32>::get","value":"fn (&self, i: usize) -> f32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the i-th element of a vector v. If i lies outside the allowed range of 0 to n-1 then the error handler is invoked and 0 is returned.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4951},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1159185,"byte_end":1159188,"line_start":205,"line_end":205,"column_start":12,"column_end":15},"name":"set","qualname":"<VectorF32>::set","value":"fn (&mut self, i: usize, x: f32) -> &mut VectorF32","parent":null,"children":[],"decl_id":null,"docs":" This function sets the value of the i-th element of a vector v to x. If i lies outside the allowed range of 0 to n-1 then the error handler is invoked.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4952},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1159407,"byte_end":1159414,"line_start":211,"line_end":211,"column_start":12,"column_end":19},"name":"set_all","qualname":"<VectorF32>::set_all","value":"fn (&mut self, x: f32) -> &mut VectorF32","parent":null,"children":[],"decl_id":null,"docs":" This function sets all the elements of the vector v to the value x.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4953},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1159617,"byte_end":1159625,"line_start":217,"line_end":217,"column_start":12,"column_end":20},"name":"set_zero","qualname":"<VectorF32>::set_zero","value":"fn (&mut self) -> &mut VectorF32","parent":null,"children":[],"decl_id":null,"docs":" This function sets all the elements of the vector v to zero.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4954},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1159893,"byte_end":1159902,"line_start":223,"line_end":223,"column_start":12,"column_end":21},"name":"set_basis","qualname":"<VectorF32>::set_basis","value":"fn (&mut self, i: usize) -> &mut VectorF32","parent":null,"children":[],"decl_id":null,"docs":" This function makes a basis vector by setting all the elements of the vector v to zero except for the i-th element which is set to one.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4955},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1160167,"byte_end":1160176,"line_start":229,"line_end":229,"column_start":12,"column_end":21},"name":"copy_from","qualname":"<VectorF32>::copy_from","value":"fn (&mut self, other: &VectorF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the other vector into the self vector. The two vectors must have the same length.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4956},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1160459,"byte_end":1160466,"line_start":234,"line_end":234,"column_start":12,"column_end":19},"name":"copy_to","qualname":"<VectorF32>::copy_to","value":"fn (&self, other: &mut VectorF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the self vector into the other vector. The two vectors must have the same length.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4957},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1160737,"byte_end":1160741,"line_start":239,"line_end":239,"column_start":12,"column_end":16},"name":"swap","qualname":"<VectorF32>::swap","value":"fn (&mut self, other: &mut VectorF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function exchanges the elements of the vectors by copying. The two vectors must have the same length.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4958},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1160984,"byte_end":1160997,"line_start":244,"line_end":244,"column_start":12,"column_end":25},"name":"swap_elements","qualname":"<VectorF32>::swap_elements","value":"fn (&mut self, i: usize, j: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function exchanges the i-th and j-th elements of the vector v in-place.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4959},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1161230,"byte_end":1161237,"line_start":249,"line_end":249,"column_start":12,"column_end":19},"name":"reverse","qualname":"<VectorF32>::reverse","value":"fn (&mut self) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function reverses the order of the elements of the vector v.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4960},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1161586,"byte_end":1161589,"line_start":255,"line_end":255,"column_start":12,"column_end":15},"name":"add","qualname":"<VectorF32>::add","value":"fn (&mut self, other: &VectorF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function adds the elements of the other vector to the elements of the self vector.\n The result a_i <- a_i + b_i is stored in self and other remains unchanged. The two vectors must have the same length.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4961},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1161971,"byte_end":1161974,"line_start":261,"line_end":261,"column_start":12,"column_end":15},"name":"sub","qualname":"<VectorF32>::sub","value":"fn (&mut self, other: &VectorF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function subtracts the elements of the self vector from the elements of the other vector.\n The result a_i <- a_i - b_i is stored in self and other remains unchanged. The two vectors must have the same length.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4962},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1162357,"byte_end":1162360,"line_start":267,"line_end":267,"column_start":12,"column_end":15},"name":"mul","qualname":"<VectorF32>::mul","value":"fn (&mut self, other: &VectorF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function multiplies the elements of the self vector a by the elements of the other vector.\n The result a_i <- a_i * b_i is stored in self and other remains unchanged. The two vectors must have the same length.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4963},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1162738,"byte_end":1162741,"line_start":273,"line_end":273,"column_start":12,"column_end":15},"name":"div","qualname":"<VectorF32>::div","value":"fn (&mut self, other: &VectorF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function divides the elements of the self vector by the elements of the other vector.\n The result a_i <- a_i / b_i is stored in self and other remains unchanged. The two vectors must have the same length.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4964},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1163026,"byte_end":1163031,"line_start":278,"line_end":278,"column_start":12,"column_end":17},"name":"scale","qualname":"<VectorF32>::scale","value":"fn (&mut self, x: f32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function multiplies the elements of the self vector by the constant factor x. The result a_i <- a_i is stored in self.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4965},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1163296,"byte_end":1163308,"line_start":283,"line_end":283,"column_start":12,"column_end":24},"name":"add_constant","qualname":"<VectorF32>::add_constant","value":"fn (&mut self, x: f32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function adds the constant value x to the elements of the self vector. The result a_i <- a_i + x is stored in self.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4966},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1163519,"byte_end":1163522,"line_start":288,"line_end":288,"column_start":12,"column_end":15},"name":"max","qualname":"<VectorF32>::max","value":"fn (&self) -> f32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the maximum value in the self vector.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4967},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1163680,"byte_end":1163683,"line_start":293,"line_end":293,"column_start":12,"column_end":15},"name":"min","qualname":"<VectorF32>::min","value":"fn (&self) -> f32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the minimum value in the self vector.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4968},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1163891,"byte_end":1163897,"line_start":298,"line_end":298,"column_start":12,"column_end":18},"name":"minmax","qualname":"<VectorF32>::minmax","value":"fn (&self) -> (f32, f32)","parent":null,"children":[],"decl_id":null,"docs":" This function returns the minimum and maximum values in the self vector, storing them in min_out and max_out.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4969},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1164284,"byte_end":1164293,"line_start":308,"line_end":308,"column_start":12,"column_end":21},"name":"max_index","qualname":"<VectorF32>::max_index","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" This function returns the index of the maximum value in the self vector.\n When there are several equal maximum elements then the lowest index is returned.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4970},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1164561,"byte_end":1164570,"line_start":314,"line_end":314,"column_start":12,"column_end":21},"name":"min_index","qualname":"<VectorF32>::min_index","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" This function returns the index of the minimum value in the self vector.\n When there are several equal minimum elements then the lowest index is returned.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4971},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1164898,"byte_end":1164910,"line_start":320,"line_end":320,"column_start":12,"column_end":24},"name":"minmax_index","qualname":"<VectorF32>::minmax_index","value":"fn (&self) -> (usize, usize)","parent":null,"children":[],"decl_id":null,"docs":" This function returns the indices of the minimum and maximum values in the self vector, storing them in imin and imax.\n When there are several equal minimum or maximum elements then the lowest indices are returned.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4972},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1165217,"byte_end":1165224,"line_start":329,"line_end":329,"column_start":12,"column_end":19},"name":"is_null","qualname":"<VectorF32>::is_null","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all the elements of the self vector are equal to 0.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4973},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1165478,"byte_end":1165484,"line_start":337,"line_end":337,"column_start":12,"column_end":18},"name":"is_pos","qualname":"<VectorF32>::is_pos","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all the elements of the self vector are stricly positive.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4974},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1165737,"byte_end":1165743,"line_start":345,"line_end":345,"column_start":12,"column_end":18},"name":"is_neg","qualname":"<VectorF32>::is_neg","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all the elements of the self vector are stricly negative.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4975},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1166000,"byte_end":1166010,"line_start":353,"line_end":353,"column_start":12,"column_end":22},"name":"is_non_neg","qualname":"<VectorF32>::is_non_neg","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all the elements of the self vector are stricly non-negative.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4976},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1166170,"byte_end":1166175,"line_start":360,"line_end":360,"column_start":12,"column_end":17},"name":"equal","qualname":"<VectorF32>::equal","value":"fn (&self, other: &VectorF32) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4977},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1166764,"byte_end":1166769,"line_start":382,"line_end":382,"column_start":12,"column_end":17},"name":"clone","qualname":"<VectorF32>::clone","value":"fn (&self) -> Option<VectorF32>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":4987},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1168380,"byte_end":1168389,"line_start":449,"line_end":449,"column_start":12,"column_end":21},"name":"VectorF64","qualname":"::types::vector::VectorF64","value":"VectorF64 {  }","parent":null,"children":[{"krate":0,"index":4988},{"krate":0,"index":4989}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4991},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1168534,"byte_end":1168537,"line_start":456,"line_end":456,"column_start":12,"column_end":15},"name":"new","qualname":"<VectorF64>::new","value":"fn (size: usize) -> Option<VectorF64>","parent":null,"children":[],"decl_id":null,"docs":" create a new VectorF64 with all elements set to zero\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4992},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1168824,"byte_end":1168834,"line_start":469,"line_end":469,"column_start":12,"column_end":22},"name":"from_slice","qualname":"<VectorF64>::from_slice","value":"fn (slice: &[f64]) -> Option<VectorF64>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4993},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1169312,"byte_end":1169315,"line_start":489,"line_end":489,"column_start":12,"column_end":15},"name":"len","qualname":"<VectorF64>::len","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4994},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1169633,"byte_end":1169636,"line_start":498,"line_end":498,"column_start":12,"column_end":15},"name":"get","qualname":"<VectorF64>::get","value":"fn (&self, i: usize) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the i-th element of a vector v. If i lies outside the allowed range of 0 to n-1 then the error handler is invoked and 0 is returned.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4995},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1169893,"byte_end":1169896,"line_start":503,"line_end":503,"column_start":12,"column_end":15},"name":"set","qualname":"<VectorF64>::set","value":"fn (&mut self, i: usize, x: f64) -> &mut VectorF64","parent":null,"children":[],"decl_id":null,"docs":" This function sets the value of the i-th element of a vector v to x. If i lies outside the allowed range of 0 to n-1 then the error handler is invoked.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4996},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1170109,"byte_end":1170116,"line_start":509,"line_end":509,"column_start":12,"column_end":19},"name":"set_all","qualname":"<VectorF64>::set_all","value":"fn (&mut self, x: f64) -> &mut VectorF64","parent":null,"children":[],"decl_id":null,"docs":" This function sets all the elements of the vector v to the value x.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4997},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1170313,"byte_end":1170321,"line_start":515,"line_end":515,"column_start":12,"column_end":20},"name":"set_zero","qualname":"<VectorF64>::set_zero","value":"fn (&mut self) -> &mut VectorF64","parent":null,"children":[],"decl_id":null,"docs":" This function sets all the elements of the vector v to zero.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4998},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1170583,"byte_end":1170592,"line_start":521,"line_end":521,"column_start":12,"column_end":21},"name":"set_basis","qualname":"<VectorF64>::set_basis","value":"fn (&mut self, i: usize) -> &mut VectorF64","parent":null,"children":[],"decl_id":null,"docs":" This function makes a basis vector by setting all the elements of the vector v to zero except for the i-th element which is set to one.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":4999},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1170851,"byte_end":1170860,"line_start":527,"line_end":527,"column_start":12,"column_end":21},"name":"copy_from","qualname":"<VectorF64>::copy_from","value":"fn (&mut self, other: &VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the other vector into the self vector. The two vectors must have the same length.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5000},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1171137,"byte_end":1171144,"line_start":532,"line_end":532,"column_start":12,"column_end":19},"name":"copy_to","qualname":"<VectorF64>::copy_to","value":"fn (&self, other: &mut VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the self vector into the other vector. The two vectors must have the same length.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5001},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1171409,"byte_end":1171413,"line_start":537,"line_end":537,"column_start":12,"column_end":16},"name":"swap","qualname":"<VectorF64>::swap","value":"fn (&mut self, other: &mut VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function exchanges the elements of the vectors by copying. The two vectors must have the same length.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5002},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1171650,"byte_end":1171663,"line_start":542,"line_end":542,"column_start":12,"column_end":25},"name":"swap_elements","qualname":"<VectorF64>::swap_elements","value":"fn (&mut self, i: usize, j: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function exchanges the i-th and j-th elements of the vector v in-place.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5003},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1171890,"byte_end":1171897,"line_start":547,"line_end":547,"column_start":12,"column_end":19},"name":"reverse","qualname":"<VectorF64>::reverse","value":"fn (&mut self) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function reverses the order of the elements of the vector v.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5004},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1172240,"byte_end":1172243,"line_start":553,"line_end":553,"column_start":12,"column_end":15},"name":"add","qualname":"<VectorF64>::add","value":"fn (&mut self, other: &VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function adds the elements of the other vector to the elements of the self vector.\n The result a_i <- a_i + b_i is stored in self and other remains unchanged. The two vectors must have the same length.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5005},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1172619,"byte_end":1172622,"line_start":559,"line_end":559,"column_start":12,"column_end":15},"name":"sub","qualname":"<VectorF64>::sub","value":"fn (&mut self, other: &VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function subtracts the elements of the self vector from the elements of the other vector.\n The result a_i <- a_i - b_i is stored in self and other remains unchanged. The two vectors must have the same length.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5006},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1172999,"byte_end":1173002,"line_start":565,"line_end":565,"column_start":12,"column_end":15},"name":"mul","qualname":"<VectorF64>::mul","value":"fn (&mut self, other: &VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function multiplies the elements of the self vector a by the elements of the other vector.\n The result a_i <- a_i * b_i is stored in self and other remains unchanged. The two vectors must have the same length.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5007},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1173374,"byte_end":1173377,"line_start":571,"line_end":571,"column_start":12,"column_end":15},"name":"div","qualname":"<VectorF64>::div","value":"fn (&mut self, other: &VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function divides the elements of the self vector by the elements of the other vector.\n The result a_i <- a_i / b_i is stored in self and other remains unchanged. The two vectors must have the same length.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5008},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1173656,"byte_end":1173661,"line_start":576,"line_end":576,"column_start":12,"column_end":17},"name":"scale","qualname":"<VectorF64>::scale","value":"fn (&mut self, x: f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function multiplies the elements of the self vector by the constant factor x. The result a_i <- a_i is stored in self.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5009},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1173920,"byte_end":1173932,"line_start":581,"line_end":581,"column_start":12,"column_end":24},"name":"add_constant","qualname":"<VectorF64>::add_constant","value":"fn (&mut self, x: f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function adds the constant value x to the elements of the self vector. The result a_i <- a_i + x is stored in self.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5010},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1174137,"byte_end":1174140,"line_start":586,"line_end":586,"column_start":12,"column_end":15},"name":"max","qualname":"<VectorF64>::max","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the maximum value in the self vector.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5011},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1174292,"byte_end":1174295,"line_start":591,"line_end":591,"column_start":12,"column_end":15},"name":"min","qualname":"<VectorF64>::min","value":"fn (&self) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the minimum value in the self vector.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5012},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1174497,"byte_end":1174503,"line_start":596,"line_end":596,"column_start":12,"column_end":18},"name":"minmax","qualname":"<VectorF64>::minmax","value":"fn (&self) -> (f64, f64)","parent":null,"children":[],"decl_id":null,"docs":" This function returns the minimum and maximum values in the self vector, storing them in min_out and max_out.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5013},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1174884,"byte_end":1174893,"line_start":606,"line_end":606,"column_start":12,"column_end":21},"name":"max_index","qualname":"<VectorF64>::max_index","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" This function returns the index of the maximum value in the self vector.\n When there are several equal maximum elements then the lowest index is returned.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5014},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1175155,"byte_end":1175164,"line_start":612,"line_end":612,"column_start":12,"column_end":21},"name":"min_index","qualname":"<VectorF64>::min_index","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":" This function returns the index of the minimum value in the self vector.\n When there are several equal minimum elements then the lowest index is returned.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5015},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1175486,"byte_end":1175498,"line_start":618,"line_end":618,"column_start":12,"column_end":24},"name":"minmax_index","qualname":"<VectorF64>::minmax_index","value":"fn (&self) -> (usize, usize)","parent":null,"children":[],"decl_id":null,"docs":" This function returns the indices of the minimum and maximum values in the self vector, storing them in imin and imax.\n When there are several equal minimum or maximum elements then the lowest indices are returned.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5016},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1175799,"byte_end":1175806,"line_start":627,"line_end":627,"column_start":12,"column_end":19},"name":"is_null","qualname":"<VectorF64>::is_null","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all the elements of the self vector are equal to 0.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5017},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1176054,"byte_end":1176060,"line_start":635,"line_end":635,"column_start":12,"column_end":18},"name":"is_pos","qualname":"<VectorF64>::is_pos","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all the elements of the self vector are stricly positive.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5018},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1176307,"byte_end":1176313,"line_start":643,"line_end":643,"column_start":12,"column_end":18},"name":"is_neg","qualname":"<VectorF64>::is_neg","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all the elements of the self vector are stricly negative.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5019},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1176564,"byte_end":1176574,"line_start":651,"line_end":651,"column_start":12,"column_end":22},"name":"is_non_neg","qualname":"<VectorF64>::is_non_neg","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all the elements of the self vector are stricly non-negative.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5020},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1176728,"byte_end":1176733,"line_start":658,"line_end":658,"column_start":12,"column_end":17},"name":"equal","qualname":"<VectorF64>::equal","value":"fn (&self, other: &VectorF64) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5021},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1177316,"byte_end":1177321,"line_start":680,"line_end":680,"column_start":12,"column_end":17},"name":"clone","qualname":"<VectorF64>::clone","value":"fn (&self) -> Option<VectorF64>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5031},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"vector_complex","qualname":"::types::vector_complex","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","parent":null,"children":[{"krate":0,"index":5032},{"krate":0,"index":5033},{"krate":0,"index":5036},{"krate":0,"index":5039},{"krate":0,"index":5040},{"krate":0,"index":5041},{"krate":0,"index":5043},{"krate":0,"index":5070},{"krate":0,"index":5072},{"krate":0,"index":5074},{"krate":0,"index":5079},{"krate":0,"index":5081},{"krate":0,"index":5108},{"krate":0,"index":5110},{"krate":0,"index":5112}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":5041},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1179095,"byte_end":1179111,"line_start":11,"line_end":11,"column_start":12,"column_end":28},"name":"VectorComplexF64","qualname":"::types::vector_complex::VectorComplexF64","value":"VectorComplexF64 {  }","parent":null,"children":[{"krate":0,"index":5042}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5044},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1179209,"byte_end":1179216,"line_start":17,"line_end":17,"column_start":12,"column_end":19},"name":"get_ffi","qualname":"<VectorComplexF64>::get_ffi","value":"fn (&self) -> *mut ffi::gsl_vector_complex","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5045},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1179361,"byte_end":1179364,"line_start":22,"line_end":22,"column_start":12,"column_end":15},"name":"new","qualname":"<VectorComplexF64>::new","value":"fn (size: usize) -> Option<VectorComplexF64>","parent":null,"children":[],"decl_id":null,"docs":" create a new VectorComplexF64 with all elements set to zero\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5046},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1179641,"byte_end":1179651,"line_start":34,"line_end":34,"column_start":12,"column_end":22},"name":"from_slice","qualname":"<VectorComplexF64>::from_slice","value":"fn (slice: &[ComplexF64]) -> Option<VectorComplexF64>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5047},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1180125,"byte_end":1180128,"line_start":53,"line_end":53,"column_start":12,"column_end":15},"name":"len","qualname":"<VectorComplexF64>::len","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5048},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1180446,"byte_end":1180449,"line_start":62,"line_end":62,"column_start":12,"column_end":15},"name":"get","qualname":"<VectorComplexF64>::get","value":"fn (&self, i: usize) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the i-th element of a vector v. If i lies outside the allowed range of 0 to n-1 then the error handler is invoked and 0 is returned.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5049},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1180744,"byte_end":1180747,"line_start":67,"line_end":67,"column_start":12,"column_end":15},"name":"set","qualname":"<VectorComplexF64>::set","value":"fn (&mut self, i: usize, x: &ComplexF64) -> &VectorComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function sets the value of the i-th element of a vector v to x. If i lies outside the allowed range of 0 to n-1 then the error handler is invoked.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5050},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1181003,"byte_end":1181010,"line_start":73,"line_end":73,"column_start":12,"column_end":19},"name":"set_all","qualname":"<VectorComplexF64>::set_all","value":"fn (&mut self, x: &ComplexF64) -> &VectorComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function sets all the elements of the vector v to the value x.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5051},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1181250,"byte_end":1181258,"line_start":79,"line_end":79,"column_start":12,"column_end":20},"name":"set_zero","qualname":"<VectorComplexF64>::set_zero","value":"fn (&mut self) -> &VectorComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function sets all the elements of the vector v to zero.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5052},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1181531,"byte_end":1181540,"line_start":85,"line_end":85,"column_start":12,"column_end":21},"name":"set_basis","qualname":"<VectorComplexF64>::set_basis","value":"fn (&mut self, i: usize) -> &VectorComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function makes a basis vector by setting all the elements of the vector v to zero except for the i-th element which is set to one.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5053},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1181810,"byte_end":1181819,"line_start":91,"line_end":91,"column_start":12,"column_end":21},"name":"copy_from","qualname":"<VectorComplexF64>::copy_from","value":"fn (&mut self, other: &VectorComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the other vector into the self vector. The two vectors must have the same length.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5054},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1182111,"byte_end":1182118,"line_start":96,"line_end":96,"column_start":12,"column_end":19},"name":"copy_to","qualname":"<VectorComplexF64>::copy_to","value":"fn (&self, other: &mut VectorComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the self vector into the other vector. The two vectors must have the same length.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5055},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1182398,"byte_end":1182402,"line_start":101,"line_end":101,"column_start":12,"column_end":16},"name":"swap","qualname":"<VectorComplexF64>::swap","value":"fn (&mut self, other: &mut VectorComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function exchanges the elements of the vectors by copying. The two vectors must have the same length.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5056},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1182654,"byte_end":1182667,"line_start":106,"line_end":106,"column_start":12,"column_end":25},"name":"swap_elements","qualname":"<VectorComplexF64>::swap_elements","value":"fn (&mut self, i: usize, j: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function exchanges the i-th and j-th elements of the vector v in-place.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5057},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1182902,"byte_end":1182909,"line_start":111,"line_end":111,"column_start":12,"column_end":19},"name":"reverse","qualname":"<VectorComplexF64>::reverse","value":"fn (&mut self) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function reverses the order of the elements of the vector v.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5058},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1183260,"byte_end":1183263,"line_start":117,"line_end":117,"column_start":12,"column_end":15},"name":"add","qualname":"<VectorComplexF64>::add","value":"fn (&mut self, other: &VectorComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function adds the elements of the other vector to the elements of the self vector.\n The result a_i <- a_i + b_i is stored in self and other remains unchanged. The two vectors must have the same length.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5059},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1183654,"byte_end":1183657,"line_start":123,"line_end":123,"column_start":12,"column_end":15},"name":"sub","qualname":"<VectorComplexF64>::sub","value":"fn (&mut self, other: &VectorComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function subtracts the elements of the self vector from the elements of the other vector.\n The result a_i <- a_i - b_i is stored in self and other remains unchanged. The two vectors must have the same length.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5060},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1184049,"byte_end":1184052,"line_start":129,"line_end":129,"column_start":12,"column_end":15},"name":"mul","qualname":"<VectorComplexF64>::mul","value":"fn (&mut self, other: &VectorComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function multiplies the elements of the self vector a by the elements of the other vector.\n The result a_i <- a_i * b_i is stored in self and other remains unchanged. The two vectors must have the same length.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5061},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1184439,"byte_end":1184442,"line_start":135,"line_end":135,"column_start":12,"column_end":15},"name":"div","qualname":"<VectorComplexF64>::div","value":"fn (&mut self, other: &VectorComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function divides the elements of the self vector by the elements of the other vector.\n The result a_i <- a_i / b_i is stored in self and other remains unchanged. The two vectors must have the same length.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5062},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1184736,"byte_end":1184741,"line_start":140,"line_end":140,"column_start":12,"column_end":17},"name":"scale","qualname":"<VectorComplexF64>::scale","value":"fn (&mut self, x: &ComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function multiplies the elements of the self vector by the constant factor x. The result a_i <- a_i is stored in self.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5063},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1185060,"byte_end":1185072,"line_start":147,"line_end":147,"column_start":12,"column_end":24},"name":"add_constant","qualname":"<VectorComplexF64>::add_constant","value":"fn (&mut self, x: &ComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function adds the constant value x to the elements of the self vector. The result a_i <- a_i + x is stored in self.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5064},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1185359,"byte_end":1185366,"line_start":154,"line_end":154,"column_start":12,"column_end":19},"name":"is_null","qualname":"<VectorComplexF64>::is_null","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all the elements of the self vector are equal to 0.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5065},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1185622,"byte_end":1185628,"line_start":162,"line_end":162,"column_start":12,"column_end":18},"name":"is_pos","qualname":"<VectorComplexF64>::is_pos","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all the elements of the self vector are stricly positive.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5066},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1185883,"byte_end":1185889,"line_start":170,"line_end":170,"column_start":12,"column_end":18},"name":"is_neg","qualname":"<VectorComplexF64>::is_neg","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all the elements of the self vector are stricly negative.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5067},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1186148,"byte_end":1186158,"line_start":178,"line_end":178,"column_start":12,"column_end":22},"name":"is_non_neg","qualname":"<VectorComplexF64>::is_non_neg","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all the elements of the self vector are stricly non-negative.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5068},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1186320,"byte_end":1186325,"line_start":185,"line_end":185,"column_start":12,"column_end":17},"name":"equal","qualname":"<VectorComplexF64>::equal","value":"fn (&self, other: &VectorComplexF64) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5069},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1186923,"byte_end":1186928,"line_start":207,"line_end":207,"column_start":12,"column_end":17},"name":"clone","qualname":"<VectorComplexF64>::clone","value":"fn (&self) -> Option<VectorComplexF64>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":5079},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1188494,"byte_end":1188510,"line_start":268,"line_end":268,"column_start":12,"column_end":28},"name":"VectorComplexF32","qualname":"::types::vector_complex::VectorComplexF32","value":"VectorComplexF32 {  }","parent":null,"children":[{"krate":0,"index":5080}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5082},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1188614,"byte_end":1188621,"line_start":274,"line_end":274,"column_start":12,"column_end":19},"name":"get_ffi","qualname":"<VectorComplexF32>::get_ffi","value":"fn (&self) -> *mut ffi::gsl_vector_complex_float","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5083},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1188772,"byte_end":1188775,"line_start":279,"line_end":279,"column_start":12,"column_end":15},"name":"new","qualname":"<VectorComplexF32>::new","value":"fn (size: usize) -> Option<VectorComplexF32>","parent":null,"children":[],"decl_id":null,"docs":" create a new VectorComplexF32 with all elements set to zero\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5084},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1189058,"byte_end":1189068,"line_start":291,"line_end":291,"column_start":12,"column_end":22},"name":"from_slice","qualname":"<VectorComplexF32>::from_slice","value":"fn (slice: &[ComplexF32]) -> Option<VectorComplexF32>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5085},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1189548,"byte_end":1189551,"line_start":310,"line_end":310,"column_start":12,"column_end":15},"name":"len","qualname":"<VectorComplexF32>::len","value":"fn (&self) -> usize","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5086},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1189869,"byte_end":1189872,"line_start":319,"line_end":319,"column_start":12,"column_end":15},"name":"get","qualname":"<VectorComplexF32>::get","value":"fn (&self, i: usize) -> ComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the i-th element of a vector v. If i lies outside the allowed range of 0 to n-1 then the error handler is invoked and 0 is returned.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5087},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1190173,"byte_end":1190176,"line_start":324,"line_end":324,"column_start":12,"column_end":15},"name":"set","qualname":"<VectorComplexF32>::set","value":"fn (&mut self, i: usize, x: &ComplexF32) -> &VectorComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function sets the value of the i-th element of a vector v to x. If i lies outside the allowed range of 0 to n-1 then the error handler is invoked.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5088},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1190438,"byte_end":1190445,"line_start":330,"line_end":330,"column_start":12,"column_end":19},"name":"set_all","qualname":"<VectorComplexF32>::set_all","value":"fn (&mut self, x: &ComplexF32) -> &VectorComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function sets all the elements of the vector v to the value x.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5089},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1190691,"byte_end":1190699,"line_start":336,"line_end":336,"column_start":12,"column_end":20},"name":"set_zero","qualname":"<VectorComplexF32>::set_zero","value":"fn (&mut self) -> &VectorComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function sets all the elements of the vector v to zero.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5090},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1190978,"byte_end":1190987,"line_start":342,"line_end":342,"column_start":12,"column_end":21},"name":"set_basis","qualname":"<VectorComplexF32>::set_basis","value":"fn (&mut self, i: usize) -> &VectorComplexF32","parent":null,"children":[],"decl_id":null,"docs":" This function makes a basis vector by setting all the elements of the vector v to zero except for the i-th element which is set to one.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5091},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1191263,"byte_end":1191272,"line_start":348,"line_end":348,"column_start":12,"column_end":21},"name":"copy_from","qualname":"<VectorComplexF32>::copy_from","value":"fn (&mut self, other: &VectorComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the other vector into the self vector. The two vectors must have the same length.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5092},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1191570,"byte_end":1191577,"line_start":353,"line_end":353,"column_start":12,"column_end":19},"name":"copy_to","qualname":"<VectorComplexF32>::copy_to","value":"fn (&self, other: &mut VectorComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the elements of the self vector into the other vector. The two vectors must have the same length.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5093},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1191863,"byte_end":1191867,"line_start":358,"line_end":358,"column_start":12,"column_end":16},"name":"swap","qualname":"<VectorComplexF32>::swap","value":"fn (&mut self, other: &mut VectorComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function exchanges the elements of the vectors by copying. The two vectors must have the same length.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5094},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1192125,"byte_end":1192138,"line_start":363,"line_end":363,"column_start":12,"column_end":25},"name":"swap_elements","qualname":"<VectorComplexF32>::swap_elements","value":"fn (&mut self, i: usize, j: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function exchanges the i-th and j-th elements of the vector v in-place.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5095},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1192379,"byte_end":1192386,"line_start":368,"line_end":368,"column_start":12,"column_end":19},"name":"reverse","qualname":"<VectorComplexF32>::reverse","value":"fn (&mut self) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function reverses the order of the elements of the vector v.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5096},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1192743,"byte_end":1192746,"line_start":374,"line_end":374,"column_start":12,"column_end":15},"name":"add","qualname":"<VectorComplexF32>::add","value":"fn (&mut self, other: &VectorComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function adds the elements of the other vector to the elements of the self vector.\n The result a_i <- a_i + b_i is stored in self and other remains unchanged. The two vectors must have the same length.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5097},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1193143,"byte_end":1193146,"line_start":380,"line_end":380,"column_start":12,"column_end":15},"name":"sub","qualname":"<VectorComplexF32>::sub","value":"fn (&mut self, other: &VectorComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function subtracts the elements of the self vector from the elements of the other vector.\n The result a_i <- a_i - b_i is stored in self and other remains unchanged. The two vectors must have the same length.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5098},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1193544,"byte_end":1193547,"line_start":386,"line_end":386,"column_start":12,"column_end":15},"name":"mul","qualname":"<VectorComplexF32>::mul","value":"fn (&mut self, other: &VectorComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function multiplies the elements of the self vector a by the elements of the other vector.\n The result a_i <- a_i * b_i is stored in self and other remains unchanged. The two vectors must have the same length.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5099},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1193940,"byte_end":1193943,"line_start":392,"line_end":392,"column_start":12,"column_end":15},"name":"div","qualname":"<VectorComplexF32>::div","value":"fn (&mut self, other: &VectorComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function divides the elements of the self vector by the elements of the other vector.\n The result a_i <- a_i / b_i is stored in self and other remains unchanged. The two vectors must have the same length.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5100},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1194243,"byte_end":1194248,"line_start":397,"line_end":397,"column_start":12,"column_end":17},"name":"scale","qualname":"<VectorComplexF32>::scale","value":"fn (&mut self, x: &ComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function multiplies the elements of the self vector by the constant factor x. The result a_i <- a_i is stored in self.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5101},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1194573,"byte_end":1194585,"line_start":404,"line_end":404,"column_start":12,"column_end":24},"name":"add_constant","qualname":"<VectorComplexF32>::add_constant","value":"fn (&mut self, x: &ComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function adds the constant value x to the elements of the self vector. The result a_i <- a_i + x is stored in self.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5102},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1194878,"byte_end":1194885,"line_start":411,"line_end":411,"column_start":12,"column_end":19},"name":"is_null","qualname":"<VectorComplexF32>::is_null","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all the elements of the self vector are equal to 0.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5103},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1195147,"byte_end":1195153,"line_start":419,"line_end":419,"column_start":12,"column_end":18},"name":"is_pos","qualname":"<VectorComplexF32>::is_pos","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all the elements of the self vector are stricly positive.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5104},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1195414,"byte_end":1195420,"line_start":427,"line_end":427,"column_start":12,"column_end":18},"name":"is_neg","qualname":"<VectorComplexF32>::is_neg","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all the elements of the self vector are stricly negative.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5105},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1195685,"byte_end":1195695,"line_start":435,"line_end":435,"column_start":12,"column_end":22},"name":"is_non_neg","qualname":"<VectorComplexF32>::is_non_neg","value":"fn (&self) -> bool","parent":null,"children":[],"decl_id":null,"docs":" This function returns true if all the elements of the self vector are stricly non-negative.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5106},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1195863,"byte_end":1195868,"line_start":442,"line_end":442,"column_start":12,"column_end":17},"name":"equal","qualname":"<VectorComplexF32>::equal","value":"fn (&self, other: &VectorComplexF32) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5107},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1196484,"byte_end":1196489,"line_start":465,"line_end":465,"column_start":12,"column_end":17},"name":"clone","qualname":"<VectorComplexF32>::clone","value":"fn (&self) -> Option<VectorComplexF32>","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5117},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/wavelet_transforms.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"wavelet_transforms","qualname":"::types::wavelet_transforms","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/wavelet_transforms.rs","parent":null,"children":[{"krate":0,"index":5118},{"krate":0,"index":5119},{"krate":0,"index":5121},{"krate":0,"index":5124},{"krate":0,"index":5126},{"krate":0,"index":7070},{"krate":0,"index":7073},{"krate":0,"index":7072},{"krate":0,"index":5131},{"krate":0,"index":5138},{"krate":0,"index":5140},{"krate":0,"index":5142},{"krate":0,"index":5144}],"decl_id":null,"docs":"#Wavelet Transforms","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":5119},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/wavelet_transforms.rs","byte_start":1201212,"byte_end":1201219,"line_start":58,"line_end":58,"column_start":12,"column_end":19},"name":"Wavelet","qualname":"::types::wavelet_transforms::Wavelet","value":"Wavelet {  }","parent":null,"children":[{"krate":0,"index":5120}],"decl_id":null,"docs":" The Wavelet structure contains the filter coefficients defining the wavelet and any associated offset parameters.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5122},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/wavelet_transforms.rs","byte_start":1201534,"byte_end":1201537,"line_start":65,"line_end":65,"column_start":12,"column_end":15},"name":"new","qualname":"<Wavelet>::new","value":"fn (t: &WaveletType, k: usize) -> Option<Wavelet>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates and initializes a wavelet object of type T. The parameter k selects the specific member of the wavelet\n family. A null pointer is returned if insufficient memory is available or if a unsupported member is selected.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5123},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/wavelet_transforms.rs","byte_start":1201883,"byte_end":1201887,"line_start":78,"line_end":78,"column_start":12,"column_end":16},"name":"name","qualname":"<Wavelet>::name","value":"fn (&self) -> Option<String>","parent":null,"children":[],"decl_id":null,"docs":" This function returns a pointer to the name of the wavelet family for w.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":7070},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/wavelet_transforms.rs","byte_start":1202985,"byte_end":1202996,"line_start":119,"line_end":119,"column_start":12,"column_end":23},"name":"WaveletType","qualname":"::types::wavelet_transforms::WaveletType","value":"WaveletType {  }","parent":null,"children":[{"krate":0,"index":7071}],"decl_id":null,"docs":" The centered forms of the wavelets align the coefficients of the various sub-bands on edges. Thus the resulting visualization of the\n coefficients of the wavelet transform in the phase plane is easier to understand.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5132},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/wavelet_transforms.rs","byte_start":1203226,"byte_end":1203236,"line_start":126,"line_end":126,"column_start":12,"column_end":22},"name":"daubechies","qualname":"<WaveletType>::daubechies","value":"fn () -> WaveletType","parent":null,"children":[],"decl_id":null,"docs":" This is the Daubechies wavelet family of maximum phase with k/2 vanishing moments. The implemented wavelets are k=4, 6, …, 20, with\n k even.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5133},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/wavelet_transforms.rs","byte_start":1203546,"byte_end":1203565,"line_start":136,"line_end":136,"column_start":12,"column_end":31},"name":"daubechies_centered","qualname":"<WaveletType>::daubechies_centered","value":"fn () -> WaveletType","parent":null,"children":[],"decl_id":null,"docs":" This is the Daubechies wavelet family of maximum phase with k/2 vanishing moments. The implemented wavelets are k=4, 6, …, 20, with\n k even.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5134},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/wavelet_transforms.rs","byte_start":1203816,"byte_end":1203820,"line_start":145,"line_end":145,"column_start":12,"column_end":16},"name":"haar","qualname":"<WaveletType>::haar","value":"fn () -> WaveletType","parent":null,"children":[],"decl_id":null,"docs":" This is the Haar wavelet. The only valid choice of k for the Haar wavelet is k=2.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5135},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/wavelet_transforms.rs","byte_start":1204056,"byte_end":1204069,"line_start":154,"line_end":154,"column_start":12,"column_end":25},"name":"haar_centered","qualname":"<WaveletType>::haar_centered","value":"fn () -> WaveletType","parent":null,"children":[],"decl_id":null,"docs":" This is the Haar wavelet. The only valid choice of k for the Haar wavelet is k=2.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5136},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/wavelet_transforms.rs","byte_start":1204403,"byte_end":1204410,"line_start":164,"line_end":164,"column_start":12,"column_end":19},"name":"bspline","qualname":"<WaveletType>::bspline","value":"fn () -> WaveletType","parent":null,"children":[],"decl_id":null,"docs":" This is the biorthogonal B-spline wavelet family of order (i,j). The implemented values of k = 100*i + j are 103, 105, 202, 204,\n 206, 208, 301, 303, 305 307, 309.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5137},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/wavelet_transforms.rs","byte_start":1204738,"byte_end":1204754,"line_start":174,"line_end":174,"column_start":12,"column_end":28},"name":"bspline_centered","qualname":"<WaveletType>::bspline_centered","value":"fn () -> WaveletType","parent":null,"children":[],"decl_id":null,"docs":" This is the biorthogonal B-spline wavelet family of order (i,j). The implemented values of k = 100*i + j are 103, 105, 202, 204,\n 206, 208, 301, 303, 305 307, 309.\n","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":5138},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/wavelet_transforms.rs","byte_start":1205074,"byte_end":1205090,"line_start":185,"line_end":185,"column_start":12,"column_end":28},"name":"WaveletWorkspace","qualname":"::types::wavelet_transforms::WaveletWorkspace","value":"WaveletWorkspace {  }","parent":null,"children":[{"krate":0,"index":5139}],"decl_id":null,"docs":" The WaveletWorkspace structure contains scratch space of the same size as the input data and is used to hold intermediate results\n during the transform.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5141},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/wavelet_transforms.rs","byte_start":1205595,"byte_end":1205598,"line_start":194,"line_end":194,"column_start":12,"column_end":15},"name":"new","qualname":"<WaveletWorkspace>::new","value":"fn (n: usize) -> Option<WaveletWorkspace>","parent":null,"children":[],"decl_id":null,"docs":" This function allocates a workspace for the discrete wavelet transform. To perform a one-dimensional transform on n elements, a\n workspace of size n must be provided. For two-dimensional transforms of n-by-n matrices it is sufficient to allocate a workspace\n of size n, since the transform operates on individual rows and columns. A null pointer is returned if insufficient memory is\n available.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5149},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/airy.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"airy","qualname":"::airy","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/airy.rs","parent":null,"children":[{"krate":0,"index":5150},{"krate":0,"index":5151},{"krate":0,"index":5152},{"krate":0,"index":5153},{"krate":0,"index":5154},{"krate":0,"index":5155},{"krate":0,"index":5156},{"krate":0,"index":5157},{"krate":0,"index":5158},{"krate":0,"index":5159},{"krate":0,"index":5160},{"krate":0,"index":5161},{"krate":0,"index":5162},{"krate":0,"index":5163},{"krate":0,"index":5164},{"krate":0,"index":5165},{"krate":0,"index":5166},{"krate":0,"index":5167},{"krate":0,"index":5168},{"krate":0,"index":5169},{"krate":0,"index":5170},{"krate":0,"index":5171},{"krate":0,"index":5172},{"krate":0,"index":5173},{"krate":0,"index":5174},{"krate":0,"index":5175},{"krate":0,"index":5176}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5153},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/airy.rs","byte_start":1206775,"byte_end":1206777,"line_start":10,"line_end":10,"column_start":8,"column_end":10},"name":"Ai","qualname":"::airy::Ai","value":"fn (x: f64, mode: ::Mode) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Airy function Ai(x) with an accuracy specified by mode.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5154},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/airy.rs","byte_start":1206949,"byte_end":1206953,"line_start":15,"line_end":15,"column_start":8,"column_end":12},"name":"Ai_e","qualname":"::airy::Ai_e","value":"fn (x: f64, mode: ::Mode) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Airy function Ai(x) with an accuracy specified by mode.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5155},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/airy.rs","byte_start":1207325,"byte_end":1207327,"line_start":23,"line_end":23,"column_start":8,"column_end":10},"name":"Bi","qualname":"::airy::Bi","value":"fn (x: f64, mode: ::Mode) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Airy function Bi(x) with an accuracy specified by mode.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5156},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/airy.rs","byte_start":1207499,"byte_end":1207503,"line_start":28,"line_end":28,"column_start":8,"column_end":12},"name":"Bi_e","qualname":"::airy::Bi_e","value":"fn (x: f64, mode: ::Mode) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Airy function Bi(x) with an accuracy specified by mode.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5157},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/airy.rs","byte_start":1207944,"byte_end":1207953,"line_start":36,"line_end":36,"column_start":8,"column_end":17},"name":"Ai_scaled","qualname":"::airy::Ai_scaled","value":"fn (x: f64, mode: ::Mode) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes a scaled version of the Airy function S_A(x) Ai(x). For x>0 the scaling factor S_A(x) is \\exp(+(2/3) x^(3/2)), and is 1 for x<0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5158},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/airy.rs","byte_start":1208201,"byte_end":1208212,"line_start":41,"line_end":41,"column_start":8,"column_end":19},"name":"Ai_scaled_e","qualname":"::airy::Ai_scaled_e","value":"fn (x: f64, mode: ::Mode) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes a scaled version of the Airy function S_A(x) Ai(x). For x>0 the scaling factor S_A(x) is \\exp(+(2/3) x^(3/2)), and is 1 for x<0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5159},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/airy.rs","byte_start":1208659,"byte_end":1208668,"line_start":49,"line_end":49,"column_start":8,"column_end":17},"name":"Bi_scaled","qualname":"::airy::Bi_scaled","value":"fn (x: f64, mode: ::Mode) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes a scaled version of the Airy function S_B(x) Bi(x). For x>0 the scaling factor S_B(x) is exp(-(2/3) x^(3/2)), and is 1 for x<0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5160},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/airy.rs","byte_start":1208915,"byte_end":1208926,"line_start":54,"line_end":54,"column_start":8,"column_end":19},"name":"Bi_scaled_e","qualname":"::airy::Bi_scaled_e","value":"fn (x: f64, mode: ::Mode) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes a scaled version of the Airy function S_B(x) Bi(x). For x>0 the scaling factor S_B(x) is exp(-(2/3) x^(3/2)), and is 1 for x<0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5161},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/airy.rs","byte_start":1209317,"byte_end":1209325,"line_start":62,"line_end":62,"column_start":8,"column_end":16},"name":"Ai_deriv","qualname":"::airy::Ai_deriv","value":"fn (x: f64, mode: ::Mode) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Airy function derivative Ai'(x) with an accuracy specified by mode.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5162},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/airy.rs","byte_start":1209515,"byte_end":1209525,"line_start":67,"line_end":67,"column_start":8,"column_end":18},"name":"Ai_deriv_e","qualname":"::airy::Ai_deriv_e","value":"fn (x: f64, mode: ::Mode) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Airy function derivative Ai'(x) with an accuracy specified by mode.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5163},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/airy.rs","byte_start":1209915,"byte_end":1209923,"line_start":75,"line_end":75,"column_start":8,"column_end":16},"name":"Bi_deriv","qualname":"::airy::Bi_deriv","value":"fn (x: f64, mode: ::Mode) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Airy function derivative Bi'(x) with an accuracy specified by mode.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5164},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/airy.rs","byte_start":1210113,"byte_end":1210123,"line_start":80,"line_end":80,"column_start":8,"column_end":18},"name":"Bi_deriv_e","qualname":"::airy::Bi_deriv_e","value":"fn (x: f64, mode: ::Mode) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Airy function derivative Bi'(x) with an accuracy specified by mode.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5165},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/airy.rs","byte_start":1210569,"byte_end":1210584,"line_start":88,"line_end":88,"column_start":8,"column_end":23},"name":"Ai_deriv_scaled","qualname":"::airy::Ai_deriv_scaled","value":"fn (x: f64, mode: ::Mode) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled Airy function derivative S_A(x) Ai'(x). For x>0 the scaling factor S_A(x) is \\exp(+(2/3) x^(3/2)), and is 1 for x<0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5166},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/airy.rs","byte_start":1210837,"byte_end":1210854,"line_start":93,"line_end":93,"column_start":8,"column_end":25},"name":"Ai_deriv_scaled_e","qualname":"::airy::Ai_deriv_scaled_e","value":"fn (x: f64, mode: ::Mode) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled Airy function derivative S_A(x) Ai'(x). For x>0 the scaling factor S_A(x) is \\exp(+(2/3) x^(3/2)), and is 1 for x<0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5167},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/airy.rs","byte_start":1211306,"byte_end":1211321,"line_start":101,"line_end":101,"column_start":8,"column_end":23},"name":"Bi_deriv_scaled","qualname":"::airy::Bi_deriv_scaled","value":"fn (x: f64, mode: ::Mode) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled Airy function derivative S_B(x) Bi'(x). For x>0 the scaling factor S_B(x) is exp(-(2/3) x^(3/2)), and is 1 for x<0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5168},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/airy.rs","byte_start":1211573,"byte_end":1211590,"line_start":106,"line_end":106,"column_start":8,"column_end":25},"name":"Bi_deriv_scaled_e","qualname":"::airy::Bi_deriv_scaled_e","value":"fn (x: f64, mode: ::Mode) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled Airy function derivative S_B(x) Bi'(x). For x>0 the scaling factor S_B(x) is exp(-(2/3) x^(3/2)), and is 1 for x<0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5169},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/airy.rs","byte_start":1211973,"byte_end":1211980,"line_start":114,"line_end":114,"column_start":8,"column_end":15},"name":"zero_Ai","qualname":"::airy::zero_Ai","value":"fn (s: u32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the location of the s-th zero of the Airy function Ai(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5170},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/airy.rs","byte_start":1212135,"byte_end":1212144,"line_start":119,"line_end":119,"column_start":8,"column_end":17},"name":"zero_Ai_e","qualname":"::airy::zero_Ai_e","value":"fn (s: u32) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the location of the s-th zero of the Airy function Ai(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5171},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/airy.rs","byte_start":1212499,"byte_end":1212506,"line_start":127,"line_end":127,"column_start":8,"column_end":15},"name":"zero_Bi","qualname":"::airy::zero_Bi","value":"fn (s: u32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the location of the s-th zero of the Airy function Bi(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5172},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/airy.rs","byte_start":1212661,"byte_end":1212670,"line_start":132,"line_end":132,"column_start":8,"column_end":17},"name":"zero_Bi_e","qualname":"::airy::zero_Bi_e","value":"fn (s: u32) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the location of the s-th zero of the Airy function Bi(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5173},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/airy.rs","byte_start":1213037,"byte_end":1213050,"line_start":140,"line_end":140,"column_start":8,"column_end":21},"name":"zero_Ai_deriv","qualname":"::airy::zero_Ai_deriv","value":"fn (s: u32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the location of the s-th zero of the Airy function derivative Ai'(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5174},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/airy.rs","byte_start":1213223,"byte_end":1213238,"line_start":145,"line_end":145,"column_start":8,"column_end":23},"name":"zero_Ai_deriv_e","qualname":"::airy::zero_Ai_deriv_e","value":"fn (s: u32) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the location of the s-th zero of the Airy function derivative Ai'(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5175},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/airy.rs","byte_start":1213611,"byte_end":1213624,"line_start":153,"line_end":153,"column_start":8,"column_end":21},"name":"zero_Bi_deriv","qualname":"::airy::zero_Bi_deriv","value":"fn (s: u32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the location of the s-th zero of the Airy function derivative Bi'(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5176},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/airy.rs","byte_start":1213797,"byte_end":1213812,"line_start":158,"line_end":158,"column_start":8,"column_end":23},"name":"zero_Bi_deriv_e","qualname":"::airy::zero_Bi_deriv_e","value":"fn (s: u32) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the location of the s-th zero of the Airy function derivative Bi'(x).\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5177},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"bessel","qualname":"::bessel","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","parent":null,"children":[{"krate":0,"index":5178},{"krate":0,"index":5179},{"krate":0,"index":5180},{"krate":0,"index":5181},{"krate":0,"index":5182},{"krate":0,"index":5183},{"krate":0,"index":5184},{"krate":0,"index":5185},{"krate":0,"index":5186},{"krate":0,"index":5187},{"krate":0,"index":5188},{"krate":0,"index":5189},{"krate":0,"index":5190},{"krate":0,"index":5191},{"krate":0,"index":5192},{"krate":0,"index":5193},{"krate":0,"index":5194},{"krate":0,"index":5195},{"krate":0,"index":5196},{"krate":0,"index":5197},{"krate":0,"index":5198},{"krate":0,"index":5199},{"krate":0,"index":5200},{"krate":0,"index":5201},{"krate":0,"index":5202},{"krate":0,"index":5203},{"krate":0,"index":5204},{"krate":0,"index":5205},{"krate":0,"index":5206},{"krate":0,"index":5207},{"krate":0,"index":5208},{"krate":0,"index":5209},{"krate":0,"index":5210},{"krate":0,"index":5211},{"krate":0,"index":5212},{"krate":0,"index":5213},{"krate":0,"index":5214},{"krate":0,"index":5215},{"krate":0,"index":5216},{"krate":0,"index":5217},{"krate":0,"index":5218},{"krate":0,"index":5219},{"krate":0,"index":5220},{"krate":0,"index":5221},{"krate":0,"index":5222},{"krate":0,"index":5223},{"krate":0,"index":5224},{"krate":0,"index":5225},{"krate":0,"index":5226},{"krate":0,"index":5227},{"krate":0,"index":5228},{"krate":0,"index":5229},{"krate":0,"index":5230},{"krate":0,"index":5231},{"krate":0,"index":5232},{"krate":0,"index":5233},{"krate":0,"index":5234},{"krate":0,"index":5235},{"krate":0,"index":5236},{"krate":0,"index":5237},{"krate":0,"index":5238},{"krate":0,"index":5239},{"krate":0,"index":5240},{"krate":0,"index":5241},{"krate":0,"index":5242},{"krate":0,"index":5243},{"krate":0,"index":5244},{"krate":0,"index":5245},{"krate":0,"index":5246},{"krate":0,"index":5247},{"krate":0,"index":5248},{"krate":0,"index":5249},{"krate":0,"index":5250},{"krate":0,"index":5251},{"krate":0,"index":5252},{"krate":0,"index":5253},{"krate":0,"index":5254},{"krate":0,"index":5255},{"krate":0,"index":5256},{"krate":0,"index":5257},{"krate":0,"index":5258},{"krate":0,"index":5259},{"krate":0,"index":5260},{"krate":0,"index":5261},{"krate":0,"index":5262},{"krate":0,"index":5263},{"krate":0,"index":5264},{"krate":0,"index":5265},{"krate":0,"index":5266},{"krate":0,"index":5267},{"krate":0,"index":5268},{"krate":0,"index":5269},{"krate":0,"index":5270},{"krate":0,"index":5271},{"krate":0,"index":5272},{"krate":0,"index":5273},{"krate":0,"index":5274},{"krate":0,"index":5275},{"krate":0,"index":5276},{"krate":0,"index":5277},{"krate":0,"index":5278},{"krate":0,"index":5279},{"krate":0,"index":5280}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5181},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1214323,"byte_end":1214325,"line_start":10,"line_end":10,"column_start":8,"column_end":10},"name":"I0","qualname":"::bessel::I0","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the regular modified cylindrical Bessel function of zeroth order, I_0(x)\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5182},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1214492,"byte_end":1214496,"line_start":15,"line_end":15,"column_start":8,"column_end":12},"name":"I0_e","qualname":"::bessel::I0_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the regular modified cylindrical Bessel function of zeroth order, I_0(x)\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5183},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1214863,"byte_end":1214865,"line_start":23,"line_end":23,"column_start":8,"column_end":10},"name":"I1","qualname":"::bessel::I1","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the regular modified cylindrical Bessel function of first order, I_1(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5184},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1215032,"byte_end":1215036,"line_start":28,"line_end":28,"column_start":8,"column_end":12},"name":"I1_e","qualname":"::bessel::I1_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the regular modified cylindrical Bessel function of first order, I_1(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5185},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1215399,"byte_end":1215401,"line_start":36,"line_end":36,"column_start":8,"column_end":10},"name":"In","qualname":"::bessel::In","value":"fn (n: i32, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the regular modified cylindrical Bessel function of order n, I_n(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5186},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1215575,"byte_end":1215579,"line_start":41,"line_end":41,"column_start":8,"column_end":12},"name":"In_e","qualname":"::bessel::In_e","value":"fn (n: i32, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the regular modified cylindrical Bessel function of order n, I_n(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5187},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1216223,"byte_end":1216231,"line_start":51,"line_end":51,"column_start":8,"column_end":16},"name":"In_array","qualname":"::bessel::In_array","value":"fn (nmin: u32, nmax: u32, x: f64, result_array: &mut [f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the values of the regular modified cylindrical Bessel functions I_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array.\n The start of the range nmin must be positive or zero.\n The values are computed using recurrence relations for efficiency, and therefore may differ slightly from the exact values.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5188},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1216780,"byte_end":1216789,"line_start":60,"line_end":60,"column_start":8,"column_end":17},"name":"I0_scaled","qualname":"::bessel::I0_scaled","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled regular modified cylindrical Bessel function of zeroth order \\exp(-|x|) I_0(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5189},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1216981,"byte_end":1216992,"line_start":65,"line_end":65,"column_start":8,"column_end":19},"name":"I0_scaled_e","qualname":"::bessel::I0_scaled_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled regular modified cylindrical Bessel function of zeroth order \\exp(-|x|) I_0(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5190},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1217383,"byte_end":1217392,"line_start":73,"line_end":73,"column_start":8,"column_end":17},"name":"I1_scaled","qualname":"::bessel::I1_scaled","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled regular modified cylindrical Bessel function of first order \\exp(-|x|) I_1(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5191},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1217583,"byte_end":1217594,"line_start":78,"line_end":78,"column_start":8,"column_end":19},"name":"I1_scaled_e","qualname":"::bessel::I1_scaled_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled regular modified cylindrical Bessel function of first order \\exp(-|x|) I_1(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5192},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1217981,"byte_end":1217990,"line_start":86,"line_end":86,"column_start":8,"column_end":17},"name":"In_scaled","qualname":"::bessel::In_scaled","value":"fn (n: i32, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled regular modified cylindrical Bessel function of order n, \\exp(-|x|) I_n(x)\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5193},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1218188,"byte_end":1218199,"line_start":91,"line_end":91,"column_start":8,"column_end":19},"name":"In_scaled_e","qualname":"::bessel::In_scaled_e","value":"fn (n: i32, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled regular modified cylindrical Bessel function of order n, \\exp(-|x|) I_n(x)\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5194},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1218859,"byte_end":1218874,"line_start":101,"line_end":101,"column_start":8,"column_end":23},"name":"In_scaled_array","qualname":"::bessel::In_scaled_array","value":"fn (nmin: u32, nmax: u32, x: f64, result_array: &mut [f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the values of the scaled regular cylindrical Bessel functions \\exp(-|x|) I_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array.\n The start of the range nmin must be positive or zero.\n The values are computed using recurrence relations for efficiency, and therefore may differ slightly from the exact values.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5195},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1219450,"byte_end":1219459,"line_start":110,"line_end":110,"column_start":8,"column_end":17},"name":"i0_scaled","qualname":"::bessel::i0_scaled","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled regular modified spherical Bessel function of zeroth order, \\exp(-|x|) i_0(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5196},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1219650,"byte_end":1219661,"line_start":115,"line_end":115,"column_start":8,"column_end":19},"name":"i0_scaled_e","qualname":"::bessel::i0_scaled_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled regular modified spherical Bessel function of zeroth order, \\exp(-|x|) i_0(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5197},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1220051,"byte_end":1220060,"line_start":123,"line_end":123,"column_start":8,"column_end":17},"name":"i1_scaled","qualname":"::bessel::i1_scaled","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled regular modified spherical Bessel function of first order, \\exp(-|x|) i_1(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5198},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1220250,"byte_end":1220261,"line_start":128,"line_end":128,"column_start":8,"column_end":19},"name":"i1_scaled_e","qualname":"::bessel::i1_scaled_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled regular modified spherical Bessel function of first order, \\exp(-|x|) i_1(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5199},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1220651,"byte_end":1220660,"line_start":136,"line_end":136,"column_start":8,"column_end":17},"name":"i2_scaled","qualname":"::bessel::i2_scaled","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled regular modified spherical Bessel function of second order, \\exp(-|x|) i_2(x)\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5200},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1220850,"byte_end":1220861,"line_start":141,"line_end":141,"column_start":8,"column_end":19},"name":"i2_scaled_e","qualname":"::bessel::i2_scaled_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled regular modified spherical Bessel function of second order, \\exp(-|x|) i_2(x)\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5201},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1221246,"byte_end":1221255,"line_start":149,"line_end":149,"column_start":8,"column_end":17},"name":"il_scaled","qualname":"::bessel::il_scaled","value":"fn (l: i32, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled regular modified spherical Bessel function of order l, \\exp(-|x|) i_l(x)\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5202},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1221451,"byte_end":1221462,"line_start":154,"line_end":154,"column_start":8,"column_end":19},"name":"il_scaled_e","qualname":"::bessel::il_scaled_e","value":"fn (l: i32, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled regular modified spherical Bessel function of order l, \\exp(-|x|) i_l(x)\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5203},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1222080,"byte_end":1222095,"line_start":162,"line_end":162,"column_start":8,"column_end":23},"name":"il_scaled_array","qualname":"::bessel::il_scaled_array","value":"fn (lmax: u32, x: f64, result_array: &mut [f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the values of the scaled regular modified cylindrical Bessel functions \\exp(-|x|) i_l(x) for l from 0 to lmax inclusive for lmax >= 0, storing the results in the array result_array. The values are computed using recurrence relations for efficiency, and therefore may differ slightly from the exact values.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5204},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1222572,"byte_end":1222575,"line_start":170,"line_end":170,"column_start":8,"column_end":11},"name":"Inu","qualname":"::bessel::Inu","value":"fn (nu: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the regular modified Bessel function of fractional order \\nu, I_\\nu(x) for x>0, \\nu>0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5205},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1222770,"byte_end":1222775,"line_start":175,"line_end":175,"column_start":8,"column_end":13},"name":"Inu_e","qualname":"::bessel::Inu_e","value":"fn (nu: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the regular modified Bessel function of fractional order \\nu, I_\\nu(x) for x>0, \\nu>0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5206},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1223187,"byte_end":1223197,"line_start":183,"line_end":183,"column_start":8,"column_end":18},"name":"Inu_scaled","qualname":"::bessel::Inu_scaled","value":"fn (nu: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled regular modified Bessel function of fractional order \\nu, \\exp(-|x|)I_\\nu(x) for x>0, \\nu>0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5207},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1223416,"byte_end":1223428,"line_start":188,"line_end":188,"column_start":8,"column_end":20},"name":"Inu_scaled_e","qualname":"::bessel::Inu_scaled_e","value":"fn (nu: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled regular modified Bessel function of fractional order \\nu, \\exp(-|x|)I_\\nu(x) for x>0, \\nu>0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5208},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1223808,"byte_end":1223810,"line_start":196,"line_end":196,"column_start":8,"column_end":10},"name":"J0","qualname":"::bessel::J0","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the regular cylindrical Bessel function of zeroth order, J_0(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5209},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1223969,"byte_end":1223973,"line_start":201,"line_end":201,"column_start":8,"column_end":12},"name":"J0_e","qualname":"::bessel::J0_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the regular cylindrical Bessel function of zeroth order, J_0(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5210},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1224331,"byte_end":1224333,"line_start":209,"line_end":209,"column_start":8,"column_end":10},"name":"J1","qualname":"::bessel::J1","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the regular cylindrical Bessel function of first order, J_1(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5211},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1224491,"byte_end":1224495,"line_start":214,"line_end":214,"column_start":8,"column_end":12},"name":"J1_e","qualname":"::bessel::J1_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the regular cylindrical Bessel function of first order, J_1(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5212},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1224849,"byte_end":1224851,"line_start":222,"line_end":222,"column_start":8,"column_end":10},"name":"Jn","qualname":"::bessel::Jn","value":"fn (n: i32, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the regular cylindrical Bessel function of order n, J_n(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5213},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1225016,"byte_end":1225020,"line_start":227,"line_end":227,"column_start":8,"column_end":12},"name":"Jn_e","qualname":"::bessel::Jn_e","value":"fn (n: i32, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the regular cylindrical Bessel function of order n, J_n(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5214},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1225597,"byte_end":1225605,"line_start":236,"line_end":236,"column_start":8,"column_end":16},"name":"Jn_array","qualname":"::bessel::Jn_array","value":"fn (nmin: u32, nmax: u32, x: f64, result_array: &mut [f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the values of the regular cylindrical Bessel functions J_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array.\n The values are computed using recurrence relations for efficiency, and therefore may differ slightly from the exact values.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5215},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1225958,"byte_end":1225960,"line_start":242,"line_end":242,"column_start":8,"column_end":10},"name":"j0","qualname":"::bessel::j0","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the regular spherical Bessel function of zeroth order, j_0(x) = \\sin(x)/x.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5216},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1226129,"byte_end":1226133,"line_start":247,"line_end":247,"column_start":8,"column_end":12},"name":"j0_e","qualname":"::bessel::j0_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the regular spherical Bessel function of zeroth order, j_0(x) = \\sin(x)/x.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5217},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1226515,"byte_end":1226517,"line_start":255,"line_end":255,"column_start":8,"column_end":10},"name":"j1","qualname":"::bessel::j1","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the regular spherical Bessel function of first order, j_1(x) = (\\sin(x)/x - \\cos(x))/x.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5218},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1226699,"byte_end":1226703,"line_start":260,"line_end":260,"column_start":8,"column_end":12},"name":"j1_e","qualname":"::bessel::j1_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the regular spherical Bessel function of first order, j_1(x) = (\\sin(x)/x - \\cos(x))/x.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5219},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1227098,"byte_end":1227100,"line_start":268,"line_end":268,"column_start":8,"column_end":10},"name":"j2","qualname":"::bessel::j2","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the regular spherical Bessel function of second order, j_2(x) = ((3/x^2 - 1)\\sin(x) - 3\\cos(x)/x)/x.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5220},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1227295,"byte_end":1227299,"line_start":273,"line_end":273,"column_start":8,"column_end":12},"name":"j2_e","qualname":"::bessel::j2_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the regular spherical Bessel function of second order, j_2(x) = ((3/x^2 - 1)\\sin(x) - 3\\cos(x)/x)/x.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5221},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1227674,"byte_end":1227676,"line_start":281,"line_end":281,"column_start":8,"column_end":10},"name":"jl","qualname":"::bessel::jl","value":"fn (l: i32, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the regular spherical Bessel function of order l, j_l(x), for l >= 0 and x >= 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5222},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1227862,"byte_end":1227866,"line_start":286,"line_end":286,"column_start":8,"column_end":12},"name":"jl_e","qualname":"::bessel::jl_e","value":"fn (l: i32, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the regular spherical Bessel function of order l, j_l(x), for l >= 0 and x >= 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5223},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1228463,"byte_end":1228471,"line_start":295,"line_end":295,"column_start":8,"column_end":16},"name":"jl_array","qualname":"::bessel::jl_array","value":"fn (lmax: u32, x: f64, result_array: &mut [f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the values of the regular spherical Bessel functions j_l(x) for l from 0 to lmax inclusive for lmax >= 0 and x >= 0, storing the results in the array result_array.\n The values are computed using recurrence relations for efficiency, and therefore may differ slightly from the exact values.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5224},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1229090,"byte_end":1229104,"line_start":302,"line_end":302,"column_start":8,"column_end":22},"name":"jl_steed_array","qualname":"::bessel::jl_steed_array","value":"fn (lmax: u32, x: f64, result_array: &mut [f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This routine uses Steed’s method to compute the values of the regular spherical Bessel functions j_l(x) for l from 0 to lmax inclusive for lmax >= 0 and x >= 0, storing the results in the array result_array.\n The Steed/Barnett algorithm is described in Comp. Phys. Comm. 21, 297 (1981). Steed’s method is more stable than the recurrence used in the other functions but is also slower.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5225},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1229566,"byte_end":1229569,"line_start":310,"line_end":310,"column_start":8,"column_end":11},"name":"Jnu","qualname":"::bessel::Jnu","value":"fn (nu: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the regular cylindrical Bessel function of fractional order \\nu, J_\\nu(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5226},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1229752,"byte_end":1229757,"line_start":315,"line_end":315,"column_start":8,"column_end":13},"name":"Jnu_e","qualname":"::bessel::Jnu_e","value":"fn (nu: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the regular cylindrical Bessel function of fractional order \\nu, J_\\nu(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5227},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1230341,"byte_end":1230353,"line_start":324,"line_end":324,"column_start":8,"column_end":20},"name":"sequence_Jnu","qualname":"::bessel::sequence_Jnu","value":"fn (nu: f64, mode: ::Mode, v: &mut [f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the regular cylindrical Bessel function of fractional order \\nu, J_\\nu(x), evaluated at a series of x values. The array v of length size contains the x values.\n They are assumed to be strictly ordered and positive. The array is over-written with the values of J_\\nu(x_i).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5228},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1230842,"byte_end":1230844,"line_start":332,"line_end":332,"column_start":8,"column_end":10},"name":"K0","qualname":"::bessel::K0","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the irregular modified cylindrical Bessel function of zeroth order, K_0(x), for x > 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5229},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1231025,"byte_end":1231029,"line_start":337,"line_end":337,"column_start":8,"column_end":12},"name":"K0_e","qualname":"::bessel::K0_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the irregular modified cylindrical Bessel function of zeroth order, K_0(x), for x > 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5230},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1231409,"byte_end":1231411,"line_start":345,"line_end":345,"column_start":8,"column_end":10},"name":"K1","qualname":"::bessel::K1","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the irregular modified cylindrical Bessel function of first order, K_1(x), for x > 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5231},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1231591,"byte_end":1231595,"line_start":350,"line_end":350,"column_start":8,"column_end":12},"name":"K1_e","qualname":"::bessel::K1_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the irregular modified cylindrical Bessel function of first order, K_1(x), for x > 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5232},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1231971,"byte_end":1231973,"line_start":358,"line_end":358,"column_start":8,"column_end":10},"name":"Kn","qualname":"::bessel::Kn","value":"fn (n: i32, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the irregular modified cylindrical Bessel function of order n, K_n(x), for x > 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5233},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1232160,"byte_end":1232164,"line_start":363,"line_end":363,"column_start":8,"column_end":12},"name":"Kn_e","qualname":"::bessel::Kn_e","value":"fn (n: i32, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the irregular modified cylindrical Bessel function of order n, K_n(x), for x > 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5234},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1232845,"byte_end":1232853,"line_start":373,"line_end":373,"column_start":8,"column_end":16},"name":"Kn_array","qualname":"::bessel::Kn_array","value":"fn (nmin: u32, nmax: u32, x: f64, result_array: &mut [f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the values of the irregular modified cylindrical Bessel functions K_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array.\n The start of the range nmin must be positive or zero. The domain of the function is x>0.\n The values are computed using recurrence relations for efficiency, and therefore may differ slightly from the exact values.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5235},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1233409,"byte_end":1233418,"line_start":382,"line_end":382,"column_start":8,"column_end":17},"name":"K0_scaled","qualname":"::bessel::K0_scaled","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled irregular modified cylindrical Bessel function of zeroth order \\exp(x) K_0(x) for x>0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5236},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1233617,"byte_end":1233628,"line_start":387,"line_end":387,"column_start":8,"column_end":19},"name":"K0_scaled_e","qualname":"::bessel::K0_scaled_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled irregular modified cylindrical Bessel function of zeroth order \\exp(x) K_0(x) for x>0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5237},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1234026,"byte_end":1234035,"line_start":395,"line_end":395,"column_start":8,"column_end":17},"name":"K1_scaled","qualname":"::bessel::K1_scaled","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled irregular modified cylindrical Bessel function of first order \\exp(x) K_1(x) for x>0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5238},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1234233,"byte_end":1234244,"line_start":400,"line_end":400,"column_start":8,"column_end":19},"name":"K1_scaled_e","qualname":"::bessel::K1_scaled_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled irregular modified cylindrical Bessel function of first order \\exp(x) K_1(x) for x>0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5239},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1234640,"byte_end":1234649,"line_start":408,"line_end":408,"column_start":8,"column_end":17},"name":"Kn_scaled","qualname":"::bessel::Kn_scaled","value":"fn (n: i32, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled irregular modified cylindrical Bessel function of order n, \\exp(x) K_n(x), for x>0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5240},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1234856,"byte_end":1234867,"line_start":413,"line_end":413,"column_start":8,"column_end":19},"name":"Kn_scaled_e","qualname":"::bessel::Kn_scaled_e","value":"fn (n: i32, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled irregular modified cylindrical Bessel function of order n, \\exp(x) K_n(x), for x>0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5241},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1235561,"byte_end":1235576,"line_start":423,"line_end":423,"column_start":8,"column_end":23},"name":"Kn_scaled_array","qualname":"::bessel::Kn_scaled_array","value":"fn (nmin: u32, nmax: u32, x: f64, result_array: &mut [f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the values of the scaled irregular cylindrical Bessel functions \\exp(x) K_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array.\n The start of the range nmin must be positive or zero. The domain of the function is x>0.\n The values are computed using recurrence relations for efficiency, and therefore may differ slightly from the exact values.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5242},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1236336,"byte_end":1236345,"line_start":433,"line_end":433,"column_start":8,"column_end":17},"name":"k0_scaled","qualname":"::bessel::k0_scaled","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" The irregular modified spherical Bessel functions k_l(x) are related to the irregular modified Bessel functions of fractional order, k_l(x) = \\sqrt{\\pi/(2x)} K_{l+1/2}(x).\n This routine computes the scaled irregular modified spherical Bessel function of zeroth order, \\exp(x) k_0(x), for x>0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5243},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1236720,"byte_end":1236731,"line_start":439,"line_end":439,"column_start":8,"column_end":19},"name":"k0_scaled_e","qualname":"::bessel::k0_scaled_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" The irregular modified spherical Bessel functions k_l(x) are related to the irregular modified Bessel functions of fractional order, k_l(x) = \\sqrt{\\pi/(2x)} K_{l+1/2}(x).\n This routine computes the scaled irregular modified spherical Bessel function of zeroth order, \\exp(x) k_0(x), for x>0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5244},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1237129,"byte_end":1237138,"line_start":447,"line_end":447,"column_start":8,"column_end":17},"name":"k1_scaled","qualname":"::bessel::k1_scaled","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled irregular modified spherical Bessel function of first order, \\exp(x) k_1(x), for x>0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5245},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1237336,"byte_end":1237347,"line_start":452,"line_end":452,"column_start":8,"column_end":19},"name":"k1_scaled_e","qualname":"::bessel::k1_scaled_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled irregular modified spherical Bessel function of first order, \\exp(x) k_1(x), for x>0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5246},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1237746,"byte_end":1237755,"line_start":460,"line_end":460,"column_start":8,"column_end":17},"name":"k2_scaled","qualname":"::bessel::k2_scaled","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled irregular modified spherical Bessel function of second order, \\exp(x) k_2(x), for x>0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5247},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1237954,"byte_end":1237965,"line_start":465,"line_end":465,"column_start":8,"column_end":19},"name":"k2_scaled_e","qualname":"::bessel::k2_scaled_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled irregular modified spherical Bessel function of second order, \\exp(x) k_2(x), for x>0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5248},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1238359,"byte_end":1238368,"line_start":473,"line_end":473,"column_start":8,"column_end":17},"name":"kl_scaled","qualname":"::bessel::kl_scaled","value":"fn (l: i32, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled irregular modified spherical Bessel function of order l, \\exp(x) k_l(x), for x>0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5249},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1238573,"byte_end":1238584,"line_start":478,"line_end":478,"column_start":8,"column_end":19},"name":"kl_scaled_e","qualname":"::bessel::kl_scaled_e","value":"fn (l: i32, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled irregular modified spherical Bessel function of order l, \\exp(x) k_l(x), for x>0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5250},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1239211,"byte_end":1239226,"line_start":487,"line_end":487,"column_start":8,"column_end":23},"name":"kl_scaled_array","qualname":"::bessel::kl_scaled_array","value":"fn (lmax: u32, x: f64, result_array: &mut [f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the values of the scaled irregular modified spherical Bessel functions \\exp(x) k_l(x) for l from 0 to lmax inclusive for lmax >= 0 and x>0, storing the results in the array result_array.\n The values are computed using recurrence relations for efficiency, and therefore may differ slightly from the exact values.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5251},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1239705,"byte_end":1239708,"line_start":495,"line_end":495,"column_start":8,"column_end":11},"name":"Knu","qualname":"::bessel::Knu","value":"fn (nu: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the irregular modified Bessel function of fractional order \\nu, K_\\nu(x) for x>0, \\nu>0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5252},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1239905,"byte_end":1239910,"line_start":500,"line_end":500,"column_start":8,"column_end":13},"name":"Knu_e","qualname":"::bessel::Knu_e","value":"fn (nu: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the irregular modified Bessel function of fractional order \\nu, K_\\nu(x) for x>0, \\nu>0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5253},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1240329,"byte_end":1240334,"line_start":508,"line_end":508,"column_start":8,"column_end":13},"name":"lnKnu","qualname":"::bessel::lnKnu","value":"fn (nu: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the logarithm of the irregular modified Bessel function of fractional order \\nu, \\ln(K_\\nu(x)) for x>0, \\nu>0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5254},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1240555,"byte_end":1240562,"line_start":513,"line_end":513,"column_start":8,"column_end":15},"name":"lnKnu_e","qualname":"::bessel::lnKnu_e","value":"fn (nu: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the logarithm of the irregular modified Bessel function of fractional order \\nu, \\ln(K_\\nu(x)) for x>0, \\nu>0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5255},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1240979,"byte_end":1240989,"line_start":521,"line_end":521,"column_start":8,"column_end":18},"name":"Knu_scaled","qualname":"::bessel::Knu_scaled","value":"fn (nu: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled irregular modified Bessel function of fractional order \\nu, \\exp(+|x|) K_\\nu(x) for x>0, \\nu>0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5256},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1241211,"byte_end":1241223,"line_start":526,"line_end":526,"column_start":8,"column_end":20},"name":"Knu_scaled_e","qualname":"::bessel::Knu_scaled_e","value":"fn (nu: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the scaled irregular modified Bessel function of fractional order \\nu, \\exp(+|x|) K_\\nu(x) for x>0, \\nu>0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5257},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1241614,"byte_end":1241616,"line_start":534,"line_end":534,"column_start":8,"column_end":10},"name":"Y0","qualname":"::bessel::Y0","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the irregular cylindrical Bessel function of zeroth order, Y_0(x), for x>0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5258},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1241786,"byte_end":1241790,"line_start":539,"line_end":539,"column_start":8,"column_end":12},"name":"Y0_e","qualname":"::bessel::Y0_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the irregular cylindrical Bessel function of zeroth order, Y_0(x), for x>0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5259},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1242159,"byte_end":1242161,"line_start":547,"line_end":547,"column_start":8,"column_end":10},"name":"Y1","qualname":"::bessel::Y1","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the irregular cylindrical Bessel function of first order, Y_1(x), for x>0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5260},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1242330,"byte_end":1242334,"line_start":552,"line_end":552,"column_start":8,"column_end":12},"name":"Y1_e","qualname":"::bessel::Y1_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the irregular cylindrical Bessel function of first order, Y_1(x), for x>0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5261},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1242699,"byte_end":1242701,"line_start":560,"line_end":560,"column_start":8,"column_end":10},"name":"Yn","qualname":"::bessel::Yn","value":"fn (n: i32, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the irregular cylindrical Bessel function of order n, Y_n(x), for x>0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5262},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1242877,"byte_end":1242881,"line_start":565,"line_end":565,"column_start":8,"column_end":12},"name":"Yn_e","qualname":"::bessel::Yn_e","value":"fn (n: i32, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the irregular cylindrical Bessel function of order n, Y_n(x), for x>0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5263},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1243499,"byte_end":1243507,"line_start":575,"line_end":575,"column_start":8,"column_end":16},"name":"Yn_array","qualname":"::bessel::Yn_array","value":"fn (nmin: u32, nmax: u32, x: f64, result_array: &mut [f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the values of the irregular cylindrical Bessel functions Y_n(x) for n from nmin to nmax inclusive, storing the results in the array result_array.\n The domain of the function is x>0.\n The values are computed using recurrence relations for efficiency, and therefore may differ slightly from the exact values.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5264},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1244043,"byte_end":1244045,"line_start":584,"line_end":584,"column_start":8,"column_end":10},"name":"y0","qualname":"::bessel::y0","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the irregular spherical Bessel function of zeroth order, y_0(x) = -\\cos(x)/x.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5265},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1244217,"byte_end":1244221,"line_start":589,"line_end":589,"column_start":8,"column_end":12},"name":"y0_e","qualname":"::bessel::y0_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the irregular spherical Bessel function of zeroth order, y_0(x) = -\\cos(x)/x.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5266},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1244606,"byte_end":1244608,"line_start":597,"line_end":597,"column_start":8,"column_end":10},"name":"y1","qualname":"::bessel::y1","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the irregular spherical Bessel function of first order, y_1(x) = -(\\cos(x)/x + \\sin(x))/x.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5267},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1244793,"byte_end":1244797,"line_start":602,"line_end":602,"column_start":8,"column_end":12},"name":"y1_e","qualname":"::bessel::y1_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the irregular spherical Bessel function of first order, y_1(x) = -(\\cos(x)/x + \\sin(x))/x.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5268},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1245197,"byte_end":1245199,"line_start":610,"line_end":610,"column_start":8,"column_end":10},"name":"y2","qualname":"::bessel::y2","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the irregular spherical Bessel function of second order, y_2(x) = (-3/x^3 + 1/x)\\cos(x) - (3/x^2)\\sin(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5269},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1245399,"byte_end":1245403,"line_start":615,"line_end":615,"column_start":8,"column_end":12},"name":"y2_e","qualname":"::bessel::y2_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the irregular spherical Bessel function of second order, y_2(x) = (-3/x^3 + 1/x)\\cos(x) - (3/x^2)\\sin(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5270},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1245769,"byte_end":1245771,"line_start":623,"line_end":623,"column_start":8,"column_end":10},"name":"yl","qualname":"::bessel::yl","value":"fn (l: i32, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the irregular spherical Bessel function of order l, y_l(x), for l >= 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5271},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1245948,"byte_end":1245952,"line_start":628,"line_end":628,"column_start":8,"column_end":12},"name":"yl_e","qualname":"::bessel::yl_e","value":"fn (l: i32, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the irregular spherical Bessel function of order l, y_l(x), for l >= 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5272},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1246540,"byte_end":1246548,"line_start":637,"line_end":637,"column_start":8,"column_end":16},"name":"yl_array","qualname":"::bessel::yl_array","value":"fn (lmax: u32, x: f64, result_array: &mut [f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the values of the irregular spherical Bessel functions y_l(x) for l from 0 to lmax inclusive for lmax >= 0, storing the results in the array result_array.\n The values are computed using recurrence relations for efficiency, and therefore may differ slightly from the exact values.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5273},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1246874,"byte_end":1246877,"line_start":643,"line_end":643,"column_start":8,"column_end":11},"name":"Ynu","qualname":"::bessel::Ynu","value":"fn (nu: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the irregular cylindrical Bessel function of fractional order \\nu, Y_\\nu(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5274},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1247062,"byte_end":1247067,"line_start":648,"line_end":648,"column_start":8,"column_end":13},"name":"Ynu_e","qualname":"::bessel::Ynu_e","value":"fn (nu: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the irregular cylindrical Bessel function of fractional order \\nu, Y_\\nu(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5275},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1247445,"byte_end":1247452,"line_start":656,"line_end":656,"column_start":8,"column_end":15},"name":"zero_J0","qualname":"::bessel::zero_J0","value":"fn (s: u32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the location of the s-th positive zero of the Bessel function J_0(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5276},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1247621,"byte_end":1247630,"line_start":661,"line_end":661,"column_start":8,"column_end":17},"name":"zero_J0_e","qualname":"::bessel::zero_J0_e","value":"fn (s: u32) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the location of the s-th positive zero of the Bessel function J_0(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5277},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1247999,"byte_end":1248006,"line_start":669,"line_end":669,"column_start":8,"column_end":15},"name":"zero_J1","qualname":"::bessel::zero_J1","value":"fn (s: u32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the location of the s-th positive zero of the Bessel function J_1(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5278},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1248175,"byte_end":1248184,"line_start":674,"line_end":674,"column_start":8,"column_end":17},"name":"zero_J1_e","qualname":"::bessel::zero_J1_e","value":"fn (s: u32) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the location of the s-th positive zero of the Bessel function J_1(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5279},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1248626,"byte_end":1248634,"line_start":683,"line_end":683,"column_start":8,"column_end":16},"name":"zero_Jnu","qualname":"::bessel::zero_Jnu","value":"fn (nu: f64, s: u32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the location of the s-th positive zero of the Bessel function J_\\nu(x).\n The current implementation does not support negative values of nu.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5280},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/bessel.rs","byte_start":1248890,"byte_end":1248900,"line_start":689,"line_end":689,"column_start":8,"column_end":18},"name":"zero_Jnu_e","qualname":"::bessel::zero_Jnu_e","value":"fn (nu: f64, s: u32) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the location of the s-th positive zero of the Bessel function J_\\nu(x).\n The current implementation does not support negative values of nu.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5281},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"blas","qualname":"::blas","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","parent":null,"children":[{"krate":0,"index":5282},{"krate":0,"index":5330},{"krate":0,"index":5362}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5282},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1249281,"byte_end":1249287,"line_start":5,"line_end":5,"column_start":9,"column_end":15},"name":"level1","qualname":"::blas::level1","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","parent":null,"children":[{"krate":0,"index":5283},{"krate":0,"index":5284},{"krate":0,"index":5285},{"krate":0,"index":5286},{"krate":0,"index":5287},{"krate":0,"index":5288},{"krate":0,"index":5289},{"krate":0,"index":5290},{"krate":0,"index":5291},{"krate":0,"index":5292},{"krate":0,"index":5293},{"krate":0,"index":5294},{"krate":0,"index":5295},{"krate":0,"index":5296},{"krate":0,"index":5297},{"krate":0,"index":5298},{"krate":0,"index":5299},{"krate":0,"index":5300},{"krate":0,"index":5301},{"krate":0,"index":5302},{"krate":0,"index":5303},{"krate":0,"index":5304},{"krate":0,"index":5305},{"krate":0,"index":5306},{"krate":0,"index":5307},{"krate":0,"index":5308},{"krate":0,"index":5309},{"krate":0,"index":5310},{"krate":0,"index":5311},{"krate":0,"index":5312},{"krate":0,"index":5313},{"krate":0,"index":5314},{"krate":0,"index":5315},{"krate":0,"index":5316},{"krate":0,"index":5317},{"krate":0,"index":5318},{"krate":0,"index":5319},{"krate":0,"index":5320},{"krate":0,"index":5321},{"krate":0,"index":5322},{"krate":0,"index":5323},{"krate":0,"index":5324},{"krate":0,"index":5325},{"krate":0,"index":5326},{"krate":0,"index":5327},{"krate":0,"index":5328},{"krate":0,"index":5329}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5284},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1249428,"byte_end":1249434,"line_start":9,"line_end":9,"column_start":12,"column_end":18},"name":"sdsdot","qualname":"::blas::level1::sdsdot","value":"fn (alpha: f32, x: &::types::VectorF32, y: &::types::VectorF32, result: &mut f32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the sum \\alpha + x^T y for the vectors x and y, returning the result in result.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5285},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1249996,"byte_end":1250000,"line_start":23,"line_end":23,"column_start":12,"column_end":16},"name":"sdot","qualname":"::blas::level1::sdot","value":"fn (x: &::types::VectorF32, y: &::types::VectorF32, result: &mut f32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the scalar product x^T y for the vectors x and y, returning the result in result.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5286},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1250430,"byte_end":1250435,"line_start":32,"line_end":32,"column_start":12,"column_end":17},"name":"dsdot","qualname":"::blas::level1::dsdot","value":"fn (x: &::types::VectorF32, y: &::types::VectorF32, result: &mut f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the scalar product x^T y for the vectors x and y, returning the result in result.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5287},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1250868,"byte_end":1250872,"line_start":41,"line_end":41,"column_start":12,"column_end":16},"name":"ddot","qualname":"::blas::level1::ddot","value":"fn (x: &::types::VectorF64, y: &::types::VectorF64, result: &mut f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the scalar product x^T y for the vectors x and y, returning the result in result.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5288},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1251308,"byte_end":1251313,"line_start":50,"line_end":50,"column_start":12,"column_end":17},"name":"cdotu","qualname":"::blas::level1::cdotu","value":"fn (x: &::types::VectorComplexF32, y: &::types::VectorComplexF32, dotu: &mut ::types::ComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the complex scalar product x^T y for the vectors x and y, returning the result in dotu.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5289},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1251852,"byte_end":1251857,"line_start":62,"line_end":62,"column_start":12,"column_end":17},"name":"zdotu","qualname":"::blas::level1::zdotu","value":"fn (x: &::types::VectorComplexF64, y: &::types::VectorComplexF64, dotu: &mut ::types::ComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the complex scalar product x^T y for the vectors x and y, returning the result in dotu.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5290},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1252406,"byte_end":1252411,"line_start":74,"line_end":74,"column_start":12,"column_end":17},"name":"cdotc","qualname":"::blas::level1::cdotc","value":"fn (x: &::types::VectorComplexF32, y: &::types::VectorComplexF32, dotc: &mut ::types::ComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the complex conjugate scalar product x^H y for the vectors x and y, returning the result in dotc.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5291},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1252960,"byte_end":1252965,"line_start":86,"line_end":86,"column_start":12,"column_end":17},"name":"zdotc","qualname":"::blas::level1::zdotc","value":"fn (x: &::types::VectorComplexF64, y: &::types::VectorComplexF64, dotc: &mut ::types::ComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the complex conjugate scalar product x^H y for the vectors x and y, returning the result in dotc.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5292},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1253481,"byte_end":1253486,"line_start":98,"line_end":98,"column_start":12,"column_end":17},"name":"snrm2","qualname":"::blas::level1::snrm2","value":"fn (x: &::types::VectorF32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" This function computes the Euclidean norm ||x||_2 = \\sqrt {\\sum x_i^2} of the vector x.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5293},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1253705,"byte_end":1253710,"line_start":103,"line_end":103,"column_start":12,"column_end":17},"name":"dnrm2","qualname":"::blas::level1::dnrm2","value":"fn (x: &::types::VectorF64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the Euclidean norm ||x||_2 = \\sqrt {\\sum x_i^2} of the vector x.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5294},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1253974,"byte_end":1253980,"line_start":110,"line_end":110,"column_start":12,"column_end":18},"name":"scnrm2","qualname":"::blas::level1::scnrm2","value":"fn (x: &::types::VectorComplexF32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" This function computes the Euclidean norm of the complex vector x,","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5295},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1254252,"byte_end":1254258,"line_start":117,"line_end":117,"column_start":12,"column_end":18},"name":"dznrm2","qualname":"::blas::level1::dznrm2","value":"fn (x: &::types::VectorComplexF64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the Euclidean norm of the complex vector x,","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5296},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1254481,"byte_end":1254486,"line_start":122,"line_end":122,"column_start":12,"column_end":17},"name":"sasum","qualname":"::blas::level1::sasum","value":"fn (x: &::types::VectorF32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" This function computes the absolute sum \\sum |x_i| of the elements of the vector x.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5297},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1254701,"byte_end":1254706,"line_start":127,"line_end":127,"column_start":12,"column_end":17},"name":"dasum","qualname":"::blas::level1::dasum","value":"fn (x: &::types::VectorF64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the absolute sum \\sum |x_i| of the elements of the vector x.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5298},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1254973,"byte_end":1254979,"line_start":132,"line_end":132,"column_start":12,"column_end":18},"name":"scasum","qualname":"::blas::level1::scasum","value":"fn (x: &::types::VectorComplexF32) -> f32","parent":null,"children":[],"decl_id":null,"docs":" This function computes the sum of the magnitudes of the real and imaginary parts of the complex vector x, \\sum |\\Re(x_i)| + |\\Im(x_i)|.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5299},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1255254,"byte_end":1255260,"line_start":137,"line_end":137,"column_start":12,"column_end":18},"name":"dzasum","qualname":"::blas::level1::dzasum","value":"fn (x: &::types::VectorComplexF64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the sum of the magnitudes of the real and imaginary parts of the complex vector x, \\sum |\\Re(x_i)| + |\\Im(x_i)|.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5300},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1255768,"byte_end":1255774,"line_start":144,"line_end":144,"column_start":12,"column_end":18},"name":"isamax","qualname":"::blas::level1::isamax","value":"fn (x: &::types::VectorF32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the index of the largest element of the vector x.\n The largest element is determined by its absolute magnitude for real vectors and by the sum of the magnitudes of the real and imaginary parts |\\Re(x_i)| + |\\Im(x_i)| for complex vectors.\n If the largest value occurs several times then the index of the first occurrence is returned.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5301},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1256275,"byte_end":1256281,"line_start":151,"line_end":151,"column_start":12,"column_end":18},"name":"idamax","qualname":"::blas::level1::idamax","value":"fn (x: &::types::VectorF64) -> u32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the index of the largest element of the vector x.\n The largest element is determined by its absolute magnitude for real vectors and by the sum of the magnitudes of the real and imaginary parts |\\Re(x_i)| + |\\Im(x_i)| for complex vectors.\n If the largest value occurs several times then the index of the first occurrence is returned.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5302},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1256782,"byte_end":1256788,"line_start":158,"line_end":158,"column_start":12,"column_end":18},"name":"icamax","qualname":"::blas::level1::icamax","value":"fn (x: &::types::VectorComplexF32) -> u32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the index of the largest element of the vector x.\n The largest element is determined by its absolute magnitude for real vectors and by the sum of the magnitudes of the real and imaginary parts |\\Re(x_i)| + |\\Im(x_i)| for complex vectors.\n If the largest value occurs several times then the index of the first occurrence is returned.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5303},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1257296,"byte_end":1257302,"line_start":165,"line_end":165,"column_start":12,"column_end":18},"name":"izamax","qualname":"::blas::level1::izamax","value":"fn (x: &::types::VectorComplexF64) -> u32","parent":null,"children":[],"decl_id":null,"docs":" This function returns the index of the largest element of the vector x.\n The largest element is determined by its absolute magnitude for real vectors and by the sum of the magnitudes of the real and imaginary parts |\\Re(x_i)| + |\\Im(x_i)| for complex vectors.\n If the largest value occurs several times then the index of the first occurrence is returned.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5304},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1257502,"byte_end":1257507,"line_start":170,"line_end":170,"column_start":12,"column_end":17},"name":"sswap","qualname":"::blas::level1::sswap","value":"fn (x: &mut ::types::VectorF32, y: &mut ::types::VectorF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function exchanges the elements of the vectors x and y.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5305},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1257848,"byte_end":1257853,"line_start":176,"line_end":176,"column_start":12,"column_end":17},"name":"dswap","qualname":"::blas::level1::dswap","value":"fn (x: &mut ::types::VectorF64, y: &mut ::types::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function exchanges the elements of the vectors x and y.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5306},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1258194,"byte_end":1258199,"line_start":182,"line_end":182,"column_start":12,"column_end":17},"name":"cswap","qualname":"::blas::level1::cswap","value":"fn (x: &mut ::types::VectorComplexF32, y: &mut ::types::VectorComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function exchanges the elements of the vectors x and y.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5307},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1258588,"byte_end":1258593,"line_start":190,"line_end":190,"column_start":12,"column_end":17},"name":"zswap","qualname":"::blas::level1::zswap","value":"fn (x: &mut ::types::VectorComplexF64, y: &mut ::types::VectorComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function exchanges the elements of the vectors x and y.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5308},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1258988,"byte_end":1258993,"line_start":198,"line_end":198,"column_start":12,"column_end":17},"name":"scopy","qualname":"::blas::level1::scopy","value":"fn (x: &mut ::types::VectorF32, y: &mut ::types::VectorF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copy the elements of the vector x into the vector y.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5309},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1259340,"byte_end":1259345,"line_start":204,"line_end":204,"column_start":12,"column_end":17},"name":"dcopy","qualname":"::blas::level1::dcopy","value":"fn (x: &mut ::types::VectorF64, y: &mut ::types::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copy the elements of the vector x into the vector y.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5310},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1259692,"byte_end":1259697,"line_start":210,"line_end":210,"column_start":12,"column_end":17},"name":"ccopy","qualname":"::blas::level1::ccopy","value":"fn (x: &mut ::types::VectorComplexF32, y: &mut ::types::VectorComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copy the elements of the vector x into the vector y.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5311},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1260092,"byte_end":1260097,"line_start":218,"line_end":218,"column_start":12,"column_end":17},"name":"zcopy","qualname":"::blas::level1::zcopy","value":"fn (x: &mut ::types::VectorComplexF64, y: &mut ::types::VectorComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copy the elements of the vector x into the vector y.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5312},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1260498,"byte_end":1260503,"line_start":226,"line_end":226,"column_start":12,"column_end":17},"name":"saxpy","qualname":"::blas::level1::saxpy","value":"fn (alpha: f32, x: &::types::VectorF32, y: &mut ::types::VectorF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the sum y = \\alpha x + y for the vectors x and y.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5313},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1260901,"byte_end":1260906,"line_start":235,"line_end":235,"column_start":12,"column_end":17},"name":"daxpy","qualname":"::blas::level1::daxpy","value":"fn (alpha: f64, x: &::types::VectorF64, y: &mut ::types::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the sum y = \\alpha x + y for the vectors x and y.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5314},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1261304,"byte_end":1261309,"line_start":244,"line_end":244,"column_start":12,"column_end":17},"name":"caxpy","qualname":"::blas::level1::caxpy","value":"fn (alpha: &::types::ComplexF32, x: &::types::VectorComplexF32, y: &mut ::types::VectorComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the sum y = \\alpha x + y for the vectors x and y.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5315},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1261813,"byte_end":1261818,"line_start":256,"line_end":256,"column_start":12,"column_end":17},"name":"zaxpy","qualname":"::blas::level1::zaxpy","value":"fn (alpha: &::types::ComplexF64, x: &::types::VectorComplexF64, y: &mut ::types::VectorComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the sum y = \\alpha x + y for the vectors x and y.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5316},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1262321,"byte_end":1262326,"line_start":268,"line_end":268,"column_start":12,"column_end":17},"name":"sscal","qualname":"::blas::level1::sscal","value":"fn (alpha: f32, x: &mut ::types::VectorF32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function rescales the vector x by the multiplicative factor alpha.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5317},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1262545,"byte_end":1262550,"line_start":273,"line_end":273,"column_start":12,"column_end":17},"name":"dscal","qualname":"::blas::level1::dscal","value":"fn (alpha: f64, x: &mut ::types::VectorF64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function rescales the vector x by the multiplicative factor alpha.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5318},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1262769,"byte_end":1262774,"line_start":278,"line_end":278,"column_start":12,"column_end":17},"name":"cscal","qualname":"::blas::level1::cscal","value":"fn (alpha: &::types::ComplexF32, x: &mut ::types::VectorComplexF32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function rescales the vector x by the multiplicative factor alpha.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5319},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1263061,"byte_end":1263066,"line_start":285,"line_end":285,"column_start":12,"column_end":17},"name":"zscal","qualname":"::blas::level1::zscal","value":"fn (alpha: &::types::ComplexF64, x: &mut ::types::VectorComplexF64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function rescales the vector x by the multiplicative factor alpha.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5320},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1263353,"byte_end":1263359,"line_start":292,"line_end":292,"column_start":12,"column_end":18},"name":"csscal","qualname":"::blas::level1::csscal","value":"fn (alpha: f32, x: &mut ::types::VectorComplexF32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function rescales the vector x by the multiplicative factor alpha.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5321},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1263586,"byte_end":1263592,"line_start":297,"line_end":297,"column_start":12,"column_end":18},"name":"zdscal","qualname":"::blas::level1::zdscal","value":"fn (alpha: f64, x: &mut ::types::VectorComplexF64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function rescales the vector x by the multiplicative factor alpha.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5322},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1263975,"byte_end":1263980,"line_start":308,"line_end":308,"column_start":12,"column_end":17},"name":"srotg","qualname":"::blas::level1::srotg","value":"fn (a: &mut [f32], b: &mut [f32], c: &mut [f32], d: &mut [f32]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes a Givens rotation (c,s) which zeroes the vector (a,b),","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5323},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1264560,"byte_end":1264565,"line_start":324,"line_end":324,"column_start":12,"column_end":17},"name":"drotg","qualname":"::blas::level1::drotg","value":"fn (a: &mut [f64], b: &mut [f64], c: &mut [f64], d: &mut [f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes a Givens rotation (c,s) which zeroes the vector (a,b),","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5324},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1265013,"byte_end":1265017,"line_start":334,"line_end":334,"column_start":12,"column_end":16},"name":"srot","qualname":"::blas::level1::srot","value":"fn (a: &mut ::types::VectorF32, b: &mut ::types::VectorF32, c: f32, d: f32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function applies a Givens rotation (x', y') = (c x + s y, -s x + c y) to the vectors x, y.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5325},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1265539,"byte_end":1265543,"line_start":348,"line_end":348,"column_start":12,"column_end":16},"name":"drot","qualname":"::blas::level1::drot","value":"fn (a: &mut ::types::VectorF64, b: &mut ::types::VectorF64, c: f64, d: f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function applies a Givens rotation (x', y') = (c x + s y, -s x + c y) to the vectors x, y.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5326},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1266149,"byte_end":1266155,"line_start":363,"line_end":363,"column_start":12,"column_end":18},"name":"srotmg","qualname":"::blas::level1::srotmg","value":"fn (d1: &mut [f32], d2: &mut [f32], b1: &mut [f32], b2: f32, P: &mut [f32]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes a modified Givens transformation.\n The modified Givens transformation is defined in the original Level-1 BLAS specification, given in the references.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5327},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1266835,"byte_end":1266841,"line_start":380,"line_end":380,"column_start":12,"column_end":18},"name":"drotmg","qualname":"::blas::level1::drotmg","value":"fn (d1: &mut [f64], d2: &mut [f64], b1: &mut [f64], b2: f64, P: &mut [f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes a modified Givens transformation.\n The modified Givens transformation is defined in the original Level-1 BLAS specification, given in the references.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5328},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1267397,"byte_end":1267402,"line_start":396,"line_end":396,"column_start":12,"column_end":17},"name":"srotm","qualname":"::blas::level1::srotm","value":"fn (x: &mut ::types::VectorF32, y: &mut ::types::VectorF32, P: &mut [f32]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function applies a modified Givens transformation.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5329},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1267850,"byte_end":1267855,"line_start":408,"line_end":408,"column_start":12,"column_end":17},"name":"drotm","qualname":"::blas::level1::drotm","value":"fn (x: &mut ::types::VectorF64, y: &mut ::types::VectorF64, P: &mut [f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function applies a modified Givens transformation.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5330},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1268238,"byte_end":1268244,"line_start":420,"line_end":420,"column_start":9,"column_end":15},"name":"level2","qualname":"::blas::level2","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","parent":null,"children":[{"krate":0,"index":5331},{"krate":0,"index":5332},{"krate":0,"index":5333},{"krate":0,"index":5334},{"krate":0,"index":5335},{"krate":0,"index":5336},{"krate":0,"index":5337},{"krate":0,"index":5338},{"krate":0,"index":5339},{"krate":0,"index":5340},{"krate":0,"index":5341},{"krate":0,"index":5342},{"krate":0,"index":5343},{"krate":0,"index":5344},{"krate":0,"index":5345},{"krate":0,"index":5346},{"krate":0,"index":5347},{"krate":0,"index":5348},{"krate":0,"index":5349},{"krate":0,"index":5350},{"krate":0,"index":5351},{"krate":0,"index":5352},{"krate":0,"index":5353},{"krate":0,"index":5354},{"krate":0,"index":5355},{"krate":0,"index":5356},{"krate":0,"index":5357},{"krate":0,"index":5358},{"krate":0,"index":5359},{"krate":0,"index":5360},{"krate":0,"index":5361}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5332},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1268450,"byte_end":1268455,"line_start":424,"line_end":424,"column_start":12,"column_end":17},"name":"sgemv","qualname":"::blas::level2::sgemv","value":"fn (transA: ::cblas::Transpose, alpha: f32, A: &::types::MatrixF32, x: &::types::VectorF32, beta: f32, y: &mut ::types::VectorF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the matrix-vector product and sum y = \\alpha op(A) x + \\beta y, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5333},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1269259,"byte_end":1269264,"line_start":442,"line_end":442,"column_start":12,"column_end":17},"name":"dgemv","qualname":"::blas::level2::dgemv","value":"fn (transA: ::cblas::Transpose, alpha: f64, A: &::types::MatrixF64, x: &::types::VectorF64, beta: f64, y: &mut ::types::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the matrix-vector product and sum y = \\alpha op(A) x + \\beta y, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5334},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1270068,"byte_end":1270073,"line_start":460,"line_end":460,"column_start":12,"column_end":17},"name":"cgemv","qualname":"::blas::level2::cgemv","value":"fn (transA: ::cblas::Transpose, alpha: &::types::ComplexF32, A: &::types::MatrixComplexF32, x: &::types::VectorComplexF32, beta: &::types::ComplexF32, y: &mut ::types::VectorComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the matrix-vector product and sum y = \\alpha op(A) x + \\beta y, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5335},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1270980,"byte_end":1270985,"line_start":478,"line_end":478,"column_start":12,"column_end":17},"name":"zgemv","qualname":"::blas::level2::zgemv","value":"fn (transA: ::cblas::Transpose, alpha: &::types::ComplexF64, A: &::types::MatrixComplexF64, x: &::types::VectorComplexF64, beta: &::types::ComplexF64, y: &mut ::types::VectorComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the matrix-vector product and sum y = \\alpha op(A) x + \\beta y, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5336},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1272215,"byte_end":1272220,"line_start":498,"line_end":498,"column_start":12,"column_end":17},"name":"strmv","qualname":"::blas::level2::strmv","value":"fn (uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, A: &::types::MatrixF32, x: &mut ::types::VectorF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the matrix-vector product x = op(A) x for the triangular matrix A, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans.\n When Uplo is CblasUpper then the upper triangle of A is used, and when Uplo is CblasLower then the lower triangle of A is used.\n If Diag is CblasNonUnit then the diagonal of the matrix is used, but if Diag is CblasUnit then the diagonal elements of the matrix A are taken as unity and are not referenced.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5337},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1273260,"byte_end":1273265,"line_start":516,"line_end":516,"column_start":12,"column_end":17},"name":"dtrmv","qualname":"::blas::level2::dtrmv","value":"fn (uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, A: &::types::MatrixF64, x: &mut ::types::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the matrix-vector product x = op(A) x for the triangular matrix A, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans.\n When Uplo is CblasUpper then the upper triangle of A is used, and when Uplo is CblasLower then the lower triangle of A is used.\n If Diag is CblasNonUnit then the diagonal of the matrix is used, but if Diag is CblasUnit then the diagonal elements of the matrix A are taken as unity and are not referenced.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5338},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1274305,"byte_end":1274310,"line_start":534,"line_end":534,"column_start":12,"column_end":17},"name":"ctrmv","qualname":"::blas::level2::ctrmv","value":"fn (uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, A: &::types::MatrixComplexF32, x: &mut ::types::VectorComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the matrix-vector product x = op(A) x for the triangular matrix A, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans.\n When Uplo is CblasUpper then the upper triangle of A is used, and when Uplo is CblasLower then the lower triangle of A is used.\n If Diag is CblasNonUnit then the diagonal of the matrix is used, but if Diag is CblasUnit then the diagonal elements of the matrix A are taken as unity and are not referenced.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5339},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1275364,"byte_end":1275369,"line_start":552,"line_end":552,"column_start":12,"column_end":17},"name":"ztrmv","qualname":"::blas::level2::ztrmv","value":"fn (uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, A: &::types::MatrixComplexF64, x: &mut ::types::VectorComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the matrix-vector product x = op(A) x for the triangular matrix A, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans.\n When Uplo is CblasUpper then the upper triangle of A is used, and when Uplo is CblasLower then the lower triangle of A is used.\n If Diag is CblasNonUnit then the diagonal of the matrix is used, but if Diag is CblasUnit then the diagonal elements of the matrix A are taken as unity and are not referenced.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5340},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1276376,"byte_end":1276381,"line_start":570,"line_end":570,"column_start":12,"column_end":17},"name":"strsv","qualname":"::blas::level2::strsv","value":"fn (uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, A: &::types::MatrixF32, x: &mut ::types::VectorF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes inv(op(A)) x for x, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans.\n When Uplo is CblasUpper then the upper triangle of A is used, and when Uplo is CblasLower then the lower triangle of A is used.\n If Diag is CblasNonUnit then the diagonal of the matrix is used, but if Diag is CblasUnit then the diagonal elements of the matrix A are taken as unity and are not referenced.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5341},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1277374,"byte_end":1277379,"line_start":588,"line_end":588,"column_start":12,"column_end":17},"name":"dtrsv","qualname":"::blas::level2::dtrsv","value":"fn (uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, A: &::types::MatrixF64, x: &mut ::types::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes inv(op(A)) x for x, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans.\n When Uplo is CblasUpper then the upper triangle of A is used, and when Uplo is CblasLower then the lower triangle of A is used.\n If Diag is CblasNonUnit then the diagonal of the matrix is used, but if Diag is CblasUnit then the diagonal elements of the matrix A are taken as unity and are not referenced.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5342},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1278372,"byte_end":1278377,"line_start":606,"line_end":606,"column_start":12,"column_end":17},"name":"ctrsv","qualname":"::blas::level2::ctrsv","value":"fn (uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, A: &::types::MatrixComplexF32, x: &mut ::types::VectorComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes inv(op(A)) x for x, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans.\n When Uplo is CblasUpper then the upper triangle of A is used, and when Uplo is CblasLower then the lower triangle of A is used.\n If Diag is CblasNonUnit then the diagonal of the matrix is used, but if Diag is CblasUnit then the diagonal elements of the matrix A are taken as unity and are not referenced.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5343},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1279384,"byte_end":1279389,"line_start":624,"line_end":624,"column_start":12,"column_end":17},"name":"ztrsv","qualname":"::blas::level2::ztrsv","value":"fn (uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, A: &::types::MatrixComplexF64, x: &mut ::types::VectorComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes inv(op(A)) x for x, where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans.\n When Uplo is CblasUpper then the upper triangle of A is used, and when Uplo is CblasLower then the lower triangle of A is used.\n If Diag is CblasNonUnit then the diagonal of the matrix is used, but if Diag is CblasUnit then the diagonal elements of the matrix A are taken as unity and are not referenced.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5344},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1280320,"byte_end":1280325,"line_start":642,"line_end":642,"column_start":12,"column_end":17},"name":"ssymv","qualname":"::blas::level2::ssymv","value":"fn (uplo: ::cblas::Uplo, alpha: f32, A: &::types::MatrixF32, x: &::types::VectorF32, beta: f32, y: &mut ::types::VectorF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" These functions compute the matrix-vector product and sum y = \\alpha A x + \\beta y for the symmetric matrix A.\n Since the matrix A is symmetric only its upper half or lower half need to be stored.\n When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5345},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1281320,"byte_end":1281325,"line_start":662,"line_end":662,"column_start":12,"column_end":17},"name":"dsymv","qualname":"::blas::level2::dsymv","value":"fn (uplo: ::cblas::Uplo, alpha: f64, A: &::types::MatrixF64, x: &::types::VectorF64, beta: f64, y: &mut ::types::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" These functions compute the matrix-vector product and sum y = \\alpha A x + \\beta y for the symmetric matrix A.\n Since the matrix A is symmetric only its upper half or lower half need to be stored.\n When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5346},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1282420,"byte_end":1282425,"line_start":682,"line_end":682,"column_start":12,"column_end":17},"name":"chemv","qualname":"::blas::level2::chemv","value":"fn (uplo: ::cblas::Uplo, alpha: &::types::ComplexF32, A: &::types::MatrixComplexF32, x: &::types::VectorComplexF32, beta: &::types::ComplexF32, y: &mut ::types::VectorComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" These functions compute the matrix-vector product and sum y = \\alpha A x + \\beta y for the hermitian matrix A.\n Since the matrix A is hermitian only its upper half or lower half need to be stored. When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.\n The imaginary elements of the diagonal are automatically assumed to be zero and are not referenced.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5347},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1283623,"byte_end":1283628,"line_start":702,"line_end":702,"column_start":12,"column_end":17},"name":"zhemv","qualname":"::blas::level2::zhemv","value":"fn (uplo: ::cblas::Uplo, alpha: &::types::ComplexF64, A: &::types::MatrixComplexF64, x: &::types::VectorComplexF64, beta: &::types::ComplexF64, y: &mut ::types::VectorComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" These functions compute the matrix-vector product and sum y = \\alpha A x + \\beta y for the hermitian matrix A.\n Since the matrix A is hermitian only its upper half or lower half need to be stored. When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.\n The imaginary elements of the diagonal are automatically assumed to be zero and are not referenced.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5348},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1284437,"byte_end":1284441,"line_start":720,"line_end":720,"column_start":12,"column_end":16},"name":"sger","qualname":"::blas::level2::sger","value":"fn (alpha: f32, x: &::types::VectorF32, y: &::types::VectorF32, A: &mut ::types::MatrixF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the rank-1 update A = \\alpha x y^T + A of the matrix A.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5349},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1284993,"byte_end":1284997,"line_start":734,"line_end":734,"column_start":12,"column_end":16},"name":"dger","qualname":"::blas::level2::dger","value":"fn (alpha: f64, x: &::types::VectorF64, y: &::types::VectorF64, A: &mut ::types::MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the rank-1 update A = \\alpha x y^T + A of the matrix A.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5350},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1285549,"byte_end":1285554,"line_start":748,"line_end":748,"column_start":12,"column_end":17},"name":"cgeru","qualname":"::blas::level2::cgeru","value":"fn (alpha: &::types::ComplexF32, x: &::types::VectorComplexF32, y: &::types::VectorComplexF32, A: &mut ::types::MatrixComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the rank-1 update A = \\alpha x y^T + A of the matrix A.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5351},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1286176,"byte_end":1286181,"line_start":762,"line_end":762,"column_start":12,"column_end":17},"name":"zgeru","qualname":"::blas::level2::zgeru","value":"fn (alpha: &::types::ComplexF64, x: &::types::VectorComplexF64, y: &::types::VectorComplexF64, A: &mut ::types::MatrixComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the rank-1 update A = \\alpha x y^T + A of the matrix A.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5352},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1286813,"byte_end":1286818,"line_start":776,"line_end":776,"column_start":12,"column_end":17},"name":"cgerc","qualname":"::blas::level2::cgerc","value":"fn (alpha: &::types::ComplexF32, x: &::types::VectorComplexF32, y: &::types::VectorComplexF32, A: &mut ::types::MatrixComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the conjugate rank-1 update A = \\alpha x y^H + A of the matrix A.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5353},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1287450,"byte_end":1287455,"line_start":790,"line_end":790,"column_start":12,"column_end":17},"name":"zgerc","qualname":"::blas::level2::zgerc","value":"fn (alpha: &::types::ComplexF64, x: &::types::VectorComplexF64, y: &::types::VectorComplexF64, A: &mut ::types::MatrixComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the conjugate rank-1 update A = \\alpha x y^H + A of the matrix A.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5354},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1288346,"byte_end":1288350,"line_start":805,"line_end":805,"column_start":12,"column_end":16},"name":"ssyr","qualname":"::blas::level2::ssyr","value":"fn (uplo: ::cblas::Uplo, alpha: f32, x: &::types::VectorF32, A: &mut ::types::MatrixF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the symmetric rank-1 update A = \\alpha x x^T + A of the symmetric matrix A. Since the matrix A is symmetric only its upper half or lower half need to be stored.\n When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5355},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1289144,"byte_end":1289148,"line_start":820,"line_end":820,"column_start":12,"column_end":16},"name":"dsyr","qualname":"::blas::level2::dsyr","value":"fn (uplo: ::cblas::Uplo, alpha: f64, x: &::types::VectorF64, A: &mut ::types::MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the symmetric rank-1 update A = \\alpha x x^T + A of the symmetric matrix A. Since the matrix A is symmetric only its upper half or lower half need to be stored.\n When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5356},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1290029,"byte_end":1290033,"line_start":837,"line_end":837,"column_start":12,"column_end":16},"name":"cher","qualname":"::blas::level2::cher","value":"fn (uplo: ::cblas::Uplo, alpha: f32, x: &::types::VectorComplexF32, A: &mut ::types::MatrixComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" These functions compute the hermitian rank-1 update A = \\alpha x x^H + A of the hermitian matrix A.\n Since the matrix A is hermitian only its upper half or lower half need to be stored.\n When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.\n The imaginary elements of the diagonal are automatically set to zero.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5357},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1290928,"byte_end":1290932,"line_start":854,"line_end":854,"column_start":12,"column_end":16},"name":"zher","qualname":"::blas::level2::zher","value":"fn (uplo: ::cblas::Uplo, alpha: f64, x: &::types::VectorComplexF64, A: &mut ::types::MatrixComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" These functions compute the hermitian rank-1 update A = \\alpha x x^H + A of the hermitian matrix A.\n Since the matrix A is hermitian only its upper half or lower half need to be stored.\n When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.\n The imaginary elements of the diagonal are automatically set to zero.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5358},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1291764,"byte_end":1291769,"line_start":870,"line_end":870,"column_start":12,"column_end":17},"name":"ssyr2","qualname":"::blas::level2::ssyr2","value":"fn (uplo: ::cblas::Uplo, alpha: f32, x: &::types::VectorF32, y: &::types::VectorF32, A: &mut ::types::MatrixF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" These functions compute the symmetric rank-2 update A = \\alpha x y^T + \\alpha y x^T + A of the symmetric matrix A.\n Since the matrix A is symmetric only its upper half or lower half need to be stored.\n When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5359},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1292700,"byte_end":1292705,"line_start":888,"line_end":888,"column_start":12,"column_end":17},"name":"dsyr2","qualname":"::blas::level2::dsyr2","value":"fn (uplo: ::cblas::Uplo, alpha: f64, x: &::types::VectorF64, y: &::types::VectorF64, A: &mut ::types::MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" These functions compute the symmetric rank-2 update A = \\alpha x y^T + \\alpha y x^T + A of the symmetric matrix A.\n Since the matrix A is symmetric only its upper half or lower half need to be stored.\n When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5360},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1293716,"byte_end":1293721,"line_start":907,"line_end":907,"column_start":12,"column_end":17},"name":"cher2","qualname":"::blas::level2::cher2","value":"fn (uplo: ::cblas::Uplo, alpha: &::types::ComplexF32, x: &::types::VectorComplexF32, y: &::types::VectorComplexF32, A: &mut ::types::MatrixComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" These functions compute the hermitian rank-2 update A = \\alpha x y^H + \\alpha^* y x^H + A of the hermitian matrix A.\n Since the matrix A is hermitian only its upper half or lower half need to be stored.\n When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.\n The imaginary elements of the diagonal are automatically set to zero.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5361},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1294794,"byte_end":1294799,"line_start":926,"line_end":926,"column_start":12,"column_end":17},"name":"zher2","qualname":"::blas::level2::zher2","value":"fn (uplo: ::cblas::Uplo, alpha: &::types::ComplexF64, x: &::types::VectorComplexF64, y: &::types::VectorComplexF64, A: &mut ::types::MatrixComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" These functions compute the hermitian rank-2 update A = \\alpha x y^H + \\alpha^* y x^H + A of the hermitian matrix A.\n Since the matrix A is hermitian only its upper half or lower half need to be stored.\n When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.\n The imaginary elements of the diagonal are automatically set to zero.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5362},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1295411,"byte_end":1295417,"line_start":942,"line_end":942,"column_start":9,"column_end":15},"name":"level3","qualname":"::blas::level3","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","parent":null,"children":[{"krate":0,"index":5363},{"krate":0,"index":5364},{"krate":0,"index":5365},{"krate":0,"index":5366},{"krate":0,"index":5367},{"krate":0,"index":5368},{"krate":0,"index":5369},{"krate":0,"index":5370},{"krate":0,"index":5371},{"krate":0,"index":5372},{"krate":0,"index":5373},{"krate":0,"index":5374},{"krate":0,"index":5375},{"krate":0,"index":5376},{"krate":0,"index":5377},{"krate":0,"index":5378},{"krate":0,"index":5379},{"krate":0,"index":5380},{"krate":0,"index":5381},{"krate":0,"index":5382},{"krate":0,"index":5383},{"krate":0,"index":5384},{"krate":0,"index":5385},{"krate":0,"index":5386},{"krate":0,"index":5387},{"krate":0,"index":5388},{"krate":0,"index":5389},{"krate":0,"index":5390},{"krate":0,"index":5391},{"krate":0,"index":5392},{"krate":0,"index":5393}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5364},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1295665,"byte_end":1295670,"line_start":946,"line_end":946,"column_start":12,"column_end":17},"name":"sgemm","qualname":"::blas::level3::sgemm","value":"fn (transA: ::cblas::Transpose, transB: ::cblas::Transpose, alpha: f32, A: &::types::MatrixF32, B: &::types::MatrixF32, beta: f32, C: &mut ::types::MatrixF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the matrix-matrix product and sum C = \\alpha op(A) op(B) + \\beta C where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans and similarly for the parameter TransB.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5365},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1296603,"byte_end":1296608,"line_start":966,"line_end":966,"column_start":12,"column_end":17},"name":"dgemm","qualname":"::blas::level3::dgemm","value":"fn (transA: ::cblas::Transpose, transB: ::cblas::Transpose, alpha: f64, A: &::types::MatrixF64, B: &::types::MatrixF64, beta: f64, C: &mut ::types::MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the matrix-matrix product and sum C = \\alpha op(A) op(B) + \\beta C where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans and similarly for the parameter TransB.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5366},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1297541,"byte_end":1297546,"line_start":986,"line_end":986,"column_start":12,"column_end":17},"name":"cgemm","qualname":"::blas::level3::cgemm","value":"fn (transA: ::cblas::Transpose, transB: ::cblas::Transpose, alpha: &::types::ComplexF32, A: &::types::MatrixComplexF32, B: &::types::MatrixComplexF32, beta: &::types::ComplexF32, C: &mut ::types::MatrixComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the matrix-matrix product and sum C = \\alpha op(A) op(B) + \\beta C where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans and similarly for the parameter TransB.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5367},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1298582,"byte_end":1298587,"line_start":1006,"line_end":1006,"column_start":12,"column_end":17},"name":"zgemm","qualname":"::blas::level3::zgemm","value":"fn (transA: ::cblas::Transpose, transB: ::cblas::Transpose, alpha: &::types::ComplexF64, A: &::types::MatrixComplexF64, B: &::types::MatrixComplexF64, beta: &::types::ComplexF64, C: &mut ::types::MatrixComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the matrix-matrix product and sum C = \\alpha op(A) op(B) + \\beta C where op(A) = A, A^T, A^H for TransA = CblasNoTrans, CblasTrans, CblasConjTrans and similarly for the parameter TransB.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5368},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1299767,"byte_end":1299772,"line_start":1027,"line_end":1027,"column_start":12,"column_end":17},"name":"ssymm","qualname":"::blas::level3::ssymm","value":"fn (side: ::cblas::Side, uplo: ::cblas::Uplo, alpha: f32, A: &::types::MatrixF32, B: &::types::MatrixF32, beta: f32, C: &mut ::types::MatrixF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the matrix-matrix product and sum C = \\alpha A B + \\beta C for Side is CblasLeft and C = \\alpha B A + \\beta C for Side is CblasRight, where the matrix A is symmetric.\n When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5369},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1300831,"byte_end":1300836,"line_start":1048,"line_end":1048,"column_start":12,"column_end":17},"name":"dsymm","qualname":"::blas::level3::dsymm","value":"fn (side: ::cblas::Side, uplo: ::cblas::Uplo, alpha: f64, A: &::types::MatrixF64, B: &::types::MatrixF64, beta: f64, C: &mut ::types::MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the matrix-matrix product and sum C = \\alpha A B + \\beta C for Side is CblasLeft and C = \\alpha B A + \\beta C for Side is CblasRight, where the matrix A is symmetric.\n When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5370},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1301895,"byte_end":1301900,"line_start":1069,"line_end":1069,"column_start":12,"column_end":17},"name":"csymm","qualname":"::blas::level3::csymm","value":"fn (side: ::cblas::Side, uplo: ::cblas::Uplo, alpha: &::types::ComplexF32, A: &::types::MatrixComplexF32, B: &::types::MatrixComplexF32, beta: &::types::ComplexF32, C: &mut ::types::MatrixComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the matrix-matrix product and sum C = \\alpha A B + \\beta C for Side is CblasLeft and C = \\alpha B A + \\beta C for Side is CblasRight, where the matrix A is symmetric.\n When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5371},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1303062,"byte_end":1303067,"line_start":1090,"line_end":1090,"column_start":12,"column_end":17},"name":"zsymm","qualname":"::blas::level3::zsymm","value":"fn (side: ::cblas::Side, uplo: ::cblas::Uplo, alpha: &::types::ComplexF64, A: &::types::MatrixComplexF64, B: &::types::MatrixComplexF64, beta: &::types::ComplexF64, C: &mut ::types::MatrixComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the matrix-matrix product and sum C = \\alpha A B + \\beta C for Side is CblasLeft and C = \\alpha B A + \\beta C for Side is CblasRight, where the matrix A is symmetric.\n When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5372},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1304287,"byte_end":1304292,"line_start":1112,"line_end":1112,"column_start":12,"column_end":17},"name":"chemm","qualname":"::blas::level3::chemm","value":"fn (side: ::cblas::Side, uplo: ::cblas::Uplo, alpha: &::types::ComplexF32, A: &::types::MatrixComplexF32, B: &::types::MatrixComplexF32, beta: &::types::ComplexF32, C: &mut ::types::MatrixComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the matrix-matrix product and sum C = \\alpha A B + \\beta C for Side is Left and C = \\alpha B A + \\beta C for Side is Right, where the matrix A is hermitian.\n When Uplo is Upper then the upper triangle and diagonal of A are used, and when Uplo is Lower then the lower triangle and diagonal of A are used.\n The imaginary elements of the diagonal are automatically set to zero.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5373},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1305532,"byte_end":1305537,"line_start":1134,"line_end":1134,"column_start":12,"column_end":17},"name":"zhemm","qualname":"::blas::level3::zhemm","value":"fn (side: ::cblas::Side, uplo: ::cblas::Uplo, alpha: &::types::ComplexF64, A: &::types::MatrixComplexF64, B: &::types::MatrixComplexF64, beta: &::types::ComplexF64, C: &mut ::types::MatrixComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the matrix-matrix product and sum C = \\alpha A B + \\beta C for Side is CblasLeft and C = \\alpha B A + \\beta C for Side is CblasRight, where the matrix A is hermitian.\n When Uplo is CblasUpper then the upper triangle and diagonal of A are used, and when Uplo is CblasLower then the lower triangle and diagonal of A are used.\n The imaginary elements of the diagonal are automatically set to zero.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5374},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1306867,"byte_end":1306872,"line_start":1157,"line_end":1157,"column_start":12,"column_end":17},"name":"strmm","qualname":"::blas::level3::strmm","value":"fn (side: ::cblas::Side, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, alpha: f32, A: &::types::MatrixF32, B: &mut ::types::MatrixF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the matrix-matrix product B = \\alpha op(A) B for Side is Left and B = \\alpha B op(A) for Side is CblasRight.\n The matrix A is triangular and op(A) = A, A^T, A^H for TransA = NoTrans, Trans, ConjTrans.\n When Uplo is Upper then the upper triangle of A is used, and when Uplo is Lower then the lower triangle of A is used.\n If Diag is NonUnit then the diagonal of A is used, but if Diag is Unit then the diagonal elements of the matrix A are taken as unity and are not referenced.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5375},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1308091,"byte_end":1308096,"line_start":1180,"line_end":1180,"column_start":12,"column_end":17},"name":"dtrmm","qualname":"::blas::level3::dtrmm","value":"fn (side: ::cblas::Side, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, alpha: f64, A: &::types::MatrixF64, B: &mut ::types::MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the matrix-matrix product B = \\alpha op(A) B for Side is Left and B = \\alpha B op(A) for Side is CblasRight.\n The matrix A is triangular and op(A) = A, A^T, A^H for TransA = NoTrans, Trans, ConjTrans.\n When Uplo is Upper then the upper triangle of A is used, and when Uplo is Lower then the lower triangle of A is used.\n If Diag is NonUnit then the diagonal of A is used, but if Diag is Unit then the diagonal elements of the matrix A are taken as unity and are not referenced.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5376},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1309315,"byte_end":1309320,"line_start":1203,"line_end":1203,"column_start":12,"column_end":17},"name":"ctrmm","qualname":"::blas::level3::ctrmm","value":"fn (side: ::cblas::Side, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, alpha: &::types::ComplexF32, A: &::types::MatrixComplexF32, B: &mut ::types::MatrixComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the matrix-matrix product B = \\alpha op(A) B for Side is Left and B = \\alpha B op(A) for Side is CblasRight.\n The matrix A is triangular and op(A) = A, A^T, A^H for TransA = NoTrans, Trans, ConjTrans.\n When Uplo is Upper then the upper triangle of A is used, and when Uplo is Lower then the lower triangle of A is used.\n If Diag is NonUnit then the diagonal of A is used, but if Diag is Unit then the diagonal elements of the matrix A are taken as unity and are not referenced.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5377},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1310594,"byte_end":1310599,"line_start":1226,"line_end":1226,"column_start":12,"column_end":17},"name":"ztrmm","qualname":"::blas::level3::ztrmm","value":"fn (side: ::cblas::Side, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, alpha: &::types::ComplexF64, A: &::types::MatrixComplexF64, B: &mut ::types::MatrixComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the matrix-matrix product B = \\alpha op(A) B for Side is Left and B = \\alpha B op(A) for Side is CblasRight.\n The matrix A is triangular and op(A) = A, A^T, A^H for TransA = NoTrans, Trans, ConjTrans.\n When Uplo is Upper then the upper triangle of A is used, and when Uplo is Lower then the lower triangle of A is used.\n If Diag is NonUnit then the diagonal of A is used, but if Diag is Unit then the diagonal elements of the matrix A are taken as unity and are not referenced.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5378},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1311885,"byte_end":1311890,"line_start":1249,"line_end":1249,"column_start":12,"column_end":17},"name":"strsm","qualname":"::blas::level3::strsm","value":"fn (side: ::cblas::Side, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, alpha: f32, A: &::types::MatrixF32, B: &mut ::types::MatrixF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the inverse-matrix matrix product B = \\alpha op(inv(A))B for Side is Left and B = \\alpha B op(inv(A)) for Side is Right.\n The matrix A is triangular and op(A) = A, A^T, A^H for TransA = NoTrans, Trans, ConjTrans.\n When Uplo is Upper then the upper triangle of A is used, and when Uplo is Lower then the lower triangle of A is used.\n If Diag is NonUnit then the diagonal of A is used, but if Diag is Unit then the diagonal elements of the matrix A are taken as unity and are not referenced.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5379},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1313121,"byte_end":1313126,"line_start":1272,"line_end":1272,"column_start":12,"column_end":17},"name":"dtrsm","qualname":"::blas::level3::dtrsm","value":"fn (side: ::cblas::Side, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, alpha: f64, A: &::types::MatrixF64, B: &mut ::types::MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the inverse-matrix matrix product B = \\alpha op(inv(A))B for Side is Left and B = \\alpha B op(inv(A)) for Side is Right.\n The matrix A is triangular and op(A) = A, A^T, A^H for TransA = NoTrans, Trans, ConjTrans.\n When Uplo is Upper then the upper triangle of A is used, and when Uplo is Lower then the lower triangle of A is used.\n If Diag is NonUnit then the diagonal of A is used, but if Diag is Unit then the diagonal elements of the matrix A are taken as unity and are not referenced.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5380},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1314357,"byte_end":1314362,"line_start":1295,"line_end":1295,"column_start":12,"column_end":17},"name":"ctrsm","qualname":"::blas::level3::ctrsm","value":"fn (side: ::cblas::Side, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, alpha: &::types::ComplexF32, A: &::types::MatrixComplexF32, B: &mut ::types::MatrixComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the inverse-matrix matrix product B = \\alpha op(inv(A))B for Side is Left and B = \\alpha B op(inv(A)) for Side is Right.\n The matrix A is triangular and op(A) = A, A^T, A^H for TransA = NoTrans, Trans, ConjTrans.\n When Uplo is Upper then the upper triangle of A is used, and when Uplo is Lower then the lower triangle of A is used.\n If Diag is NonUnit then the diagonal of A is used, but if Diag is Unit then the diagonal elements of the matrix A are taken as unity and are not referenced.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5381},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1315648,"byte_end":1315653,"line_start":1318,"line_end":1318,"column_start":12,"column_end":17},"name":"ztrsm","qualname":"::blas::level3::ztrsm","value":"fn (side: ::cblas::Side, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, alpha: &::types::ComplexF64, A: &::types::MatrixComplexF64, B: &mut ::types::MatrixComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the inverse-matrix matrix product B = \\alpha op(inv(A))B for Side is Left and B = \\alpha B op(inv(A)) for Side is Right.\n The matrix A is triangular and op(A) = A, A^T, A^H for TransA = NoTrans, Trans, ConjTrans.\n When Uplo is Upper then the upper triangle of A is used, and when Uplo is Lower then the lower triangle of A is used.\n If Diag is NonUnit then the diagonal of A is used, but if Diag is Unit then the diagonal elements of the matrix A are taken as unity and are not referenced.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5382},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1316819,"byte_end":1316824,"line_start":1340,"line_end":1340,"column_start":12,"column_end":17},"name":"ssyrk","qualname":"::blas::level3::ssyrk","value":"fn (uplo: ::cblas::Uplo, trans: ::cblas::Transpose, alpha: f32, A: &::types::MatrixF32, beta: f32, C: &mut ::types::MatrixF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes a rank-k update of the symmetric matrix C, C = \\alpha A A^T + \\beta C when Trans is NoTrans and C = \\alpha A^T A + \\beta C when Trans is Trans.\n Since the matrix C is symmetric only its upper half or lower half need to be stored.\n When Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5383},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1317845,"byte_end":1317850,"line_start":1360,"line_end":1360,"column_start":12,"column_end":17},"name":"dsyrk","qualname":"::blas::level3::dsyrk","value":"fn (uplo: ::cblas::Uplo, trans: ::cblas::Transpose, alpha: f64, A: &::types::MatrixF64, beta: f64, C: &mut ::types::MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes a rank-k update of the symmetric matrix C, C = \\alpha A A^T + \\beta C when Trans is NoTrans and C = \\alpha A^T A + \\beta C when Trans is Trans.\n Since the matrix C is symmetric only its upper half or lower half need to be stored.\n When Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5384},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1318871,"byte_end":1318876,"line_start":1380,"line_end":1380,"column_start":12,"column_end":17},"name":"csyrk","qualname":"::blas::level3::csyrk","value":"fn (uplo: ::cblas::Uplo, trans: ::cblas::Transpose, alpha: &::types::ComplexF32, A: &::types::MatrixComplexF32, beta: &::types::ComplexF32, C: &mut ::types::MatrixComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes a rank-k update of the symmetric matrix C, C = \\alpha A A^T + \\beta C when Trans is NoTrans and C = \\alpha A^T A + \\beta C when Trans is Trans.\n Since the matrix C is symmetric only its upper half or lower half need to be stored.\n When Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5385},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1319993,"byte_end":1319998,"line_start":1400,"line_end":1400,"column_start":12,"column_end":17},"name":"zsyrk","qualname":"::blas::level3::zsyrk","value":"fn (uplo: ::cblas::Uplo, trans: ::cblas::Transpose, alpha: &::types::ComplexF64, A: &::types::MatrixComplexF64, beta: &::types::ComplexF64, C: &mut ::types::MatrixComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes a rank-k update of the symmetric matrix C, C = \\alpha A A^T + \\beta C when Trans is NoTrans and C = \\alpha A^T A + \\beta C when Trans is Trans.\n Since the matrix C is symmetric only its upper half or lower half need to be stored.\n When Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5386},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1321198,"byte_end":1321203,"line_start":1421,"line_end":1421,"column_start":12,"column_end":17},"name":"cherk","qualname":"::blas::level3::cherk","value":"fn (uplo: ::cblas::Uplo, trans: ::cblas::Transpose, alpha: f32, A: &::types::MatrixComplexF32, beta: f32, C: &mut ::types::MatrixComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" These functions compute a rank-k update of the hermitian matrix C, C = \\alpha A A^H + \\beta C when Trans is NoTrans and C = \\alpha A^H A + \\beta C when Trans is ConjTrans.\n Since the matrix C is hermitian only its upper half or lower half need to be stored.\n When Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used.\n The imaginary elements of the diagonal are automatically set to zero.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5387},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1322321,"byte_end":1322326,"line_start":1442,"line_end":1442,"column_start":12,"column_end":17},"name":"zherk","qualname":"::blas::level3::zherk","value":"fn (uplo: ::cblas::Uplo, trans: ::cblas::Transpose, alpha: f64, A: &::types::MatrixComplexF64, beta: f64, C: &mut ::types::MatrixComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" These functions compute a rank-k update of the hermitian matrix C, C = \\alpha A A^H + \\beta C when Trans is NoTrans and C = \\alpha A^H A + \\beta C when Trans is ConjTrans.\n Since the matrix C is hermitian only its upper half or lower half need to be stored.\n When Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used.\n The imaginary elements of the diagonal are automatically set to zero.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5388},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1323392,"byte_end":1323398,"line_start":1462,"line_end":1462,"column_start":12,"column_end":18},"name":"ssyr2k","qualname":"::blas::level3::ssyr2k","value":"fn (uplo: ::cblas::Uplo, trans: ::cblas::Transpose, alpha: f32, A: &::types::MatrixF32, B: &::types::MatrixF32, beta: f32, C: &mut ::types::MatrixF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes a rank-2k update of the symmetric matrix C, C = \\alpha A B^T + \\alpha B A^T + \\beta C when Trans is NoTrans and C = \\alpha A^T B + \\alpha B^T A + \\beta C when Trans is Trans.\n Since the matrix C is symmetric only its upper half or lower half need to be stored.\n When Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5389},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1324569,"byte_end":1324575,"line_start":1484,"line_end":1484,"column_start":12,"column_end":18},"name":"dsyr2k","qualname":"::blas::level3::dsyr2k","value":"fn (uplo: ::cblas::Uplo, trans: ::cblas::Transpose, alpha: f64, A: &::types::MatrixF64, B: &::types::MatrixF64, beta: f64, C: &mut ::types::MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes a rank-2k update of the symmetric matrix C, C = \\alpha A B^T + \\alpha B A^T + \\beta C when Trans is NoTrans and C = \\alpha A^T B + \\alpha B^T A + \\beta C when Trans is Trans.\n Since the matrix C is symmetric only its upper half or lower half need to be stored.\n When Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5390},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1325746,"byte_end":1325752,"line_start":1506,"line_end":1506,"column_start":12,"column_end":18},"name":"csyr2k","qualname":"::blas::level3::csyr2k","value":"fn (uplo: ::cblas::Uplo, trans: ::cblas::Transpose, alpha: &::types::ComplexF32, A: &::types::MatrixComplexF32, B: &::types::MatrixComplexF32, beta: &::types::ComplexF32, C: &mut ::types::MatrixComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes a rank-2k update of the symmetric matrix C, C = \\alpha A B^T + \\alpha B A^T + \\beta C when Trans is NoTrans and C = \\alpha A^T B + \\alpha B^T A + \\beta C when Trans is Trans.\n Since the matrix C is symmetric only its upper half or lower half need to be stored.\n When Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5391},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1327026,"byte_end":1327032,"line_start":1528,"line_end":1528,"column_start":12,"column_end":18},"name":"zsyr2k","qualname":"::blas::level3::zsyr2k","value":"fn (uplo: ::cblas::Uplo, trans: ::cblas::Transpose, alpha: &::types::ComplexF64, A: &::types::MatrixComplexF64, B: &::types::MatrixComplexF64, beta: &::types::ComplexF64, C: &mut ::types::MatrixComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes a rank-2k update of the symmetric matrix C, C = \\alpha A B^T + \\alpha B A^T + \\beta C when Trans is NoTrans and C = \\alpha A^T B + \\alpha B^T A + \\beta C when Trans is Trans.\n Since the matrix C is symmetric only its upper half or lower half need to be stored.\n When Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5392},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1328392,"byte_end":1328398,"line_start":1551,"line_end":1551,"column_start":12,"column_end":18},"name":"cher2k","qualname":"::blas::level3::cher2k","value":"fn (uplo: ::cblas::Uplo, trans: ::cblas::Transpose, alpha: &::types::ComplexF32, A: &::types::MatrixComplexF32, B: &::types::MatrixComplexF32, beta: f32, C: &mut ::types::MatrixComplexF32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes a rank-2k update of the hermitian matrix C, C = \\alpha A B^H + \\alpha^* B A^H + \\beta C when Trans is NoTrans and C = \\alpha A^H B + \\alpha^* B^H A + \\beta C when Trans is ConjTrans.\n Since the matrix C is hermitian only its upper half or lower half need to be stored.\n When Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used.\n The imaginary elements of the diagonal are automatically set to zero.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5393},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/blas.rs","byte_start":1329717,"byte_end":1329723,"line_start":1574,"line_end":1574,"column_start":12,"column_end":18},"name":"zher2k","qualname":"::blas::level3::zher2k","value":"fn (uplo: ::cblas::Uplo, trans: ::cblas::Transpose, alpha: &::types::ComplexF64, A: &::types::MatrixComplexF64, B: &::types::MatrixComplexF64, beta: f64, C: &mut ::types::MatrixComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes a rank-2k update of the hermitian matrix C, C = \\alpha A B^H + \\alpha^* B A^H + \\beta C when Trans is NoTrans and C = \\alpha A^H B + \\alpha^* B^H A + \\beta C when Trans is ConjTrans.\n Since the matrix C is hermitian only its upper half or lower half need to be stored.\n When Uplo is Upper then the upper triangle and diagonal of C are used, and when Uplo is Lower then the lower triangle and diagonal of C are used.\n The imaginary elements of the diagonal are automatically set to zero.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5394},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"cblas","qualname":"::cblas","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","parent":null,"children":[{"krate":0,"index":7075},{"krate":0,"index":7079},{"krate":0,"index":7078},{"krate":0,"index":7081},{"krate":0,"index":7094},{"krate":0,"index":7095},{"krate":0,"index":7092},{"krate":0,"index":7090},{"krate":0,"index":7088},{"krate":0,"index":7087},{"krate":0,"index":7097},{"krate":0,"index":7110},{"krate":0,"index":7111},{"krate":0,"index":7108},{"krate":0,"index":7106},{"krate":0,"index":7104},{"krate":0,"index":7103},{"krate":0,"index":7113},{"krate":0,"index":7128},{"krate":0,"index":7129},{"krate":0,"index":7126},{"krate":0,"index":7124},{"krate":0,"index":7122},{"krate":0,"index":7121},{"krate":0,"index":7131},{"krate":0,"index":7144},{"krate":0,"index":7145},{"krate":0,"index":7142},{"krate":0,"index":7140},{"krate":0,"index":7138},{"krate":0,"index":7137},{"krate":0,"index":7147},{"krate":0,"index":7160},{"krate":0,"index":7161},{"krate":0,"index":7158},{"krate":0,"index":7156},{"krate":0,"index":7154},{"krate":0,"index":7153},{"krate":0,"index":5395},{"krate":0,"index":5462},{"krate":0,"index":5575}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Struct","id":{"krate":0,"index":7075},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1330621,"byte_end":1330626,"line_start":6,"line_end":6,"column_start":12,"column_end":17},"name":"Index","qualname":"::cblas::Index","value":"","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":7082},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1330897,"byte_end":1330905,"line_start":13,"line_end":13,"column_start":5,"column_end":13},"name":"RowMajor","qualname":"::cblas::Order::RowMajor","value":"Order::RowMajor","parent":{"krate":0,"index":7081},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":7085},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1330917,"byte_end":1330926,"line_start":14,"line_end":14,"column_start":5,"column_end":14},"name":"ColMajoyr","qualname":"::cblas::Order::ColMajoyr","value":"Order::ColMajoyr","parent":{"krate":0,"index":7081},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":7081},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1330885,"byte_end":1330890,"line_start":12,"line_end":12,"column_start":10,"column_end":15},"name":"Order","qualname":"::cblas::Order","value":"Order::{RowMajor, ColMajoyr}","parent":null,"children":[{"krate":0,"index":7082},{"krate":0,"index":7085}],"decl_id":null,"docs":" Indicates whether a matrix is in Row Major or Column Major order.\n Row major order is the native order for C programs, while Column major order is native for Fortran.\n","sig":null,"attributes":[{"value":"repr(C)","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1330865,"byte_end":1330875,"line_start":11,"line_end":11,"column_start":1,"column_end":11}}]},{"kind":"TupleVariant","id":{"krate":0,"index":7098},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1331101,"byte_end":1331105,"line_start":22,"line_end":22,"column_start":5,"column_end":9},"name":"Left","qualname":"::cblas::Side::Left","value":"Side::Left","parent":{"krate":0,"index":7097},"children":[],"decl_id":null,"docs":" Means __A__ __B__\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":7101},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1331143,"byte_end":1331148,"line_start":24,"line_end":24,"column_start":5,"column_end":10},"name":"Right","qualname":"::cblas::Side::Right","value":"Side::Right","parent":{"krate":0,"index":7097},"children":[],"decl_id":null,"docs":" Means __B__ __A__\n","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":7097},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1331064,"byte_end":1331068,"line_start":20,"line_end":20,"column_start":10,"column_end":14},"name":"Side","qualname":"::cblas::Side","value":"Side::{Left, Right}","parent":null,"children":[{"krate":0,"index":7098},{"krate":0,"index":7101}],"decl_id":null,"docs":" Used to indicate the order of a matrix-matrix multiply.\n","sig":null,"attributes":[{"value":"repr(C)","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1331044,"byte_end":1331054,"line_start":19,"line_end":19,"column_start":1,"column_end":11}}]},{"kind":"TupleVariant","id":{"krate":0,"index":7114},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1331323,"byte_end":1331330,"line_start":32,"line_end":32,"column_start":5,"column_end":12},"name":"NoTrans","qualname":"::cblas::Transpose::NoTrans","value":"Transpose::NoTrans","parent":{"krate":0,"index":7113},"children":[],"decl_id":null,"docs":" Represents __X__\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":7117},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1331369,"byte_end":1331374,"line_start":34,"line_end":34,"column_start":5,"column_end":10},"name":"Trans","qualname":"::cblas::Transpose::Trans","value":"Transpose::Trans","parent":{"krate":0,"index":7113},"children":[],"decl_id":null,"docs":" Represents __X^T__\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":7119},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1331407,"byte_end":1331416,"line_start":36,"line_end":36,"column_start":5,"column_end":14},"name":"ConjTrans","qualname":"::cblas::Transpose::ConjTrans","value":"Transpose::ConjTrans","parent":{"krate":0,"index":7113},"children":[],"decl_id":null,"docs":" Represents __X^H__\n","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":7113},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1331282,"byte_end":1331291,"line_start":30,"line_end":30,"column_start":10,"column_end":19},"name":"Transpose","qualname":"::cblas::Transpose","value":"Transpose::{NoTrans, Trans, ConjTrans}","parent":null,"children":[{"krate":0,"index":7114},{"krate":0,"index":7117},{"krate":0,"index":7119}],"decl_id":null,"docs":" Used to represent transpose operations on a matrix.\n","sig":null,"attributes":[{"value":"repr(C)","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1331262,"byte_end":1331272,"line_start":29,"line_end":29,"column_start":1,"column_end":11}}]},{"kind":"TupleVariant","id":{"krate":0,"index":7132},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1331619,"byte_end":1331624,"line_start":44,"line_end":44,"column_start":5,"column_end":10},"name":"Upper","qualname":"::cblas::Uplo::Upper","value":"Uplo::Upper","parent":{"krate":0,"index":7131},"children":[],"decl_id":null,"docs":" Means user the upper triagle of the matrix.\n","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":7135},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1331687,"byte_end":1331692,"line_start":46,"line_end":46,"column_start":5,"column_end":10},"name":"Lower","qualname":"::cblas::Uplo::Lower","value":"Uplo::Lower","parent":{"krate":0,"index":7131},"children":[],"decl_id":null,"docs":" Means use the lower triange of the matrix.\n","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":7131},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1331556,"byte_end":1331560,"line_start":42,"line_end":42,"column_start":10,"column_end":14},"name":"Uplo","qualname":"::cblas::Uplo","value":"Uplo::{Upper, Lower}","parent":null,"children":[{"krate":0,"index":7132},{"krate":0,"index":7135}],"decl_id":null,"docs":" Used to indicate which part of a symmetric matrix to use.\n","sig":null,"attributes":[{"value":"repr(C)","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1331536,"byte_end":1331546,"line_start":41,"line_end":41,"column_start":1,"column_end":11}}]},{"kind":"TupleVariant","id":{"krate":0,"index":7148},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1331781,"byte_end":1331788,"line_start":52,"line_end":52,"column_start":5,"column_end":12},"name":"NonUnit","qualname":"::cblas::Diag::NonUnit","value":"Diag::NonUnit","parent":{"krate":0,"index":7147},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"TupleVariant","id":{"krate":0,"index":7151},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1331800,"byte_end":1331804,"line_start":53,"line_end":53,"column_start":5,"column_end":9},"name":"Unit","qualname":"::cblas::Diag::Unit","value":"Diag::Unit","parent":{"krate":0,"index":7147},"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Enum","id":{"krate":0,"index":7147},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1331770,"byte_end":1331774,"line_start":51,"line_end":51,"column_start":10,"column_end":14},"name":"Diag","qualname":"::cblas::Diag","value":"Diag::{NonUnit, Unit}","parent":null,"children":[{"krate":0,"index":7148},{"krate":0,"index":7151}],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"repr(C)","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1331750,"byte_end":1331760,"line_start":50,"line_end":50,"column_start":1,"column_end":11}}]},{"kind":"Mod","id":{"krate":0,"index":5395},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1331817,"byte_end":1331823,"line_start":56,"line_end":56,"column_start":9,"column_end":15},"name":"level1","qualname":"::cblas::level1","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","parent":null,"children":[{"krate":0,"index":5396},{"krate":0,"index":5397},{"krate":0,"index":5398},{"krate":0,"index":5399},{"krate":0,"index":5400},{"krate":0,"index":5402},{"krate":0,"index":5404},{"krate":0,"index":5406},{"krate":0,"index":5408},{"krate":0,"index":5409},{"krate":0,"index":5410},{"krate":0,"index":5411},{"krate":0,"index":5412},{"krate":0,"index":5414},{"krate":0,"index":5416},{"krate":0,"index":5418},{"krate":0,"index":5420},{"krate":0,"index":5421},{"krate":0,"index":5422},{"krate":0,"index":5424},{"krate":0,"index":5426},{"krate":0,"index":5427},{"krate":0,"index":5428},{"krate":0,"index":5429},{"krate":0,"index":5430},{"krate":0,"index":5431},{"krate":0,"index":5432},{"krate":0,"index":5434},{"krate":0,"index":5436},{"krate":0,"index":5438},{"krate":0,"index":5440},{"krate":0,"index":5442},{"krate":0,"index":5444},{"krate":0,"index":5445},{"krate":0,"index":5446},{"krate":0,"index":5447},{"krate":0,"index":5448},{"krate":0,"index":5449},{"krate":0,"index":5450},{"krate":0,"index":5451},{"krate":0,"index":5452},{"krate":0,"index":5453},{"krate":0,"index":5454},{"krate":0,"index":5456},{"krate":0,"index":5458},{"krate":0,"index":5460}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5396},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1331837,"byte_end":1331843,"line_start":57,"line_end":57,"column_start":12,"column_end":18},"name":"sdsdot","qualname":"::cblas::level1::sdsdot","value":"fn (N: i32, alpha: f32, x: &[f32], incx: i32, y: &[f32], incy: i32) -> f32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5397},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1332020,"byte_end":1332025,"line_start":61,"line_end":61,"column_start":12,"column_end":17},"name":"dsdot","qualname":"::cblas::level1::dsdot","value":"fn (N: i32, x: &[f32], incx: i32, y: &[f32], incy: i32) -> f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5398},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1332182,"byte_end":1332186,"line_start":65,"line_end":65,"column_start":12,"column_end":16},"name":"sdot","qualname":"::cblas::level1::sdot","value":"fn (N: i32, x: &[f32], incx: i32, y: &[f32], incy: i32) -> f32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5399},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1332342,"byte_end":1332346,"line_start":69,"line_end":69,"column_start":12,"column_end":16},"name":"ddot","qualname":"::cblas::level1::ddot","value":"fn (N: i32, x: &[f32], incx: i32, y: &[f32], incy: i32) -> f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5400},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1332502,"byte_end":1332511,"line_start":73,"line_end":73,"column_start":12,"column_end":21},"name":"cdotu_sub","qualname":"::cblas::level1::cdotu_sub","value":"fn <T> (N: i32, x: &[T], incx: i32, y: &[T], incy: i32, dotu: &mut [T]) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5402},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1332967,"byte_end":1332976,"line_start":84,"line_end":84,"column_start":12,"column_end":21},"name":"cdotc_sub","qualname":"::cblas::level1::cdotc_sub","value":"fn <T> (N: i32, x: &[T], incx: i32, y: &[T], incy: i32, dotc: &mut [T]) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5404},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1333432,"byte_end":1333441,"line_start":95,"line_end":95,"column_start":12,"column_end":21},"name":"zdotu_sub","qualname":"::cblas::level1::zdotu_sub","value":"fn <T> (N: i32, x: &[T], incx: i32, y: &[T], incy: i32, dotu: &mut [T]) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5406},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1333897,"byte_end":1333906,"line_start":106,"line_end":106,"column_start":12,"column_end":21},"name":"zdotc_sub","qualname":"::cblas::level1::zdotc_sub","value":"fn <T> (N: i32, x: &[T], incx: i32, y: &[T], incy: i32, dotc: &mut [T]) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5408},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1334362,"byte_end":1334367,"line_start":117,"line_end":117,"column_start":12,"column_end":17},"name":"snrm2","qualname":"::cblas::level1::snrm2","value":"fn (N: i32, x: &[f32], incx: i32) -> f32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5409},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1334484,"byte_end":1334489,"line_start":121,"line_end":121,"column_start":12,"column_end":17},"name":"sasum","qualname":"::cblas::level1::sasum","value":"fn (N: i32, x: &[f32], incx: i32) -> f32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5410},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1334606,"byte_end":1334611,"line_start":125,"line_end":125,"column_start":12,"column_end":17},"name":"dnrm2","qualname":"::cblas::level1::dnrm2","value":"fn (N: i32, x: &[f64], incx: i32) -> f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5411},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1334728,"byte_end":1334733,"line_start":129,"line_end":129,"column_start":12,"column_end":17},"name":"dasum","qualname":"::cblas::level1::dasum","value":"fn (N: i32, x: &[f64], incx: i32) -> f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5412},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1334850,"byte_end":1334856,"line_start":133,"line_end":133,"column_start":12,"column_end":18},"name":"scnrm2","qualname":"::cblas::level1::scnrm2","value":"fn <T> (N: i32, x: &[T], incx: i32) -> f32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5414},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1335000,"byte_end":1335006,"line_start":137,"line_end":137,"column_start":12,"column_end":18},"name":"scasum","qualname":"::cblas::level1::scasum","value":"fn <T> (N: i32, x: &[T], incx: i32) -> f32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5416},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1335150,"byte_end":1335156,"line_start":141,"line_end":141,"column_start":12,"column_end":18},"name":"dznrm2","qualname":"::cblas::level1::dznrm2","value":"fn <T> (N: i32, x: &[T], incx: i32) -> f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5418},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1335300,"byte_end":1335306,"line_start":145,"line_end":145,"column_start":12,"column_end":18},"name":"dzasum","qualname":"::cblas::level1::dzasum","value":"fn <T> (N: i32, x: &[T], incx: i32) -> f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5420},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1335450,"byte_end":1335456,"line_start":149,"line_end":149,"column_start":12,"column_end":18},"name":"isamax","qualname":"::cblas::level1::isamax","value":"fn (N: i32, x: &[f32], incx: i32) -> ::cblas::Index","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5421},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1335601,"byte_end":1335607,"line_start":153,"line_end":153,"column_start":12,"column_end":18},"name":"idamax","qualname":"::cblas::level1::idamax","value":"fn (N: i32, x: &[f64], incx: i32) -> ::cblas::Index","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5422},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1335752,"byte_end":1335758,"line_start":157,"line_end":157,"column_start":12,"column_end":18},"name":"icamax","qualname":"::cblas::level1::icamax","value":"fn <T> (N: i32, x: &[T], incx: i32) -> ::cblas::Index","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5424},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1335929,"byte_end":1335935,"line_start":161,"line_end":161,"column_start":12,"column_end":18},"name":"izamax","qualname":"::cblas::level1::izamax","value":"fn <T> (N: i32, x: &[T], incx: i32) -> ::cblas::Index","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5426},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1336106,"byte_end":1336111,"line_start":165,"line_end":165,"column_start":12,"column_end":17},"name":"sswap","qualname":"::cblas::level1::sswap","value":"fn (N: i32, x: &mut [f32], incx: i32, y: &mut [f32], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5427},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1336277,"byte_end":1336282,"line_start":169,"line_end":169,"column_start":12,"column_end":17},"name":"scopy","qualname":"::cblas::level1::scopy","value":"fn (N: i32, x: &[f32], incx: i32, y: &mut [f32], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5428},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1336440,"byte_end":1336445,"line_start":173,"line_end":173,"column_start":12,"column_end":17},"name":"saxpy","qualname":"::cblas::level1::saxpy","value":"fn (N: i32, alpha: f32, x: &[f32], incx: i32, y: &mut [f32], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5429},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1336622,"byte_end":1336627,"line_start":177,"line_end":177,"column_start":12,"column_end":17},"name":"dswap","qualname":"::cblas::level1::dswap","value":"fn (N: i32, x: &mut [f64], incx: i32, y: &mut [f64], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5430},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1336793,"byte_end":1336798,"line_start":181,"line_end":181,"column_start":12,"column_end":17},"name":"dcopy","qualname":"::cblas::level1::dcopy","value":"fn (N: i32, x: &[f64], incx: i32, y: &mut [f64], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5431},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1336956,"byte_end":1336961,"line_start":185,"line_end":185,"column_start":12,"column_end":17},"name":"daxpy","qualname":"::cblas::level1::daxpy","value":"fn (N: i32, alpha: f64, x: &[f64], incx: i32, y: &mut [f64], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5432},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1337138,"byte_end":1337143,"line_start":189,"line_end":189,"column_start":12,"column_end":17},"name":"cswap","qualname":"::cblas::level1::cswap","value":"fn <T> (N: i32, x: &mut [T], incx: i32, y: &mut [T], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5434},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1337498,"byte_end":1337503,"line_start":199,"line_end":199,"column_start":12,"column_end":17},"name":"ccopy","qualname":"::cblas::level1::ccopy","value":"fn <T> (N: i32, x: &[T], incx: i32, y: &mut [T], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5436},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1337852,"byte_end":1337857,"line_start":209,"line_end":209,"column_start":12,"column_end":17},"name":"caxpy","qualname":"::cblas::level1::caxpy","value":"fn <T> (N: i32, alpha: &[T], x: &[T], incx: i32, y: &mut [T], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5438},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1338291,"byte_end":1338296,"line_start":220,"line_end":220,"column_start":12,"column_end":17},"name":"zswap","qualname":"::cblas::level1::zswap","value":"fn <T> (N: i32, x: &mut [T], incx: i32, y: &mut [T], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5440},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1338651,"byte_end":1338656,"line_start":230,"line_end":230,"column_start":12,"column_end":17},"name":"zcopy","qualname":"::cblas::level1::zcopy","value":"fn <T> (N: i32, x: &[T], incx: i32, y: &mut [T], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5442},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1339005,"byte_end":1339010,"line_start":240,"line_end":240,"column_start":12,"column_end":17},"name":"zaxpy","qualname":"::cblas::level1::zaxpy","value":"fn <T> (N: i32, alpha: &[T], x: &[T], incx: i32, y: &mut [T], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5444},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1339444,"byte_end":1339449,"line_start":251,"line_end":251,"column_start":12,"column_end":17},"name":"srotg","qualname":"::cblas::level1::srotg","value":"fn (a: &mut [f32], b: &mut [f32], c: &mut [f32], s: &mut [f32]) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5445},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1339745,"byte_end":1339751,"line_start":260,"line_end":260,"column_start":12,"column_end":18},"name":"srotmg","qualname":"::cblas::level1::srotmg","value":"fn (d1: &mut [f32], d2: &mut [f32], b1: &mut [f32], b2: &[f32], P: &mut [f32]) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5446},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1340114,"byte_end":1340118,"line_start":270,"line_end":270,"column_start":12,"column_end":16},"name":"srot","qualname":"::cblas::level1::srot","value":"fn (N: i32, x: &mut [f32], incx: i32, y: &mut [f32], incy: i32, c: f32, s: f32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5447},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1340305,"byte_end":1340310,"line_start":274,"line_end":274,"column_start":12,"column_end":17},"name":"srotm","qualname":"::cblas::level1::srotm","value":"fn (N: i32, x: &mut [f32], incx: i32, y: &mut [f32], incy: i32, p: &[f32]) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5448},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1340499,"byte_end":1340504,"line_start":278,"line_end":278,"column_start":12,"column_end":17},"name":"drotg","qualname":"::cblas::level1::drotg","value":"fn (a: &mut [f64], b: &mut [f64], c: &mut [f64], s: &mut [f64]) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5449},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1340800,"byte_end":1340806,"line_start":287,"line_end":287,"column_start":12,"column_end":18},"name":"drotmg","qualname":"::cblas::level1::drotmg","value":"fn (d1: &mut [f64], d2: &mut [f64], b1: &mut [f64], b2: &[f64], P: &mut [f64]) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5450},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1341169,"byte_end":1341173,"line_start":297,"line_end":297,"column_start":12,"column_end":16},"name":"drot","qualname":"::cblas::level1::drot","value":"fn (N: i32, x: &mut [f64], incx: i32, y: &mut [f64], incy: i32, c: f64, s: f64) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5451},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1341360,"byte_end":1341365,"line_start":301,"line_end":301,"column_start":12,"column_end":17},"name":"drotm","qualname":"::cblas::level1::drotm","value":"fn (N: i32, x: &mut [f64], incx: i32, y: &mut [f64], incy: i32, p: &[f64]) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5452},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1342130,"byte_end":1342135,"line_start":317,"line_end":317,"column_start":12,"column_end":17},"name":"sscal","qualname":"::cblas::level1::sscal","value":"fn (N: i32, alpha: f32, x: &mut [f32], incx: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Multiple each element of a matrix/vector by a constant.","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5453},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1342336,"byte_end":1342341,"line_start":322,"line_end":322,"column_start":12,"column_end":17},"name":"dscal","qualname":"::cblas::level1::dscal","value":"fn (N: i32, alpha: f64, x: &mut [f64], incx: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Multiple each element of a matrix/vector by a constant.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5454},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1342542,"byte_end":1342547,"line_start":327,"line_end":327,"column_start":12,"column_end":17},"name":"cscal","qualname":"::cblas::level1::cscal","value":"fn <T> (N: i32, alpha: &[T], x: &mut [T], incx: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Multiple each element of a matrix/vector by a constant.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5456},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1342920,"byte_end":1342925,"line_start":337,"line_end":337,"column_start":12,"column_end":17},"name":"zscal","qualname":"::cblas::level1::zscal","value":"fn <T> (N: i32, alpha: &[T], x: &mut [T], incx: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Multiple each element of a matrix/vector by a constant.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5458},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1343298,"byte_end":1343304,"line_start":347,"line_end":347,"column_start":12,"column_end":18},"name":"csscal","qualname":"::cblas::level1::csscal","value":"fn <T> (N: i32, alpha: f32, x: &mut [T], incx: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Multiple each element of a matrix/vector by a constant.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5460},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1343530,"byte_end":1343536,"line_start":352,"line_end":352,"column_start":12,"column_end":18},"name":"zdscal","qualname":"::cblas::level1::zdscal","value":"fn <T> (N: i32, alpha: f64, x: &mut [T], incx: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Multiple each element of a matrix/vector by a constant.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5462},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1343697,"byte_end":1343703,"line_start":357,"line_end":357,"column_start":9,"column_end":15},"name":"level2","qualname":"::cblas::level2","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","parent":null,"children":[{"krate":0,"index":5463},{"krate":0,"index":5464},{"krate":0,"index":5465},{"krate":0,"index":5466},{"krate":0,"index":5467},{"krate":0,"index":5468},{"krate":0,"index":5469},{"krate":0,"index":5470},{"krate":0,"index":5471},{"krate":0,"index":5472},{"krate":0,"index":5473},{"krate":0,"index":5474},{"krate":0,"index":5475},{"krate":0,"index":5476},{"krate":0,"index":5477},{"krate":0,"index":5478},{"krate":0,"index":5479},{"krate":0,"index":5481},{"krate":0,"index":5483},{"krate":0,"index":5485},{"krate":0,"index":5487},{"krate":0,"index":5489},{"krate":0,"index":5491},{"krate":0,"index":5493},{"krate":0,"index":5495},{"krate":0,"index":5497},{"krate":0,"index":5499},{"krate":0,"index":5501},{"krate":0,"index":5503},{"krate":0,"index":5505},{"krate":0,"index":5507},{"krate":0,"index":5509},{"krate":0,"index":5511},{"krate":0,"index":5512},{"krate":0,"index":5513},{"krate":0,"index":5514},{"krate":0,"index":5515},{"krate":0,"index":5516},{"krate":0,"index":5517},{"krate":0,"index":5518},{"krate":0,"index":5519},{"krate":0,"index":5520},{"krate":0,"index":5521},{"krate":0,"index":5522},{"krate":0,"index":5523},{"krate":0,"index":5524},{"krate":0,"index":5525},{"krate":0,"index":5526},{"krate":0,"index":5527},{"krate":0,"index":5529},{"krate":0,"index":5531},{"krate":0,"index":5533},{"krate":0,"index":5535},{"krate":0,"index":5537},{"krate":0,"index":5539},{"krate":0,"index":5541},{"krate":0,"index":5543},{"krate":0,"index":5545},{"krate":0,"index":5547},{"krate":0,"index":5549},{"krate":0,"index":5551},{"krate":0,"index":5553},{"krate":0,"index":5555},{"krate":0,"index":5557},{"krate":0,"index":5559},{"krate":0,"index":5561},{"krate":0,"index":5563},{"krate":0,"index":5565},{"krate":0,"index":5567},{"krate":0,"index":5569},{"krate":0,"index":5571},{"krate":0,"index":5573}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5463},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1344495,"byte_end":1344500,"line_start":374,"line_end":374,"column_start":12,"column_end":17},"name":"sgemv","qualname":"::cblas::level2::sgemv","value":"fn (order: ::cblas::Order, transA: ::cblas::Transpose, M: i32, N: i32, alpha: f32, A: &[f32], lda: i32, X: &[f32], incx: i32, beta: f32, Y: &mut [f32], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Multiplies a matrix and a vector.","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5464},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1345357,"byte_end":1345362,"line_start":402,"line_end":402,"column_start":12,"column_end":17},"name":"sgbmv","qualname":"::cblas::level2::sgbmv","value":"fn (order: ::cblas::Order, transA: ::cblas::Transpose, M: i32, N: i32, KL: i32, KU: i32, alpha: f32, A: &[f32], lda: i32, X: &[f32], incx: i32, beta: f32, Y: &mut [f32], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5465},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1346341,"byte_end":1346346,"line_start":434,"line_end":434,"column_start":12,"column_end":17},"name":"strmv","qualname":"::cblas::level2::strmv","value":"fn (order: ::cblas::Order, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, N: i32, A: &[f32], lda: i32, X: &mut [f32], incx: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5466},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1347026,"byte_end":1347031,"line_start":456,"line_end":456,"column_start":12,"column_end":17},"name":"stbmv","qualname":"::cblas::level2::stbmv","value":"fn (order: ::cblas::Order, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, N: i32, K: i32, A: &[f32], lda: i32, X: &mut [f32], incx: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5467},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1347770,"byte_end":1347775,"line_start":480,"line_end":480,"column_start":12,"column_end":17},"name":"stpmv","qualname":"::cblas::level2::stpmv","value":"fn (order: ::cblas::Order, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, N: i32, Ap: &[f32], X: &mut [f32], incx: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5468},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1348394,"byte_end":1348399,"line_start":500,"line_end":500,"column_start":12,"column_end":17},"name":"strsv","qualname":"::cblas::level2::strsv","value":"fn (order: ::cblas::Order, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, N: i32, A: &[f32], lda: i32, X: &mut [f32], incx: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5469},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1349079,"byte_end":1349084,"line_start":522,"line_end":522,"column_start":12,"column_end":17},"name":"stbsv","qualname":"::cblas::level2::stbsv","value":"fn (order: ::cblas::Order, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, N: i32, K: i32, A: &[f32], lda: i32, X: &mut [f32], incx: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5470},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1349823,"byte_end":1349828,"line_start":546,"line_end":546,"column_start":12,"column_end":17},"name":"stpsv","qualname":"::cblas::level2::stpsv","value":"fn (order: ::cblas::Order, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, N: i32, Ap: &[f32], X: &mut [f32], incx: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5471},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1350447,"byte_end":1350452,"line_start":566,"line_end":566,"column_start":12,"column_end":17},"name":"dgemv","qualname":"::cblas::level2::dgemv","value":"fn (order: ::cblas::Order, transA: ::cblas::Transpose, M: i32, N: i32, alpha: f64, A: &[f64], lda: i32, X: &[f64], incx: i32, beta: f64, Y: &mut [f64], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5472},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1351309,"byte_end":1351314,"line_start":594,"line_end":594,"column_start":12,"column_end":17},"name":"dgbmv","qualname":"::cblas::level2::dgbmv","value":"fn (order: ::cblas::Order, transA: ::cblas::Transpose, M: i32, N: i32, KL: i32, KU: i32, alpha: f64, A: &[f64], lda: i32, X: &[f64], incx: i32, beta: f64, Y: &mut [f64], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5473},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1352293,"byte_end":1352298,"line_start":626,"line_end":626,"column_start":12,"column_end":17},"name":"dtrmv","qualname":"::cblas::level2::dtrmv","value":"fn (order: ::cblas::Order, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, N: i32, A: &[f64], lda: i32, X: &mut [f64], incx: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5474},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1352978,"byte_end":1352983,"line_start":648,"line_end":648,"column_start":12,"column_end":17},"name":"dtbmv","qualname":"::cblas::level2::dtbmv","value":"fn (order: ::cblas::Order, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, N: i32, K: i32, A: &[f64], lda: i32, X: &mut [f64], incx: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5475},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1353722,"byte_end":1353727,"line_start":672,"line_end":672,"column_start":12,"column_end":17},"name":"dtpmv","qualname":"::cblas::level2::dtpmv","value":"fn (order: ::cblas::Order, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, N: i32, Ap: &[f64], X: &mut [f64], incx: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5476},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1354346,"byte_end":1354351,"line_start":692,"line_end":692,"column_start":12,"column_end":17},"name":"dtrsv","qualname":"::cblas::level2::dtrsv","value":"fn (order: ::cblas::Order, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, N: i32, A: &[f64], lda: i32, X: &mut [f64], incx: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5477},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1355031,"byte_end":1355036,"line_start":714,"line_end":714,"column_start":12,"column_end":17},"name":"dtbsv","qualname":"::cblas::level2::dtbsv","value":"fn (order: ::cblas::Order, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, N: i32, K: i32, A: &[f64], lda: i32, X: &mut [f64], incx: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5478},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1355775,"byte_end":1355780,"line_start":738,"line_end":738,"column_start":12,"column_end":17},"name":"dtpsv","qualname":"::cblas::level2::dtpsv","value":"fn (order: ::cblas::Order, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, N: i32, Ap: &[f64], X: &mut [f64], incx: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5479},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1356399,"byte_end":1356404,"line_start":758,"line_end":758,"column_start":12,"column_end":17},"name":"cgemv","qualname":"::cblas::level2::cgemv","value":"fn <T> (order: ::cblas::Order, transA: ::cblas::Transpose, M: i32, N: i32, alpha: &[T], A: &[T], lda: i32, X: &[T], incx: i32, beta: &[T], Y: &mut [T], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5481},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1357434,"byte_end":1357439,"line_start":786,"line_end":786,"column_start":12,"column_end":17},"name":"cgbmv","qualname":"::cblas::level2::cgbmv","value":"fn <T> (order: ::cblas::Order, transA: ::cblas::Transpose, M: i32, N: i32, KL: i32, KU: i32, alpha: &[T], A: &[T], lda: i32, X: &[T], incx: i32, beta: &[T], Y: &mut [T], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5483},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1358597,"byte_end":1358602,"line_start":818,"line_end":818,"column_start":12,"column_end":17},"name":"ctrmv","qualname":"::cblas::level2::ctrmv","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, N: i32, A: &[T], lda: i32, X: &mut [T], incx: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5485},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1359349,"byte_end":1359354,"line_start":840,"line_end":840,"column_start":12,"column_end":17},"name":"ctbmv","qualname":"::cblas::level2::ctbmv","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, N: i32, K: i32, A: &[T], lda: i32, X: &mut [T], incx: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5487},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1360163,"byte_end":1360168,"line_start":864,"line_end":864,"column_start":12,"column_end":17},"name":"ctpmv","qualname":"::cblas::level2::ctpmv","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, N: i32, Ap: &[T], X: &mut [T], incx: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5489},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1360851,"byte_end":1360856,"line_start":884,"line_end":884,"column_start":12,"column_end":17},"name":"ctrsv","qualname":"::cblas::level2::ctrsv","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, N: i32, A: &[T], lda: i32, X: &mut [T], incx: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5491},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1361603,"byte_end":1361608,"line_start":906,"line_end":906,"column_start":12,"column_end":17},"name":"ctbsv","qualname":"::cblas::level2::ctbsv","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, N: i32, K: i32, A: &[T], lda: i32, X: &mut [T], incx: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5493},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1362421,"byte_end":1362426,"line_start":930,"line_end":930,"column_start":12,"column_end":17},"name":"ctpsv","qualname":"::cblas::level2::ctpsv","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, N: i32, Ap: &[T], X: &mut [T], incx: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5495},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1363109,"byte_end":1363114,"line_start":950,"line_end":950,"column_start":12,"column_end":17},"name":"zgemv","qualname":"::cblas::level2::zgemv","value":"fn <T> (order: ::cblas::Order, transA: ::cblas::Transpose, M: i32, N: i32, alpha: &[T], A: &[T], lda: i32, X: &[T], incx: i32, beta: &[T], Y: &mut [T], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5497},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1364144,"byte_end":1364149,"line_start":978,"line_end":978,"column_start":12,"column_end":17},"name":"zgbmv","qualname":"::cblas::level2::zgbmv","value":"fn <T> (order: ::cblas::Order, transA: ::cblas::Transpose, M: i32, N: i32, KL: i32, KU: i32, alpha: &[T], A: &[T], lda: i32, X: &[T], incx: i32, beta: &[T], Y: &mut [T], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5499},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1365307,"byte_end":1365312,"line_start":1010,"line_end":1010,"column_start":12,"column_end":17},"name":"ztrmv","qualname":"::cblas::level2::ztrmv","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, N: i32, A: &[T], lda: i32, X: &mut [T], incx: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5501},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1366059,"byte_end":1366064,"line_start":1032,"line_end":1032,"column_start":12,"column_end":17},"name":"ztbmv","qualname":"::cblas::level2::ztbmv","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, N: i32, K: i32, A: &[T], lda: i32, X: &mut [T], incx: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5503},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1366873,"byte_end":1366878,"line_start":1056,"line_end":1056,"column_start":12,"column_end":17},"name":"ztpmv","qualname":"::cblas::level2::ztpmv","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, N: i32, Ap: &[T], X: &mut [T], incx: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5505},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1367561,"byte_end":1367566,"line_start":1076,"line_end":1076,"column_start":12,"column_end":17},"name":"ztrsv","qualname":"::cblas::level2::ztrsv","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, N: i32, A: &[T], lda: i32, X: &mut [T], incx: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5507},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1368313,"byte_end":1368318,"line_start":1098,"line_end":1098,"column_start":12,"column_end":17},"name":"ztbsv","qualname":"::cblas::level2::ztbsv","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, N: i32, K: i32, A: &[T], lda: i32, X: &mut [T], incx: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5509},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1369131,"byte_end":1369136,"line_start":1122,"line_end":1122,"column_start":12,"column_end":17},"name":"ztpsv","qualname":"::cblas::level2::ztpsv","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, N: i32, Ap: &[T], X: &mut [T], incx: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5511},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1369819,"byte_end":1369824,"line_start":1142,"line_end":1142,"column_start":12,"column_end":17},"name":"ssymv","qualname":"::cblas::level2::ssymv","value":"fn (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, alpha: f32, A: &[f32], lda: i32, x: &[f32], incx: i32, beta: f32, y: &mut [f32], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5512},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1370613,"byte_end":1370618,"line_start":1168,"line_end":1168,"column_start":12,"column_end":17},"name":"ssbmv","qualname":"::cblas::level2::ssbmv","value":"fn (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, K: i32, alpha: f32, A: &[f32], lda: i32, x: &[f32], incx: i32, beta: f32, y: &mut [f32], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5513},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1371466,"byte_end":1371471,"line_start":1196,"line_end":1196,"column_start":12,"column_end":17},"name":"sspmv","qualname":"::cblas::level2::sspmv","value":"fn (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, alpha: f32, Ap: &[f32], x: &[f32], incx: i32, beta: f32, y: &mut [f32], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5514},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1372199,"byte_end":1372203,"line_start":1220,"line_end":1220,"column_start":12,"column_end":16},"name":"sger","qualname":"::cblas::level2::sger","value":"fn (order: ::cblas::Order, M: i32, N: i32, alpha: f32, x: &[f32], incx: i32, y: &[f32], incy: i32, A: &mut [f32], lda: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5515},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1372892,"byte_end":1372896,"line_start":1244,"line_end":1244,"column_start":12,"column_end":16},"name":"ssyr","qualname":"::cblas::level2::ssyr","value":"fn (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, alpha: f32, x: &[f32], incx: i32, A: &mut [f32], lda: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5516},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1373239,"byte_end":1373243,"line_start":1255,"line_end":1255,"column_start":12,"column_end":16},"name":"sspr","qualname":"::cblas::level2::sspr","value":"fn (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, alpha: f32, x: &[f32], incx: i32, Ap: &mut [f32]) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5517},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1373557,"byte_end":1373562,"line_start":1265,"line_end":1265,"column_start":12,"column_end":17},"name":"ssyr2","qualname":"::cblas::level2::ssyr2","value":"fn (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, alpha: f32, x: &[f32], incx: i32, y: &[f32], incy: i32, A: &mut [f32], lda: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5518},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1374286,"byte_end":1374291,"line_start":1289,"line_end":1289,"column_start":12,"column_end":17},"name":"sspr2","qualname":"::cblas::level2::sspr2","value":"fn (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, alpha: f32, x: &[f32], incx: i32, y: &[f32], incy: i32, A: &mut [f32]) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5519},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1374952,"byte_end":1374957,"line_start":1311,"line_end":1311,"column_start":12,"column_end":17},"name":"dsymv","qualname":"::cblas::level2::dsymv","value":"fn (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, alpha: f64, A: &[f64], lda: i32, x: &[f64], incx: i32, beta: f64, y: &mut [f64], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5520},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1375746,"byte_end":1375751,"line_start":1337,"line_end":1337,"column_start":12,"column_end":17},"name":"dsbmv","qualname":"::cblas::level2::dsbmv","value":"fn (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, K: i32, alpha: f64, A: &[f64], lda: i32, x: &[f64], incx: i32, beta: f64, y: &mut [f64], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5521},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1376599,"byte_end":1376604,"line_start":1365,"line_end":1365,"column_start":12,"column_end":17},"name":"dspmv","qualname":"::cblas::level2::dspmv","value":"fn (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, alpha: f64, Ap: &[f64], x: &[f64], incx: i32, beta: f64, y: &mut [f64], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5522},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1377332,"byte_end":1377336,"line_start":1389,"line_end":1389,"column_start":12,"column_end":16},"name":"dger","qualname":"::cblas::level2::dger","value":"fn (order: ::cblas::Order, M: i32, N: i32, alpha: f64, x: &[f64], incx: i32, y: &[f64], incy: i32, A: &mut [f64], lda: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5523},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1378025,"byte_end":1378029,"line_start":1413,"line_end":1413,"column_start":12,"column_end":16},"name":"dsyr","qualname":"::cblas::level2::dsyr","value":"fn (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, alpha: f64, x: &[f64], incx: i32, A: &mut [f64], lda: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5524},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1378372,"byte_end":1378376,"line_start":1424,"line_end":1424,"column_start":12,"column_end":16},"name":"dspr","qualname":"::cblas::level2::dspr","value":"fn (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, alpha: f64, x: &[f64], incx: i32, Ap: &mut [f64]) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5525},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1378690,"byte_end":1378695,"line_start":1434,"line_end":1434,"column_start":12,"column_end":17},"name":"dsyr2","qualname":"::cblas::level2::dsyr2","value":"fn (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, alpha: f64, x: &[f64], incx: i32, y: &[f64], incy: i32, A: &mut [f64], lda: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5526},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1379419,"byte_end":1379424,"line_start":1458,"line_end":1458,"column_start":12,"column_end":17},"name":"dspr2","qualname":"::cblas::level2::dspr2","value":"fn (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, alpha: f64, x: &[f64], incx: i32, y: &[f64], incy: i32, A: &mut [f64]) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5527},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1380085,"byte_end":1380090,"line_start":1480,"line_end":1480,"column_start":12,"column_end":17},"name":"chemv","qualname":"::cblas::level2::chemv","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, alpha: &[T], A: &[T], lda: i32, x: &[T], incx: i32, beta: &[T], y: &mut [T], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5529},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1381049,"byte_end":1381054,"line_start":1506,"line_end":1506,"column_start":12,"column_end":17},"name":"chbmv","qualname":"::cblas::level2::chbmv","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, K: i32, alpha: &[T], A: &[T], lda: i32, x: &[T], incx: i32, beta: &[T], y: &mut [T], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5531},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1382075,"byte_end":1382080,"line_start":1534,"line_end":1534,"column_start":12,"column_end":17},"name":"chpmv","qualname":"::cblas::level2::chpmv","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, alpha: &[T], Ap: &[T], x: &[T], incx: i32, beta: &[T], y: &mut [T], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5533},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1382975,"byte_end":1382980,"line_start":1558,"line_end":1558,"column_start":12,"column_end":17},"name":"csymv","qualname":"::cblas::level2::csymv","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, alpha: &[T], A: &[T], lda: i32, x: &[T], incx: i32, beta: &[T], y: &mut [T], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5535},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1383939,"byte_end":1383944,"line_start":1584,"line_end":1584,"column_start":12,"column_end":17},"name":"csbmv","qualname":"::cblas::level2::csbmv","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, K: i32, alpha: &[T], A: &[T], lda: i32, x: &[T], incx: i32, beta: &[T], y: &mut [T], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5537},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1384965,"byte_end":1384970,"line_start":1612,"line_end":1612,"column_start":12,"column_end":17},"name":"cspmv","qualname":"::cblas::level2::cspmv","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, alpha: &[T], Ap: &[T], x: &[T], incx: i32, beta: &[T], y: &mut [T], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5539},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1385865,"byte_end":1385870,"line_start":1636,"line_end":1636,"column_start":12,"column_end":17},"name":"cgeru","qualname":"::cblas::level2::cgeru","value":"fn <T> (order: ::cblas::Order, M: i32, N: i32, alpha: &[T], x: &[T], incx: i32, y: &[T], incy: i32, A: &mut [T], lda: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5541},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1386710,"byte_end":1386715,"line_start":1660,"line_end":1660,"column_start":12,"column_end":17},"name":"cgerc","qualname":"::cblas::level2::cgerc","value":"fn <T> (order: ::cblas::Order, M: i32, N: i32, alpha: &[T], x: &[T], incx: i32, y: &[T], incy: i32, A: &mut [T], lda: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5543},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1387555,"byte_end":1387559,"line_start":1684,"line_end":1684,"column_start":12,"column_end":16},"name":"cher","qualname":"::cblas::level2::cher","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, alpha: &[T], x: &[T], incx: i32, A: &mut [T], lda: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5545},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1388235,"byte_end":1388239,"line_start":1704,"line_end":1704,"column_start":12,"column_end":16},"name":"chpr","qualname":"::cblas::level2::chpr","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, alpha: &[T], x: &[T], incx: i32, Ap: &mut [T]) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5547},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1388853,"byte_end":1388858,"line_start":1722,"line_end":1722,"column_start":12,"column_end":17},"name":"cher2","qualname":"::cblas::level2::cher2","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, alpha: &[T], x: &[T], incx: i32, y: &[T], incy: i32, A: &mut [T], lda: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5549},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1389714,"byte_end":1389719,"line_start":1746,"line_end":1746,"column_start":12,"column_end":17},"name":"chpr2","qualname":"::cblas::level2::chpr2","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, alpha: &[T], x: &[T], incx: i32, y: &[f64], incy: i32, Ap: &mut [f64]) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5551},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1390515,"byte_end":1390520,"line_start":1768,"line_end":1768,"column_start":12,"column_end":17},"name":"zhemv","qualname":"::cblas::level2::zhemv","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, alpha: &[T], A: &[T], lda: i32, x: &[T], incx: i32, beta: &[T], y: &mut [T], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5553},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1391479,"byte_end":1391484,"line_start":1794,"line_end":1794,"column_start":12,"column_end":17},"name":"zhbmv","qualname":"::cblas::level2::zhbmv","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, K: i32, alpha: &[T], A: &[T], lda: i32, x: &[T], incx: i32, beta: &[T], y: &mut [T], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5555},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1392505,"byte_end":1392510,"line_start":1822,"line_end":1822,"column_start":12,"column_end":17},"name":"zhpmv","qualname":"::cblas::level2::zhpmv","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, alpha: &[T], Ap: &[T], x: &[T], incx: i32, beta: &[T], y: &mut [T], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5557},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1393405,"byte_end":1393410,"line_start":1846,"line_end":1846,"column_start":12,"column_end":17},"name":"zsymv","qualname":"::cblas::level2::zsymv","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, alpha: &[T], A: &[T], lda: i32, x: &[T], incx: i32, beta: &[T], y: &mut [T], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5559},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1394369,"byte_end":1394374,"line_start":1872,"line_end":1872,"column_start":12,"column_end":17},"name":"zsbmv","qualname":"::cblas::level2::zsbmv","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, K: i32, alpha: &[T], A: &[T], lda: i32, x: &[T], incx: i32, beta: &[T], y: &mut [T], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5561},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1395395,"byte_end":1395400,"line_start":1900,"line_end":1900,"column_start":12,"column_end":17},"name":"zspmv","qualname":"::cblas::level2::zspmv","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, alpha: &[T], Ap: &[T], x: &[T], incx: i32, beta: &[T], y: &mut [T], incy: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5563},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1396295,"byte_end":1396300,"line_start":1924,"line_end":1924,"column_start":12,"column_end":17},"name":"zgeru","qualname":"::cblas::level2::zgeru","value":"fn <T> (order: ::cblas::Order, M: i32, N: i32, alpha: &[T], x: &[T], incx: i32, y: &[T], incy: i32, A: &mut [T], lda: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5565},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1397140,"byte_end":1397145,"line_start":1948,"line_end":1948,"column_start":12,"column_end":17},"name":"zgerc","qualname":"::cblas::level2::zgerc","value":"fn <T> (order: ::cblas::Order, M: i32, N: i32, alpha: &[T], x: &[T], incx: i32, y: &[T], incy: i32, A: &mut [T], lda: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5567},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1397985,"byte_end":1397989,"line_start":1972,"line_end":1972,"column_start":12,"column_end":16},"name":"zher","qualname":"::cblas::level2::zher","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, alpha: &[T], x: &[T], incx: i32, A: &mut [T], lda: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5569},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1398665,"byte_end":1398669,"line_start":1992,"line_end":1992,"column_start":12,"column_end":16},"name":"zhpr","qualname":"::cblas::level2::zhpr","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, alpha: &[T], x: &[T], incx: i32, Ap: &mut [T]) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5571},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1399283,"byte_end":1399288,"line_start":2010,"line_end":2010,"column_start":12,"column_end":17},"name":"zher2","qualname":"::cblas::level2::zher2","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, alpha: &[T], x: &[T], incx: i32, y: &[T], incy: i32, A: &mut [T], lda: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5573},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1400144,"byte_end":1400149,"line_start":2034,"line_end":2034,"column_start":12,"column_end":17},"name":"zhpr2","qualname":"::cblas::level2::zhpr2","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, N: i32, alpha: &[T], x: &[T], incx: i32, y: &[f64], incy: i32, Ap: &mut [f64]) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5575},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1400944,"byte_end":1400950,"line_start":2057,"line_end":2057,"column_start":9,"column_end":15},"name":"level3","qualname":"::cblas::level3","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","parent":null,"children":[{"krate":0,"index":5576},{"krate":0,"index":5577},{"krate":0,"index":5578},{"krate":0,"index":5579},{"krate":0,"index":5580},{"krate":0,"index":5581},{"krate":0,"index":5582},{"krate":0,"index":5583},{"krate":0,"index":5584},{"krate":0,"index":5585},{"krate":0,"index":5586},{"krate":0,"index":5587},{"krate":0,"index":5588},{"krate":0,"index":5590},{"krate":0,"index":5592},{"krate":0,"index":5594},{"krate":0,"index":5596},{"krate":0,"index":5598},{"krate":0,"index":5600},{"krate":0,"index":5602},{"krate":0,"index":5604},{"krate":0,"index":5606},{"krate":0,"index":5608},{"krate":0,"index":5610},{"krate":0,"index":5612},{"krate":0,"index":5614},{"krate":0,"index":5616},{"krate":0,"index":5618},{"krate":0,"index":5620},{"krate":0,"index":5622}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5576},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1402055,"byte_end":1402060,"line_start":2078,"line_end":2078,"column_start":12,"column_end":17},"name":"sgemm","qualname":"::cblas::level3::sgemm","value":"fn (order: ::cblas::Order, transA: ::cblas::Transpose, transB: ::cblas::Transpose, M: i32, N: i32, K: i32, alpha: f32, A: &[f32], lda: i32, B: &[f32], ldb: i32, beta: f32, C: &mut [f32], ldc: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" General ::types::Matrix-MatrixF64 multiplication for single precision float.","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5577},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1403972,"byte_end":1403977,"line_start":2127,"line_end":2127,"column_start":12,"column_end":17},"name":"ssymm","qualname":"::cblas::level3::ssymm","value":"fn (order: ::cblas::Order, side: ::cblas::Side, uplo: ::cblas::Uplo, M: i32, N: i32, alpha: f32, A: &[f32], lda: i32, B: &[f32], ldb: i32, beta: f32, C: &mut [f32], ldc: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Symmetric ::types::Matrix-MatrixF64 multiplication for single precision float.","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5578},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1404896,"byte_end":1404901,"line_start":2157,"line_end":2157,"column_start":12,"column_end":17},"name":"ssyrk","qualname":"::cblas::level3::ssyrk","value":"fn (order: ::cblas::Order, uplo: ::cblas::Uplo, trans: ::cblas::Transpose, N: i32, K: i32, alpha: f32, A: &[f32], lda: i32, beta: f32, C: &mut [f32], ldc: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5579},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1405693,"byte_end":1405699,"line_start":2183,"line_end":2183,"column_start":12,"column_end":18},"name":"ssyr2k","qualname":"::cblas::level3::ssyr2k","value":"fn (order: ::cblas::Order, uplo: ::cblas::Uplo, trans: ::cblas::Transpose, N: i32, K: i32, alpha: f32, A: &[f32], lda: i32, B: &[f32], ldb: i32, beta: f32, C: &mut [f32], ldc: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5580},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1406650,"byte_end":1406655,"line_start":2213,"line_end":2213,"column_start":12,"column_end":17},"name":"strmm","qualname":"::cblas::level3::strmm","value":"fn (order: ::cblas::Order, side: ::cblas::Side, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, M: i32, N: i32, alpha: f32, A: &[f32], lda: i32, B: &mut [f32], ldb: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5581},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1407534,"byte_end":1407539,"line_start":2241,"line_end":2241,"column_start":12,"column_end":17},"name":"strsm","qualname":"::cblas::level3::strsm","value":"fn (order: ::cblas::Order, side: ::cblas::Side, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, M: i32, N: i32, alpha: f32, A: &[f32], lda: i32, B: &mut [f32], ldb: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5582},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1408418,"byte_end":1408423,"line_start":2269,"line_end":2269,"column_start":12,"column_end":17},"name":"dgemm","qualname":"::cblas::level3::dgemm","value":"fn (order: ::cblas::Order, transA: ::cblas::Transpose, transB: ::cblas::Transpose, M: i32, N: i32, K: i32, alpha: f64, A: &[f64], lda: i32, B: &[f64], ldb: i32, beta: f64, C: &mut [f64], ldc: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5583},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1409419,"byte_end":1409424,"line_start":2301,"line_end":2301,"column_start":12,"column_end":17},"name":"dsymm","qualname":"::cblas::level3::dsymm","value":"fn (order: ::cblas::Order, side: ::cblas::Side, uplo: ::cblas::Uplo, M: i32, N: i32, alpha: f64, A: &[f64], lda: i32, B: &[f64], ldb: i32, beta: f64, C: &mut [f64], ldc: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5584},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1410343,"byte_end":1410348,"line_start":2331,"line_end":2331,"column_start":12,"column_end":17},"name":"dsyrk","qualname":"::cblas::level3::dsyrk","value":"fn (order: ::cblas::Order, uplo: ::cblas::Uplo, trans: ::cblas::Transpose, N: i32, K: i32, alpha: f64, A: &[f64], lda: i32, beta: f64, C: &mut [f64], ldc: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5585},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1411140,"byte_end":1411146,"line_start":2357,"line_end":2357,"column_start":12,"column_end":18},"name":"dsyr2k","qualname":"::cblas::level3::dsyr2k","value":"fn (order: ::cblas::Order, uplo: ::cblas::Uplo, trans: ::cblas::Transpose, N: i32, K: i32, alpha: f64, A: &[f64], lda: i32, B: &[f64], ldb: i32, beta: f64, C: &mut [f64], ldc: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5586},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1412097,"byte_end":1412102,"line_start":2387,"line_end":2387,"column_start":12,"column_end":17},"name":"dtrmm","qualname":"::cblas::level3::dtrmm","value":"fn (order: ::cblas::Order, side: ::cblas::Side, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, M: i32, N: i32, alpha: f64, A: &[f64], lda: i32, B: &mut [f64], ldb: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5587},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1412981,"byte_end":1412986,"line_start":2415,"line_end":2415,"column_start":12,"column_end":17},"name":"dtrsm","qualname":"::cblas::level3::dtrsm","value":"fn (order: ::cblas::Order, side: ::cblas::Side, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, M: i32, N: i32, alpha: f64, A: &[f64], lda: i32, B: &mut [f64], ldb: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5588},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1413865,"byte_end":1413870,"line_start":2443,"line_end":2443,"column_start":12,"column_end":17},"name":"cgemm","qualname":"::cblas::level3::cgemm","value":"fn <T> (order: ::cblas::Order, transA: ::cblas::Transpose, transB: ::cblas::Transpose, M: i32, N: i32, K: i32, alpha: &[T], A: &[T], lda: i32, B: &[T], ldb: i32, beta: &[T], C: &mut [T], ldc: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5590},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1415045,"byte_end":1415050,"line_start":2475,"line_end":2475,"column_start":12,"column_end":17},"name":"csymm","qualname":"::cblas::level3::csymm","value":"fn <T> (order: ::cblas::Order, side: ::cblas::Side, uplo: ::cblas::Uplo, M: i32, N: i32, alpha: &[T], A: &[T], lda: i32, B: &[T], ldb: i32, beta: &[T], C: &mut [T], ldc: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5592},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1416145,"byte_end":1416150,"line_start":2505,"line_end":2505,"column_start":12,"column_end":17},"name":"csyrk","qualname":"::cblas::level3::csyrk","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, trans: ::cblas::Transpose, N: i32, K: i32, alpha: &[T], A: &[T], lda: i32, beta: &[T], C: &mut [T], ldc: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5594},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1417089,"byte_end":1417095,"line_start":2531,"line_end":2531,"column_start":12,"column_end":18},"name":"csyr2k","qualname":"::cblas::level3::csyr2k","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, trans: ::cblas::Transpose, N: i32, K: i32, alpha: &[T], A: &[T], lda: i32, B: &[T], ldb: i32, beta: &[T], C: &mut [T], ldc: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5596},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1418222,"byte_end":1418227,"line_start":2561,"line_end":2561,"column_start":12,"column_end":17},"name":"ctrmm","qualname":"::cblas::level3::ctrmm","value":"fn <T> (order: ::cblas::Order, side: ::cblas::Side, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, M: i32, N: i32, alpha: &[T], A: &[T], lda: i32, B: &mut [T], ldb: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5598},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1419221,"byte_end":1419226,"line_start":2589,"line_end":2589,"column_start":12,"column_end":17},"name":"ctrsm","qualname":"::cblas::level3::ctrsm","value":"fn <T> (order: ::cblas::Order, side: ::cblas::Side, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, M: i32, N: i32, alpha: &[T], A: &[T], lda: i32, B: &mut [T], ldb: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5600},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1420220,"byte_end":1420225,"line_start":2617,"line_end":2617,"column_start":12,"column_end":17},"name":"zgemm","qualname":"::cblas::level3::zgemm","value":"fn <T> (order: ::cblas::Order, transA: ::cblas::Transpose, transB: ::cblas::Transpose, M: i32, N: i32, K: i32, alpha: &[T], A: &[T], lda: i32, B: &[T], ldb: i32, beta: &[T], C: &mut [T], ldc: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5602},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1421400,"byte_end":1421405,"line_start":2649,"line_end":2649,"column_start":12,"column_end":17},"name":"zsymm","qualname":"::cblas::level3::zsymm","value":"fn <T> (order: ::cblas::Order, side: ::cblas::Side, uplo: ::cblas::Uplo, M: i32, N: i32, alpha: &[T], A: &[T], lda: i32, B: &[T], ldb: i32, beta: &[T], C: &mut [T], ldc: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5604},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1422500,"byte_end":1422505,"line_start":2679,"line_end":2679,"column_start":12,"column_end":17},"name":"zsyrk","qualname":"::cblas::level3::zsyrk","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, trans: ::cblas::Transpose, N: i32, K: i32, alpha: &[T], A: &[T], lda: i32, beta: &[T], C: &mut [T], ldc: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5606},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1423444,"byte_end":1423450,"line_start":2705,"line_end":2705,"column_start":12,"column_end":18},"name":"zsyr2k","qualname":"::cblas::level3::zsyr2k","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, trans: ::cblas::Transpose, N: i32, K: i32, alpha: &[T], A: &[T], lda: i32, B: &[T], ldb: i32, beta: &[T], C: &mut [T], ldc: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5608},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1424577,"byte_end":1424582,"line_start":2735,"line_end":2735,"column_start":12,"column_end":17},"name":"ztrmm","qualname":"::cblas::level3::ztrmm","value":"fn <T> (order: ::cblas::Order, side: ::cblas::Side, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, M: i32, N: i32, alpha: &[T], A: &[T], lda: i32, B: &mut [T], ldb: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5610},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1425576,"byte_end":1425581,"line_start":2763,"line_end":2763,"column_start":12,"column_end":17},"name":"ztrsm","qualname":"::cblas::level3::ztrsm","value":"fn <T> (order: ::cblas::Order, side: ::cblas::Side, uplo: ::cblas::Uplo, transA: ::cblas::Transpose, diag: ::cblas::Diag, M: i32, N: i32, alpha: &[T], A: &[T], lda: i32, B: &mut [T], ldb: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5612},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1426575,"byte_end":1426580,"line_start":2791,"line_end":2791,"column_start":12,"column_end":17},"name":"chemm","qualname":"::cblas::level3::chemm","value":"fn <T> (order: ::cblas::Order, side: ::cblas::Side, uplo: ::cblas::Uplo, M: i32, N: i32, alpha: &[T], A: &[T], lda: i32, B: &[T], ldb: i32, beta: &[T], C: &mut [T], ldc: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5614},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1427675,"byte_end":1427680,"line_start":2821,"line_end":2821,"column_start":12,"column_end":17},"name":"cherk","qualname":"::cblas::level3::cherk","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, trans: ::cblas::Transpose, N: i32, K: i32, alpha: &[T], A: &[T], lda: i32, beta: &[T], C: &mut [T], ldc: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5616},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1428619,"byte_end":1428625,"line_start":2847,"line_end":2847,"column_start":12,"column_end":18},"name":"cher2k","qualname":"::cblas::level3::cher2k","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, trans: ::cblas::Transpose, N: i32, K: i32, alpha: &[T], A: &[T], lda: i32, B: &[T], ldb: i32, beta: &[T], C: &mut [T], ldc: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5618},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1429752,"byte_end":1429757,"line_start":2877,"line_end":2877,"column_start":12,"column_end":17},"name":"zhemm","qualname":"::cblas::level3::zhemm","value":"fn <T> (order: ::cblas::Order, side: ::cblas::Side, uplo: ::cblas::Uplo, M: i32, N: i32, alpha: &[T], A: &[T], lda: i32, B: &[T], ldb: i32, beta: &[T], C: &mut [T], ldc: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5620},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1430852,"byte_end":1430857,"line_start":2907,"line_end":2907,"column_start":12,"column_end":17},"name":"zherk","qualname":"::cblas::level3::zherk","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, trans: ::cblas::Transpose, N: i32, K: i32, alpha: f64, A: &[T], lda: i32, beta: f64, C: &mut [T], ldc: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5622},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/cblas.rs","byte_start":1431726,"byte_end":1431732,"line_start":2933,"line_end":2933,"column_start":12,"column_end":18},"name":"zher2k","qualname":"::cblas::level3::zher2k","value":"fn <T> (order: ::cblas::Order, uplo: ::cblas::Uplo, trans: ::cblas::Transpose, N: i32, K: i32, alpha: &[T], A: &[T], lda: i32, B: &[T], ldb: i32, beta: &[T], C: &mut [T], ldc: i32) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5624},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/clausen.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"clausen","qualname":"::clausen","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/clausen.rs","parent":null,"children":[{"krate":0,"index":5625},{"krate":0,"index":5626},{"krate":0,"index":5627},{"krate":0,"index":5628},{"krate":0,"index":5629}],"decl_id":null,"docs":"The Clausen function is defined by the following integral,","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5628},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/clausen.rs","byte_start":1433238,"byte_end":1433245,"line_start":18,"line_end":18,"column_start":8,"column_end":15},"name":"clausen","qualname":"::clausen::clausen","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Clausen integral Cl_2(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5629},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/clausen.rs","byte_start":1433367,"byte_end":1433376,"line_start":23,"line_end":23,"column_start":8,"column_end":17},"name":"clausen_e","qualname":"::clausen::clausen_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Clausen integral Cl_2(x).\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5630},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/coulomb.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"coulomb","qualname":"::coulomb","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/coulomb.rs","parent":null,"children":[{"krate":0,"index":5631},{"krate":0,"index":5632},{"krate":0,"index":5633},{"krate":0,"index":5634},{"krate":0,"index":5635},{"krate":0,"index":5636},{"krate":0,"index":5637},{"krate":0,"index":5638},{"krate":0,"index":5639},{"krate":0,"index":5640},{"krate":0,"index":5641},{"krate":0,"index":5642},{"krate":0,"index":5643},{"krate":0,"index":5644}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5634},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/coulomb.rs","byte_start":1433906,"byte_end":1433919,"line_start":10,"line_end":10,"column_start":8,"column_end":21},"name":"hydrogenicR_1","qualname":"::coulomb::hydrogenicR_1","value":"fn (Z: f64, r: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the lowest-order normalized hydrogenic bound state radial wavefunction R_1 := 2Z \\sqrt{Z} \\exp(-Z r).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5635},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/coulomb.rs","byte_start":1434130,"byte_end":1434145,"line_start":15,"line_end":15,"column_start":8,"column_end":23},"name":"hydrogenicR_1_e","qualname":"::coulomb::hydrogenicR_1_e","value":"fn (Z: f64, r: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the lowest-order normalized hydrogenic bound state radial wavefunction R_1 := 2Z \\sqrt{Z} \\exp(-Z r).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5636},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/coulomb.rs","byte_start":1434925,"byte_end":1434936,"line_start":29,"line_end":29,"column_start":8,"column_end":19},"name":"hydrogenicR","qualname":"::coulomb::hydrogenicR","value":"fn (n: i32, l: i32, Z: f64, r: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the n-th normalized hydrogenic bound state radial wavefunction,\n \n R_n := 2 (Z^{3/2}/n^2) \\sqrt{(n-l-1)!/(n+l)!} \\exp(-Z r/n) (2Zr/n)^l\n           L^{2l+1}_{n-l-1}(2Zr/n).  \n \n where L^a_b(x) is the generalized Laguerre polynomial (see [`Laguerre Functions`](http://www.gnu.org/software/gsl/manual/html_node/Laguerre-Functions.html#Laguerre-Functions)).\n The normalization is chosen such that the wavefunction \\psi is given by \\psi(n,l,r) = R_n Y_{lm}.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5637},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/coulomb.rs","byte_start":1435536,"byte_end":1435549,"line_start":40,"line_end":40,"column_start":8,"column_end":21},"name":"hydrogenicR_e","qualname":"::coulomb::hydrogenicR_e","value":"fn (n: i32, l: i32, Z: f64, r: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the n-th normalized hydrogenic bound state radial wavefunction,\n \n R_n := 2 (Z^{3/2}/n^2) \\sqrt{(n-l-1)!/(n+l)!} \\exp(-Z r/n) (2Zr/n)^l\n           L^{2l+1}_{n-l-1}(2Zr/n).  \n \n where L^a_b(x) is the generalized Laguerre polynomial (see [`Laguerre Functions`](http://www.gnu.org/software/gsl/manual/html_node/Laguerre-Functions.html#Laguerre-Functions)).\n The normalization is chosen such that the wavefunction \\psi is given by \\psi(n,l,r) = R_n Y_{lm}.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5638},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/coulomb.rs","byte_start":1436369,"byte_end":1436378,"line_start":49,"line_end":49,"column_start":8,"column_end":17},"name":"wave_FG_e","qualname":"::coulomb::wave_FG_e","value":"fn (eta: f64, x: f64, L_F: f64, k: i32, exp_F: &mut f64, exp_G: &mut f64) -> (enums::Value, ::types::Result, ::types::Result, ::types::Result,\n ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This function computes the Coulomb wave functions F_L(\\eta,x), G_{L-k}(\\eta,x) and their derivatives F'_L(\\eta,x), G'_{L-k}(\\eta,x) with respect to x. The parameters are restricted to L, L-k > -1/2, x > 0 and integer k. Note that L itself is not restricted to being an integer. The results are stored in the parameters F, G for the function values and Fp, Gp for the derivative values.\n If an overflow occurs, GSL_EOVRFLW is returned and scaling exponents are stored in the modifiable parameters exp_F, exp_G.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5639},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/coulomb.rs","byte_start":1437347,"byte_end":1437359,"line_start":72,"line_end":72,"column_start":8,"column_end":20},"name":"wave_F_array","qualname":"::coulomb::wave_F_array","value":"fn (L_min: f64, eta: f64, x: f64, fc_array: &mut [f64], F_exponent: &mut f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the Coulomb wave function F_L(\\eta,x) for L = Lmin \\dots Lmin + kmax, storing the results in fc_array.\n In the case of overflow the exponent is stored in F_exponent.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5640},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/coulomb.rs","byte_start":1437863,"byte_end":1437876,"line_start":86,"line_end":86,"column_start":8,"column_end":21},"name":"wave_FG_array","qualname":"::coulomb::wave_FG_array","value":"fn (L_min: f64, eta: f64, x: f64, fc_array: &mut [f64], gc_array: &mut [f64], F_exponent: &mut f64, G_exponent: &mut f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the functions F_L(\\eta,x), G_L(\\eta,x) for L = Lmin \\dots Lmin + kmax storing the results in fc_array and gc_array.\n In the case of overflow the exponents are stored in F_exponent and G_exponent.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5641},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/coulomb.rs","byte_start":1438621,"byte_end":1438635,"line_start":104,"line_end":104,"column_start":8,"column_end":22},"name":"wave_FGp_array","qualname":"::coulomb::wave_FGp_array","value":"fn (L_min: f64, eta: f64, x: f64, fc_array: &mut [f64], fcp_array: &mut [f64], gc_array: &mut [f64], gcp_array: &mut [f64], F_exponent: &mut f64, G_exponent: &mut f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the functions F_L(\\eta,x), G_L(\\eta,x) and their derivatives F'_L(\\eta,x), G'_L(\\eta,x) for L = Lmin \\dots Lmin + kmax storing the results in fc_array, gc_array, fcp_array and gcp_array.\n In the case of overflow the exponents are stored in F_exponent and G_exponent.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5642},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/coulomb.rs","byte_start":1439530,"byte_end":1439545,"line_start":125,"line_end":125,"column_start":8,"column_end":23},"name":"wave_sphF_array","qualname":"::coulomb::wave_sphF_array","value":"fn (L_min: f64, eta: f64, x: f64, fc_array: &mut [f64], F_exponent: &mut f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the Coulomb wave function divided by the argument F_L(\\eta, x)/x for L = Lmin \\dots Lmin + kmax, storing the results in fc_array.\n In the case of overflow the exponent is stored in F_exponent. This function reduces to spherical Bessel functions in the limit \\eta \\to 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5643},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/coulomb.rs","byte_start":1439964,"byte_end":1439968,"line_start":138,"line_end":138,"column_start":8,"column_end":12},"name":"CL_e","qualname":"::coulomb::CL_e","value":"fn (L: f64, eta: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This function computes the Coulomb wave function normalization constant C_L(\\eta) for L > -1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5644},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/coulomb.rs","byte_start":1440381,"byte_end":1440389,"line_start":146,"line_end":146,"column_start":8,"column_end":16},"name":"CL_array","qualname":"::coulomb::CL_array","value":"fn (Lmin: f64, eta: f64, cl: &mut [f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the Coulomb wave function normalization constant C_L(\\eta) for L = Lmin \\dots Lmin + kmax, Lmin > -1.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5645},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/coupling_coefficients.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"coupling_coefficients","qualname":"::coupling_coefficients","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/coupling_coefficients.rs","parent":null,"children":[{"krate":0,"index":5646},{"krate":0,"index":5647},{"krate":0,"index":5648},{"krate":0,"index":5649},{"krate":0,"index":5650},{"krate":0,"index":5651},{"krate":0,"index":5652},{"krate":0,"index":5653}],"decl_id":null,"docs":"The Wigner 3-j, 6-j and 9-j symbols give the coupling coefficients for combined angular momentum vectors.\nSince the arguments of the standard coupling coefficient functions are integer or half-integer, the arguments of the following functions\nare, by convention, integers equal to twice the actual spin value.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5648},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/coupling_coefficients.rs","byte_start":1441256,"byte_end":1441259,"line_start":20,"line_end":20,"column_start":8,"column_end":11},"name":"_3j","qualname":"::coupling_coefficients::_3j","value":"fn (two_ja: i32, two_jb: i32, two_jc: i32, two_ma: i32, two_mb: i32, two_mc: i32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Wigner 3-j coefficient,\n \n (ja jb jc\n  ma mb mc)\n \n where the arguments are given in half-integer units, ja = two_ja/2, ma = two_ma/2, etc.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5649},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/coupling_coefficients.rs","byte_start":1441631,"byte_end":1441636,"line_start":30,"line_end":30,"column_start":8,"column_end":13},"name":"_3j_e","qualname":"::coupling_coefficients::_3j_e","value":"fn (two_ja: i32, two_jb: i32, two_jc: i32, two_ma: i32, two_mb: i32, two_mc: i32) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Wigner 3-j coefficient,\n \n (ja jb jc\n  ma mb mc)\n \n where the arguments are given in half-integer units, ja = two_ja/2, ma = two_ma/2, etc.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5650},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/coupling_coefficients.rs","byte_start":1442209,"byte_end":1442212,"line_start":43,"line_end":43,"column_start":8,"column_end":11},"name":"_6j","qualname":"::coupling_coefficients::_6j","value":"fn (two_ja: i32, two_jb: i32, two_jc: i32, two_jd: i32, two_je: i32, two_jf: i32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Wigner 6-j coefficient,\n \n {ja jb jc\n jd je jf}\n \n where the arguments are given in half-integer units, ja = two_ja/2, ma = two_ma/2, etc.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5651},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/coupling_coefficients.rs","byte_start":1442583,"byte_end":1442588,"line_start":53,"line_end":53,"column_start":8,"column_end":13},"name":"_6j_e","qualname":"::coupling_coefficients::_6j_e","value":"fn (two_ja: i32, two_jb: i32, two_jc: i32, two_jd: i32, two_je: i32, two_jf: i32) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Wigner 6-j coefficient,\n \n {ja jb jc\n jd je jf}\n \n where the arguments are given in half-integer units, ja = two_ja/2, ma = two_ma/2, etc.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5652},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/coupling_coefficients.rs","byte_start":1443169,"byte_end":1443172,"line_start":66,"line_end":66,"column_start":8,"column_end":11},"name":"_9j","qualname":"::coupling_coefficients::_9j","value":"fn (two_ja: i32, two_jb: i32, two_jc: i32, two_jd: i32, two_je: i32, two_jf: i32, two_jg: i32, two_jh: i32, two_ji: i32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Wigner 9-j coefficient,\n \n {ja jb jc\n jd je jf\n jg jh ji}\n where the arguments are given in half-integer units, ja = two_ja/2, ma = two_ma/2, etc.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5653},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/coupling_coefficients.rs","byte_start":1443618,"byte_end":1443623,"line_start":77,"line_end":77,"column_start":8,"column_end":13},"name":"_9j_e","qualname":"::coupling_coefficients::_9j_e","value":"fn (two_ja: i32, two_jb: i32, two_jc: i32, two_jd: i32, two_je: i32, two_jf: i32, two_jg: i32, two_jh: i32, two_ji: i32) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Wigner 9-j coefficient,\n \n {ja jb jc\n jd je jf\n jg jh ji}\n where the arguments are given in half-integer units, ja = two_ja/2, ma = two_ma/2, etc.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5654},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/dawson.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"dawson","qualname":"::dawson","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/dawson.rs","parent":null,"children":[{"krate":0,"index":5655},{"krate":0,"index":5656},{"krate":0,"index":5657},{"krate":0,"index":5658}],"decl_id":null,"docs":"The Dawson integral is defined by \\exp(-x^2) \\int_0^x dt \\exp(t^2).\nA table of Dawson’s integral can be found in Abramowitz & Stegun, Table 7.5.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5657},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/dawson.rs","byte_start":1444436,"byte_end":1444442,"line_start":14,"line_end":14,"column_start":8,"column_end":14},"name":"dawson","qualname":"::dawson::dawson","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the value of Dawson’s integral for x.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5658},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/dawson.rs","byte_start":1444575,"byte_end":1444583,"line_start":19,"line_end":19,"column_start":8,"column_end":16},"name":"dawson_e","qualname":"::dawson::dawson_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the value of Dawson’s integral for x.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5659},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/debye.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"debye","qualname":"::debye","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/debye.rs","parent":null,"children":[{"krate":0,"index":5660},{"krate":0,"index":5661},{"krate":0,"index":5662},{"krate":0,"index":5663},{"krate":0,"index":5664},{"krate":0,"index":5665},{"krate":0,"index":5666},{"krate":0,"index":5667},{"krate":0,"index":5668},{"krate":0,"index":5669},{"krate":0,"index":5670},{"krate":0,"index":5671},{"krate":0,"index":5672},{"krate":0,"index":5673}],"decl_id":null,"docs":"The Debye functions D_n(x) are defined by the following integral,","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5662},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/debye.rs","byte_start":1445260,"byte_end":1445262,"line_start":17,"line_end":17,"column_start":8,"column_end":10},"name":"_1","qualname":"::debye::_1","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the first-order Debye function D_1(x) = (1/x) \\int_0^x dt (t/(e^t - 1)).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5663},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/debye.rs","byte_start":1445429,"byte_end":1445433,"line_start":22,"line_end":22,"column_start":8,"column_end":12},"name":"_1_e","qualname":"::debye::_1_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the first-order Debye function D_1(x) = (1/x) \\int_0^x dt (t/(e^t - 1)).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5664},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/debye.rs","byte_start":1445807,"byte_end":1445809,"line_start":30,"line_end":30,"column_start":8,"column_end":10},"name":"_2","qualname":"::debye::_2","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the second-order Debye function D_2(x) = (2/x^2) \\int_0^x dt (t^2/(e^t - 1)).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5665},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/debye.rs","byte_start":1445981,"byte_end":1445985,"line_start":35,"line_end":35,"column_start":8,"column_end":12},"name":"_2_e","qualname":"::debye::_2_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the second-order Debye function D_2(x) = (2/x^2) \\int_0^x dt (t^2/(e^t - 1)).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5666},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/debye.rs","byte_start":1446358,"byte_end":1446360,"line_start":43,"line_end":43,"column_start":8,"column_end":10},"name":"_3","qualname":"::debye::_3","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the third-order Debye function D_3(x) = (3/x^3) \\int_0^x dt (t^3/(e^t - 1)).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5667},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/debye.rs","byte_start":1446531,"byte_end":1446535,"line_start":48,"line_end":48,"column_start":8,"column_end":12},"name":"_3_e","qualname":"::debye::_3_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the third-order Debye function D_3(x) = (3/x^3) \\int_0^x dt (t^3/(e^t - 1)).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5668},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/debye.rs","byte_start":1446909,"byte_end":1446911,"line_start":56,"line_end":56,"column_start":8,"column_end":10},"name":"_4","qualname":"::debye::_4","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the fourth-order Debye function D_4(x) = (4/x^4) \\int_0^x dt (t^4/(e^t - 1)).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5669},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/debye.rs","byte_start":1447083,"byte_end":1447087,"line_start":61,"line_end":61,"column_start":8,"column_end":12},"name":"_4_e","qualname":"::debye::_4_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the fourth-order Debye function D_4(x) = (4/x^4) \\int_0^x dt (t^4/(e^t - 1)).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5670},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/debye.rs","byte_start":1447460,"byte_end":1447462,"line_start":69,"line_end":69,"column_start":8,"column_end":10},"name":"_5","qualname":"::debye::_5","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the fifth-order Debye function D_5(x) = (5/x^5) \\int_0^x dt (t^5/(e^t - 1)).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5671},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/debye.rs","byte_start":1447633,"byte_end":1447637,"line_start":74,"line_end":74,"column_start":8,"column_end":12},"name":"_5_e","qualname":"::debye::_5_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the fifth-order Debye function D_5(x) = (5/x^5) \\int_0^x dt (t^5/(e^t - 1)).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5672},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/debye.rs","byte_start":1448010,"byte_end":1448012,"line_start":82,"line_end":82,"column_start":8,"column_end":10},"name":"_6","qualname":"::debye::_6","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the sixth-order Debye function D_6(x) = (6/x^6) \\int_0^x dt (t^6/(e^t - 1)).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5673},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/debye.rs","byte_start":1448183,"byte_end":1448187,"line_start":87,"line_end":87,"column_start":8,"column_end":12},"name":"_6_e","qualname":"::debye::_6_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the sixth-order Debye function D_6(x) = (6/x^6) \\int_0^x dt (t^6/(e^t - 1)).\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5674},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/dilogarithm.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"dilogarithm","qualname":"::dilogarithm","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/dilogarithm.rs","parent":null,"children":[{"krate":0,"index":5675},{"krate":0,"index":5676},{"krate":0,"index":5677},{"krate":0,"index":5678},{"krate":0,"index":5679}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5677},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/dilogarithm.rs","byte_start":1449014,"byte_end":1449019,"line_start":12,"line_end":12,"column_start":8,"column_end":13},"name":"dilog","qualname":"::dilogarithm::dilog","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" These routines compute the dilogarithm for a real argument. In Lewin’s notation this is Li_2(x), the real part of the dilogarithm of a real x.\n It is defined by the integral representation Li_2(x) = - \\Re \\int_0^x ds \\log(1-s) / s. Note that \\Im(Li_2(x)) = 0 for x <= 1, and -\\pi\\log(x) for x > 1.\n \n Note that Abramowitz & Stegun refer to the Spence integral S(x)=Li_2(1-x) as the dilogarithm rather than Li_2(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5678},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/dilogarithm.rs","byte_start":1449515,"byte_end":1449522,"line_start":20,"line_end":20,"column_start":8,"column_end":15},"name":"dilog_e","qualname":"::dilogarithm::dilog_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" These routines compute the dilogarithm for a real argument. In Lewin’s notation this is Li_2(x), the real part of the dilogarithm of a real x.\n It is defined by the integral representation Li_2(x) = - \\Re \\int_0^x ds \\log(1-s) / s. Note that \\Im(Li_2(x)) = 0 for x <= 1, and -\\pi\\log(x) for x > 1.\n \n Note that Abramowitz & Stegun refer to the Spence integral S(x)=Li_2(1-x) as the dilogarithm rather than Li_2(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5679},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/dilogarithm.rs","byte_start":1449985,"byte_end":1450000,"line_start":29,"line_end":29,"column_start":8,"column_end":23},"name":"complex_dilog_e","qualname":"::dilogarithm::complex_dilog_e","value":"fn (r: f64, theta: f64) -> (enums::Value, ::types::Result, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This function computes the full complex-valued dilogarithm for the complex argument z = r \\exp(i \\theta).\n The real and imaginary parts of the result are returned in result_re, result_im.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5680},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/eigen.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"eigen","qualname":"::eigen","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/eigen.rs","parent":null,"children":[{"krate":0,"index":5681},{"krate":0,"index":5682},{"krate":0,"index":5683},{"krate":0,"index":5688},{"krate":0,"index":5689},{"krate":0,"index":5690},{"krate":0,"index":5691},{"krate":0,"index":5692},{"krate":0,"index":5693}],"decl_id":null,"docs":"##References and Further Reading","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5688},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/eigen.rs","byte_start":1451724,"byte_end":1451734,"line_start":28,"line_end":28,"column_start":8,"column_end":18},"name":"symmv_sort","qualname":"::eigen::symmv_sort","value":"fn (eval: &mut VectorF64, evec: &mut MatrixF64, sort_type: ::EigenSort) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function simultaneously sorts the eigenvalues stored in the vector eval and the corresponding real eigenvectors stored in the columns\n of the matrix evec into ascending or descending order according to the value of the parameter sort_type\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5689},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/eigen.rs","byte_start":1452239,"byte_end":1452249,"line_start":36,"line_end":36,"column_start":8,"column_end":18},"name":"hermv_sort","qualname":"::eigen::hermv_sort","value":"fn (eval: &mut VectorF64, evec: &mut MatrixComplexF64, sort_type: ::EigenSort) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function simultaneously sorts the eigenvalues stored in the vector eval and the corresponding complex eigenvectors stored in the columns\n of the matrix evec into ascending or descending order according to the value of the parameter sort_type.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5690},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/eigen.rs","byte_start":1452863,"byte_end":1452876,"line_start":45,"line_end":45,"column_start":8,"column_end":21},"name":"nonsymmv_sort","qualname":"::eigen::nonsymmv_sort","value":"fn (eval: &mut VectorComplexF64, evec: &mut MatrixComplexF64, sort_type: ::EigenSort) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function simultaneously sorts the eigenvalues stored in the vector eval and the corresponding complex eigenvectors stored in the columns\n of the matrix evec into ascending or descending order according to the value of the parameter sort_type. Only EigenSort::AbsAsc and\n EigenSort::AbsDesc are supported due to the eigenvalues being complex.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5691},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/eigen.rs","byte_start":1453509,"byte_end":1453522,"line_start":54,"line_end":54,"column_start":8,"column_end":21},"name":"gensymmv_sort","qualname":"::eigen::gensymmv_sort","value":"fn (eval: &mut VectorF64, evec: &mut MatrixF64, sort_type: ::EigenSort) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function simultaneously sorts the eigenvalues stored in the vector eval and the corresponding real eigenvectors stored in the columns\n of the matrix evec into ascending or descending order according to the value of the parameter sort_type.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5692},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/eigen.rs","byte_start":1454030,"byte_end":1454043,"line_start":62,"line_end":62,"column_start":8,"column_end":21},"name":"genhermv_sort","qualname":"::eigen::genhermv_sort","value":"fn (eval: &mut VectorF64, evec: &mut MatrixComplexF64, sort_type: ::EigenSort) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function simultaneously sorts the eigenvalues stored in the vector eval and the corresponding complex eigenvectors stored in the\n columns of the matrix evec into ascending or descending order according to the value of the parameter sort_type.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5693},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/eigen.rs","byte_start":1454670,"byte_end":1454679,"line_start":71,"line_end":71,"column_start":8,"column_end":17},"name":"genv_sort","qualname":"::eigen::genv_sort","value":"fn (alpha: &mut VectorComplexF64, beta: &mut VectorF64, evec: &mut MatrixComplexF64, sort_type: ::EigenSort) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function simultaneously sorts the eigenvalues stored in the vectors (alpha, beta) and the corresponding complex eigenvectors stored\n in the columns of the matrix evec into ascending or descending order according to the value of the parameter sort_type. Only\n EigenSort::AbsAsc and EigenSort::AbsDesc are supported due to the eigenvalues being complex.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5694},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elementary.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"elementary","qualname":"::elementary","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elementary.rs","parent":null,"children":[{"krate":0,"index":5695},{"krate":0,"index":5696},{"krate":0,"index":5706}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Trait","id":{"krate":0,"index":5696},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elementary.rs","byte_start":1455136,"byte_end":1455146,"line_start":7,"line_end":7,"column_start":11,"column_end":21},"name":"Elementary","qualname":"::elementary::Elementary","value":"Elementary","parent":null,"children":[{"krate":0,"index":5697},{"krate":0,"index":5698},{"krate":0,"index":5699},{"krate":0,"index":5700},{"krate":0,"index":5701},{"krate":0,"index":5702},{"krate":0,"index":5703},{"krate":0,"index":5704},{"krate":0,"index":5705}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5697},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elementary.rs","byte_start":1455314,"byte_end":1455319,"line_start":9,"line_end":9,"column_start":8,"column_end":13},"name":"log1p","qualname":"::elementary::Elementary::log1p","value":"fn (&self) -> Self","parent":{"krate":0,"index":5696},"children":[],"decl_id":null,"docs":" This function computes the value of __log(1+x)__ in a way that is accurate for small x. It provides an alternative to the BSD math function log1p(x).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5698},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elementary.rs","byte_start":1455501,"byte_end":1455506,"line_start":11,"line_end":11,"column_start":8,"column_end":13},"name":"expm1","qualname":"::elementary::Elementary::expm1","value":"fn (&self) -> Self","parent":{"krate":0,"index":5696},"children":[],"decl_id":null,"docs":" This function computes the value of __exp(x)-1__ in a way that is accurate for small x. It provides an alternative to the BSD math function expm1(x).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5699},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elementary.rs","byte_start":1455689,"byte_end":1455694,"line_start":13,"line_end":13,"column_start":8,"column_end":13},"name":"hypot","qualname":"::elementary::Elementary::hypot","value":"fn (&self, y: f64) -> Self","parent":{"krate":0,"index":5696},"children":[],"decl_id":null,"docs":" This function computes the value of __sqrt{x^2 + y^2}__ in a way that avoids overflow. It provides an alternative to the BSD math function hypot(x,y).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5700},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elementary.rs","byte_start":1455827,"byte_end":1455833,"line_start":15,"line_end":15,"column_start":8,"column_end":14},"name":"hypot3","qualname":"::elementary::Elementary::hypot3","value":"fn (&self, y: f64, z: f64) -> Self","parent":{"krate":0,"index":5696},"children":[],"decl_id":null,"docs":" This function computes the value of __sqrt{x^2 + y^2 + z^2}__ in a way that avoids overflow.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5701},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elementary.rs","byte_start":1456000,"byte_end":1456005,"line_start":17,"line_end":17,"column_start":8,"column_end":13},"name":"acosh","qualname":"::elementary::Elementary::acosh","value":"fn (&self) -> Self","parent":{"krate":0,"index":5696},"children":[],"decl_id":null,"docs":" This function computes the value of __arccosh(x)__. It provides an alternative to the standard math function acosh(x).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5702},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elementary.rs","byte_start":1456156,"byte_end":1456161,"line_start":19,"line_end":19,"column_start":8,"column_end":13},"name":"asinh","qualname":"::elementary::Elementary::asinh","value":"fn (&self) -> Self","parent":{"krate":0,"index":5696},"children":[],"decl_id":null,"docs":" This function computes the value of __arcsinh(x)__. It provides an alternative to the standard math function asinh(x).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5703},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elementary.rs","byte_start":1456312,"byte_end":1456317,"line_start":21,"line_end":21,"column_start":8,"column_end":13},"name":"atanh","qualname":"::elementary::Elementary::atanh","value":"fn (&self) -> Self","parent":{"krate":0,"index":5696},"children":[],"decl_id":null,"docs":" This function computes the value of __arctanh(x)__. It provides an alternative to the standard math function atanh(x).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5704},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elementary.rs","byte_start":1456467,"byte_end":1456472,"line_start":23,"line_end":23,"column_start":8,"column_end":13},"name":"ldexp","qualname":"::elementary::Elementary::ldexp","value":"fn (&self, e: i32) -> Self","parent":{"krate":0,"index":5696},"children":[],"decl_id":null,"docs":" This function computes the value of __x * 2^e__. It provides an alternative to the standard math function ldexp(x,e).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":5705},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elementary.rs","byte_start":1456819,"byte_end":1456824,"line_start":26,"line_end":26,"column_start":8,"column_end":13},"name":"frexp","qualname":"::elementary::Elementary::frexp","value":"fn (&self, e: &mut i32) -> Self","parent":{"krate":0,"index":5696},"children":[],"decl_id":null,"docs":" This function splits the number x into its normalized fraction f and exponent e, such that x = f * 2^e and 0.5 <= f < 1. The function returns f and stores the exponent in e.\n If x is zero, both f and e are set to zero. This function provides an alternative to the standard math function frexp(x, e).\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5716},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elementary_operations.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"elementary_operations","qualname":"::elementary_operations","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elementary_operations.rs","parent":null,"children":[{"krate":0,"index":5717},{"krate":0,"index":5718},{"krate":0,"index":5719},{"krate":0,"index":5720}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5719},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elementary_operations.rs","byte_start":1457866,"byte_end":1457876,"line_start":9,"line_end":9,"column_start":8,"column_end":18},"name":"multiply_e","qualname":"::elementary_operations::multiply_e","value":"fn (x: f64, y: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This function multiplies x and y storing the product and its associated error in result.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5720},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elementary_operations.rs","byte_start":1458311,"byte_end":1458325,"line_start":18,"line_end":18,"column_start":8,"column_end":22},"name":"multiply_err_e","qualname":"::elementary_operations::multiply_err_e","value":"fn (x: f64, dx: f64, y: f64, dy: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This function multiplies x and y with associated absolute errors dx and dy.\n The product xy +/- xy \\sqrt((dx/x)^2 +(dy/y)^2) is stored in result.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5721},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"elliptic","qualname":"::elliptic","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","parent":null,"children":[{"krate":0,"index":5722},{"krate":0,"index":5745}],"decl_id":null,"docs":" Further information about the elliptic integrals can be found in Abramowitz & Stegun, Chapter 17.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5722},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","byte_start":1459478,"byte_end":1459486,"line_start":18,"line_end":18,"column_start":9,"column_end":17},"name":"legendre","qualname":"::elliptic::legendre","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","parent":null,"children":[{"krate":0,"index":5723},{"krate":0,"index":5733}],"decl_id":null,"docs":" The Legendre forms of elliptic integrals F(\\phi,k), E(\\phi,k) and \\Pi(\\phi,k,n) are defined by,","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5723},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","byte_start":1459501,"byte_end":1459509,"line_start":19,"line_end":19,"column_start":13,"column_end":21},"name":"complete","qualname":"::elliptic::legendre::complete","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","parent":null,"children":[{"krate":0,"index":5724},{"krate":0,"index":5725},{"krate":0,"index":5726},{"krate":0,"index":5727},{"krate":0,"index":5728},{"krate":0,"index":5729},{"krate":0,"index":5730},{"krate":0,"index":5731},{"krate":0,"index":5732}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5727},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","byte_start":1459815,"byte_end":1459827,"line_start":26,"line_end":26,"column_start":16,"column_end":28},"name":"ellint_Kcomp","qualname":"::elliptic::legendre::complete::ellint_Kcomp","value":"fn (k: f64, mode: ::Mode) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the complete elliptic integral K(k) to the accuracy specified by the mode variable mode.\n Note that Abramowitz & Stegun define this function in terms of the parameter m = k^2.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5728},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","byte_start":1460163,"byte_end":1460177,"line_start":32,"line_end":32,"column_start":16,"column_end":30},"name":"ellint_Kcomp_e","qualname":"::elliptic::legendre::complete::ellint_Kcomp_e","value":"fn (k: f64, mode: ::Mode) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the complete elliptic integral K(k) to the accuracy specified by the mode variable mode.\n Note that Abramowitz & Stegun define this function in terms of the parameter m = k^2.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5729},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","byte_start":1460733,"byte_end":1460745,"line_start":41,"line_end":41,"column_start":16,"column_end":28},"name":"ellint_Ecomp","qualname":"::elliptic::legendre::complete::ellint_Ecomp","value":"fn (k: f64, mode: ::Mode) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the complete elliptic integral E(k) to the accuracy specified by the mode variable mode.\n Note that Abramowitz & Stegun define this function in terms of the parameter m = k^2.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5730},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","byte_start":1461081,"byte_end":1461095,"line_start":47,"line_end":47,"column_start":16,"column_end":30},"name":"ellint_Ecomp_e","qualname":"::elliptic::legendre::complete::ellint_Ecomp_e","value":"fn (k: f64, mode: ::Mode) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the complete elliptic integral E(k) to the accuracy specified by the mode variable mode.\n Note that Abramowitz & Stegun define this function in terms of the parameter m = k^2.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5731},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","byte_start":1461715,"byte_end":1461727,"line_start":56,"line_end":56,"column_start":16,"column_end":28},"name":"ellint_Pcomp","qualname":"::elliptic::legendre::complete::ellint_Pcomp","value":"fn (k: f64, n: f64, mode: ::Mode) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the complete elliptic integral \\Pi(k,n) to the accuracy specified by the mode variable mode.\n Note that Abramowitz & Stegun define this function in terms of the parameters m = k^2 and \\sin^2(\\alpha) = k^2, with the change of sign n \\to -n.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5732},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","byte_start":1462138,"byte_end":1462152,"line_start":62,"line_end":62,"column_start":16,"column_end":30},"name":"ellint_Pcomp_e","qualname":"::elliptic::legendre::complete::ellint_Pcomp_e","value":"fn (k: f64, n: f64, mode: ::Mode) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the complete elliptic integral \\Pi(k,n) to the accuracy specified by the mode variable mode.\n Note that Abramowitz & Stegun define this function in terms of the parameters m = k^2 and \\sin^2(\\alpha) = k^2, with the change of sign n \\to -n.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5733},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","byte_start":1462501,"byte_end":1462511,"line_start":70,"line_end":70,"column_start":13,"column_end":23},"name":"incomplete","qualname":"::elliptic::legendre::incomplete","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","parent":null,"children":[{"krate":0,"index":5734},{"krate":0,"index":5735},{"krate":0,"index":5736},{"krate":0,"index":5737},{"krate":0,"index":5738},{"krate":0,"index":5739},{"krate":0,"index":5740},{"krate":0,"index":5741},{"krate":0,"index":5742},{"krate":0,"index":5743},{"krate":0,"index":5744}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5737},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","byte_start":1462824,"byte_end":1462832,"line_start":77,"line_end":77,"column_start":16,"column_end":24},"name":"ellint_F","qualname":"::elliptic::legendre::incomplete::ellint_F","value":"fn (phi: f64, k: f64, mode: ::Mode) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the incomplete elliptic integral F(\\phi,k) to the accuracy specified by the mode variable mode.\n Note that Abramowitz & Stegun define this function in terms of the parameter m = k^2.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5738},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","byte_start":1463186,"byte_end":1463196,"line_start":83,"line_end":83,"column_start":16,"column_end":26},"name":"ellint_F_e","qualname":"::elliptic::legendre::incomplete::ellint_F_e","value":"fn (phi: f64, k: f64, mode: ::Mode) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the incomplete elliptic integral F(\\phi,k) to the accuracy specified by the mode variable mode.\n Note that Abramowitz & Stegun define this function in terms of the parameter m = k^2.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5739},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","byte_start":1463770,"byte_end":1463778,"line_start":92,"line_end":92,"column_start":16,"column_end":24},"name":"ellint_E","qualname":"::elliptic::legendre::incomplete::ellint_E","value":"fn (phi: f64, k: f64, mode: ::Mode) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the incomplete elliptic integral E(\\phi,k) to the accuracy specified by the mode variable mode.\n Note that Abramowitz & Stegun define this function in terms of the parameter m = k^2.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5740},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","byte_start":1464132,"byte_end":1464142,"line_start":98,"line_end":98,"column_start":16,"column_end":26},"name":"ellint_E_e","qualname":"::elliptic::legendre::incomplete::ellint_E_e","value":"fn (phi: f64, k: f64, mode: ::Mode) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the incomplete elliptic integral E(\\phi,k) to the accuracy specified by the mode variable mode.\n Note that Abramowitz & Stegun define this function in terms of the parameter m = k^2.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5741},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","byte_start":1464780,"byte_end":1464788,"line_start":107,"line_end":107,"column_start":16,"column_end":24},"name":"ellint_P","qualname":"::elliptic::legendre::incomplete::ellint_P","value":"fn (phi: f64, k: f64, n: f64, mode: ::Mode) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the incomplete elliptic integral \\Pi(\\phi,k,n) to the accuracy specified by the mode variable mode.\n Note that Abramowitz & Stegun define this function in terms of the parameters m = k^2 and \\sin^2(\\alpha) = k^2, with the change of sign n \\to -n.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5742},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","byte_start":1465217,"byte_end":1465227,"line_start":113,"line_end":113,"column_start":16,"column_end":26},"name":"ellint_P_e","qualname":"::elliptic::legendre::incomplete::ellint_P_e","value":"fn (phi: f64, k: f64, n: f64, mode: ::Mode) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the incomplete elliptic integral \\Pi(\\phi,k,n) to the accuracy specified by the mode variable mode.\n Note that Abramowitz & Stegun define this function in terms of the parameters m = k^2 and \\sin^2(\\alpha) = k^2, with the change of sign n \\to -n.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5743},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","byte_start":1465882,"byte_end":1465890,"line_start":124,"line_end":124,"column_start":16,"column_end":24},"name":"ellint_D","qualname":"::elliptic::legendre::incomplete::ellint_D","value":"fn (phi: f64, k: f64, mode: ::Mode) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the incomplete elliptic integral D(\\phi,k) which is defined through the Carlson form RD(x,y,z) by the following relation,\n \n D(\\phi,k,n) = (1/3)(\\sin(\\phi))^3 RD (1-\\sin^2(\\phi), 1-k^2 \\sin^2(\\phi), 1).\n","sig":null,"attributes":[{"value":"cfg(feature = \"v2\")","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","byte_start":1465844,"byte_end":1465866,"line_start":123,"line_end":123,"column_start":9,"column_end":31}}]},{"kind":"Function","id":{"krate":0,"index":5744},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","byte_start":1466901,"byte_end":1466911,"line_start":143,"line_end":143,"column_start":16,"column_end":26},"name":"ellint_D_e","qualname":"::elliptic::legendre::incomplete::ellint_D_e","value":"fn (phi: f64, k: f64, n: f64, mode: ::Mode) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the incomplete elliptic integral D(\\phi,k) which is defined through the Carlson form RD(x,y,z) by the following relation,\n \n D(\\phi,k,n) = (1/3)(\\sin(\\phi))^3 RD (1-\\sin^2(\\phi), 1-k^2 \\sin^2(\\phi), 1).\n \n The argument n is not used and will be removed in a future release.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5745},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","byte_start":1467727,"byte_end":1467734,"line_start":162,"line_end":162,"column_start":9,"column_end":16},"name":"carlson","qualname":"::elliptic::carlson","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","parent":null,"children":[{"krate":0,"index":5746},{"krate":0,"index":5747},{"krate":0,"index":5748},{"krate":0,"index":5749},{"krate":0,"index":5750},{"krate":0,"index":5751},{"krate":0,"index":5752},{"krate":0,"index":5753},{"krate":0,"index":5754},{"krate":0,"index":5755},{"krate":0,"index":5756}],"decl_id":null,"docs":" The Carlson symmetric forms of elliptical integrals RC(x,y), RD(x,y,z), RF(x,y,z) and RJ(x,y,z,p) are defined by,\n \n RC(x,y) = 1/2 \\int_0^\\infty dt (t+x)^(-1/2) (t+y)^(-1)\n \n RD(x,y,z) = 3/2 \\int_0^\\infty dt (t+x)^(-1/2) (t+y)^(-1/2) (t+z)^(-3/2)\n \n RF(x,y,z) = 1/2 \\int_0^\\infty dt (t+x)^(-1/2) (t+y)^(-1/2) (t+z)^(-1/2)\n \n RJ(x,y,z,p) = 3/2 \\int_0^\\infty dt \n                (t+x)^(-1/2) (t+y)^(-1/2) (t+z)^(-1/2) (t+p)^(-1)\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5749},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","byte_start":1467927,"byte_end":1467936,"line_start":168,"line_end":168,"column_start":12,"column_end":21},"name":"ellint_RC","qualname":"::elliptic::carlson::ellint_RC","value":"fn (x: f64, y: f64, mode: ::Mode) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the incomplete elliptic integral RC(x,y) to the accuracy specified by the mode variable mode.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5750},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","byte_start":1468171,"byte_end":1468182,"line_start":173,"line_end":173,"column_start":12,"column_end":23},"name":"ellint_RC_e","qualname":"::elliptic::carlson::ellint_RC_e","value":"fn (x: f64, y: f64, mode: ::Mode) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the incomplete elliptic integral RC(x,y) to the accuracy specified by the mode variable mode.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5751},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","byte_start":1468631,"byte_end":1468640,"line_start":181,"line_end":181,"column_start":12,"column_end":21},"name":"ellint_RD","qualname":"::elliptic::carlson::ellint_RD","value":"fn (x: f64, y: f64, z: f64, mode: ::Mode) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the incomplete elliptic integral RD(x,y,z) to the accuracy specified by the mode variable mode.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5752},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","byte_start":1468888,"byte_end":1468899,"line_start":186,"line_end":186,"column_start":12,"column_end":23},"name":"ellint_RD_e","qualname":"::elliptic::carlson::ellint_RD_e","value":"fn (x: f64, y: f64, z: f64, mode: ::Mode) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the incomplete elliptic integral RD(x,y,z) to the accuracy specified by the mode variable mode.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5753},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","byte_start":1469359,"byte_end":1469368,"line_start":194,"line_end":194,"column_start":12,"column_end":21},"name":"ellint_RF","qualname":"::elliptic::carlson::ellint_RF","value":"fn (x: f64, y: f64, z: f64, mode: ::Mode) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the incomplete elliptic integral RF(x,y,z) to the accuracy specified by the mode variable mode.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5754},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","byte_start":1469616,"byte_end":1469627,"line_start":199,"line_end":199,"column_start":12,"column_end":23},"name":"ellint_RF_e","qualname":"::elliptic::carlson::ellint_RF_e","value":"fn (x: f64, y: f64, z: f64, mode: ::Mode) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the incomplete elliptic integral RF(x,y,z) to the accuracy specified by the mode variable mode.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5755},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","byte_start":1470089,"byte_end":1470098,"line_start":207,"line_end":207,"column_start":12,"column_end":21},"name":"ellint_RJ","qualname":"::elliptic::carlson::ellint_RJ","value":"fn (x: f64, y: f64, z: f64, p: f64, mode: ::Mode) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the incomplete elliptic integral RJ(x,y,z,p) to the accuracy specified by the mode variable mode.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5756},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/elliptic.rs","byte_start":1470359,"byte_end":1470370,"line_start":212,"line_end":212,"column_start":12,"column_end":23},"name":"ellint_RJ_e","qualname":"::elliptic::carlson::ellint_RJ_e","value":"fn (x: f64, y: f64, z: f64, p: f64, mode: ::Mode) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the incomplete elliptic integral RJ(x,y,z,p) to the accuracy specified by the mode variable mode.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5757},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/error.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"error","qualname":"::error","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/error.rs","parent":null,"children":[{"krate":0,"index":5758},{"krate":0,"index":5759},{"krate":0,"index":5760},{"krate":0,"index":5761},{"krate":0,"index":5762},{"krate":0,"index":5763},{"krate":0,"index":5764},{"krate":0,"index":5765},{"krate":0,"index":5766},{"krate":0,"index":5767},{"krate":0,"index":5768},{"krate":0,"index":5769},{"krate":0,"index":5770},{"krate":0,"index":5771},{"krate":0,"index":5772},{"krate":0,"index":5773},{"krate":0,"index":5774},{"krate":0,"index":5775},{"krate":0,"index":5776},{"krate":0,"index":5777},{"krate":0,"index":5778},{"krate":0,"index":5779}],"decl_id":null,"docs":" The error function is described in Abramowitz & Stegun, Chapter 7.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5763},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/error.rs","byte_start":1471057,"byte_end":1471060,"line_start":14,"line_end":14,"column_start":8,"column_end":11},"name":"erf","qualname":"::error::erf","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the error function erf(x), where erf(x) = (2/\\sqrt(\\pi)) \\int_0^x dt \\exp(-t^2).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5764},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/error.rs","byte_start":1471231,"byte_end":1471236,"line_start":19,"line_end":19,"column_start":8,"column_end":13},"name":"erf_e","qualname":"::error::erf_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the error function erf(x), where erf(x) = (2/\\sqrt(\\pi)) \\int_0^x dt \\exp(-t^2).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5765},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/error.rs","byte_start":1471621,"byte_end":1471625,"line_start":27,"line_end":27,"column_start":8,"column_end":12},"name":"erfc","qualname":"::error::erfc","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the complementary error function erfc(x) = 1 - erf(x) = (2/\\sqrt(\\pi)) \\int_x^\\infty \\exp(-t^2).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5766},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/error.rs","byte_start":1471813,"byte_end":1471819,"line_start":32,"line_end":32,"column_start":8,"column_end":14},"name":"erfc_e","qualname":"::error::erfc_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the complementary error function erfc(x) = 1 - erf(x) = (2/\\sqrt(\\pi)) \\int_x^\\infty \\exp(-t^2).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5767},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/error.rs","byte_start":1472174,"byte_end":1472182,"line_start":40,"line_end":40,"column_start":8,"column_end":16},"name":"log_erfc","qualname":"::error::log_erfc","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the logarithm of the complementary error function \\log(\\erfc(x)).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5768},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/error.rs","byte_start":1472343,"byte_end":1472353,"line_start":45,"line_end":45,"column_start":8,"column_end":18},"name":"log_erfc_e","qualname":"::error::log_erfc_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the logarithm of the complementary error function \\log(\\erfc(x)).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5769},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/error.rs","byte_start":1472725,"byte_end":1472730,"line_start":53,"line_end":53,"column_start":8,"column_end":13},"name":"erf_Z","qualname":"::error::erf_Z","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Gaussian probability density function Z(x) = (1/\\sqrt{2\\pi}) \\exp(-x^2/2).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5770},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/error.rs","byte_start":1472901,"byte_end":1472908,"line_start":58,"line_end":58,"column_start":8,"column_end":15},"name":"erf_Z_e","qualname":"::error::erf_Z_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Gaussian probability density function Z(x) = (1/\\sqrt{2\\pi}) \\exp(-x^2/2).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5771},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/error.rs","byte_start":1473603,"byte_end":1473608,"line_start":72,"line_end":72,"column_start":8,"column_end":13},"name":"erf_Q","qualname":"::error::erf_Q","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the upper tail of the Gaussian probability function Q(x) = (1/\\sqrt{2\\pi}) \\int_x^\\infty dt \\exp(-t^2/2).\n \n The hazard function for the normal distribution, also known as the inverse Mills’ ratio, is defined as,\n \n h(x) = Z(x)/Q(x) = \\sqrt{2/\\pi} \\exp(-x^2 / 2) / \\erfc(x/\\sqrt 2)\n \n It decreases rapidly as x approaches -\\infty and asymptotes to h(x) \\sim x as x approaches +\\infty.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5772},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/error.rs","byte_start":1474105,"byte_end":1474112,"line_start":83,"line_end":83,"column_start":8,"column_end":15},"name":"erf_Q_e","qualname":"::error::erf_Q_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the upper tail of the Gaussian probability function Q(x) = (1/\\sqrt{2\\pi}) \\int_x^\\infty dt \\exp(-t^2/2).\n \n The hazard function for the normal distribution, also known as the inverse Mills’ ratio, is defined as,\n \n h(x) = Z(x)/Q(x) = \\sqrt{2/\\pi} \\exp(-x^2 / 2) / \\erfc(x/\\sqrt 2)\n \n It decreases rapidly as x approaches -\\infty and asymptotes to h(x) \\sim x as x approaches +\\infty.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5773},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/error.rs","byte_start":1474451,"byte_end":1474457,"line_start":91,"line_end":91,"column_start":8,"column_end":14},"name":"hazard","qualname":"::error::hazard","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the hazard function for the normal distribution.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5774},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/error.rs","byte_start":1474599,"byte_end":1474607,"line_start":96,"line_end":96,"column_start":8,"column_end":16},"name":"hazard_e","qualname":"::error::hazard_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the hazard function for the normal distribution.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5775},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/error.rs","byte_start":1474872,"byte_end":1474881,"line_start":103,"line_end":103,"column_start":8,"column_end":17},"name":"str_error","qualname":"::error::str_error","value":"fn (error: ::Value) -> &'static str","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5777},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/error.rs","byte_start":1479002,"byte_end":1479019,"line_start":184,"line_end":184,"column_start":8,"column_end":25},"name":"set_error_handler","qualname":"::error::set_error_handler","value":"fn (f: Option<fn(&str, &str, u32, ::Value)>) -> Option<fn(&str, &str, u32, ::Value)>","parent":null,"children":[],"decl_id":null,"docs":" `f` is the type of GSL error handler functions. An error handler will be passed four arguments\n which specify the reason for the error (a string), the name of the source file in which it\n occurred (also a string), the line number in that file (an integer) and the error number (an\n integer). The source file and line number are set at compile time using the __FILE__ and\n __LINE__ directives in the preprocessor. An error handler function returns type void. Error\n handler functions should be defined like this,","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5778},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/error.rs","byte_start":1479823,"byte_end":1479844,"line_start":207,"line_end":207,"column_start":8,"column_end":29},"name":"set_error_handler_off","qualname":"::error::set_error_handler_off","value":"fn () -> Option<fn(&str, &str, u32, ::Value)>","parent":null,"children":[],"decl_id":null,"docs":" This function turns off the error handler by defining an error handler which does nothing. This\n will cause the program to continue after any error, so the return values from any library\n routines must be checked. This is the recommended behavior for production programs. The previous\n handler is returned (so that you can restore it later).\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5782},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"exponential","qualname":"::exponential","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential.rs","parent":null,"children":[{"krate":0,"index":5783},{"krate":0,"index":5784},{"krate":0,"index":5785},{"krate":0,"index":5786},{"krate":0,"index":5787},{"krate":0,"index":5788},{"krate":0,"index":5789},{"krate":0,"index":5790},{"krate":0,"index":5791},{"krate":0,"index":5792},{"krate":0,"index":5793},{"krate":0,"index":5794},{"krate":0,"index":5795},{"krate":0,"index":5796},{"krate":0,"index":5797},{"krate":0,"index":5798},{"krate":0,"index":5799},{"krate":0,"index":5800},{"krate":0,"index":5801},{"krate":0,"index":5802},{"krate":0,"index":5803}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5786},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential.rs","byte_start":1480953,"byte_end":1480956,"line_start":10,"line_end":10,"column_start":8,"column_end":11},"name":"exp","qualname":"::exponential::exp","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine provides an exponential function \\exp(x) using GSL semantics and error checking.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5787},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential.rs","byte_start":1481116,"byte_end":1481121,"line_start":15,"line_end":15,"column_start":8,"column_end":13},"name":"exp_e","qualname":"::exponential::exp_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine provides an exponential function \\exp(x) using GSL semantics and error checking.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5788},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential.rs","byte_start":1481607,"byte_end":1481616,"line_start":24,"line_end":24,"column_start":8,"column_end":17},"name":"exp_e10_e","qualname":"::exponential::exp_e10_e","value":"fn (x: f64) -> (enums::Value, ::types::ResultE10)","parent":null,"children":[],"decl_id":null,"docs":" This function computes the exponential \\exp(x) using the gsl_sf_result_e10 type to return a result with extended range.\n This function may be useful if the value of \\exp(x) would overflow the numeric range of double.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5789},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential.rs","byte_start":1482004,"byte_end":1482012,"line_start":32,"line_end":32,"column_start":8,"column_end":16},"name":"exp_mult","qualname":"::exponential::exp_mult","value":"fn (x: f64, y: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine exponentiates x and multiply by the factor y to return the product y \\exp(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5790},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential.rs","byte_start":1482185,"byte_end":1482195,"line_start":37,"line_end":37,"column_start":8,"column_end":18},"name":"exp_mult_e","qualname":"::exponential::exp_mult_e","value":"fn (x: f64, y: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine exponentiates x and multiply by the factor y to return the product y \\exp(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5791},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential.rs","byte_start":1482697,"byte_end":1482711,"line_start":46,"line_end":46,"column_start":8,"column_end":22},"name":"exp_mult_e10_e","qualname":"::exponential::exp_mult_e10_e","value":"fn (x: f64, y: f64) -> (enums::Value, ::types::ResultE10)","parent":null,"children":[],"decl_id":null,"docs":" This function computes the exponential \\exp(x) using the gsl_sf_result_e10 type to return a result with extended range.\n This function may be useful if the value of \\exp(x) would overflow the numeric range of double.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5792},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential.rs","byte_start":1483118,"byte_end":1483123,"line_start":54,"line_end":54,"column_start":8,"column_end":13},"name":"expm1","qualname":"::exponential::expm1","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the quantity \\exp(x)-1 using an algorithm that is accurate for small x.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5793},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential.rs","byte_start":1483285,"byte_end":1483292,"line_start":59,"line_end":59,"column_start":8,"column_end":15},"name":"expm1_e","qualname":"::exponential::expm1_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the quantity \\exp(x)-1 using an algorithm that is accurate for small x.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5794},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential.rs","byte_start":1483773,"byte_end":1483779,"line_start":68,"line_end":68,"column_start":8,"column_end":14},"name":"exprel","qualname":"::exponential::exprel","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the quantity (\\exp(x)-1)/x using an algorithm that is accurate for small x.\n For small x the algorithm is based on the expansion (\\exp(x)-1)/x = 1 + x/2 + x^2/(2*3) + x^3/(2*3*4) + \\dots.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5795},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential.rs","byte_start":1484061,"byte_end":1484069,"line_start":74,"line_end":74,"column_start":8,"column_end":16},"name":"exprel_e","qualname":"::exponential::exprel_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the quantity (\\exp(x)-1)/x using an algorithm that is accurate for small x.\n For small x the algorithm is based on the expansion (\\exp(x)-1)/x = 1 + x/2 + x^2/(2*3) + x^3/(2*3*4) + \\dots.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5796},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential.rs","byte_start":1484561,"byte_end":1484569,"line_start":83,"line_end":83,"column_start":8,"column_end":16},"name":"exprel_2","qualname":"::exponential::exprel_2","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the quantity 2(\\exp(x)-1-x)/x^2 using an algorithm that is accurate for small x.\n For small x the algorithm is based on the expansion 2(\\exp(x)-1-x)/x^2 = 1 + x/3 + x^2/(3*4) + x^3/(3*4*5) + \\dots.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5797},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential.rs","byte_start":1484863,"byte_end":1484873,"line_start":89,"line_end":89,"column_start":8,"column_end":18},"name":"exprel_2_e","qualname":"::exponential::exprel_2_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the quantity 2(\\exp(x)-1-x)/x^2 using an algorithm that is accurate for small x.\n For small x the algorithm is based on the expansion 2(\\exp(x)-1-x)/x^2 = 1 + x/3 + x^2/(3*4) + x^3/(3*4*5) + \\dots.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5798},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential.rs","byte_start":1485504,"byte_end":1485512,"line_start":106,"line_end":106,"column_start":8,"column_end":16},"name":"exprel_n","qualname":"::exponential::exprel_n","value":"fn (n: i32, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the N-relative exponential, which is the n-th generalization of the functions gsl_sf_exprel and gsl_sf_exprel_2.\n The N-relative exponential is given by:","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5799},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential.rs","byte_start":1485954,"byte_end":1485964,"line_start":120,"line_end":120,"column_start":8,"column_end":18},"name":"exprel_n_e","qualname":"::exponential::exprel_n_e","value":"fn (n: i32, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the N-relative exponential, which is the n-th generalization of the functions gsl_sf_exprel and gsl_sf_exprel_2.\n The N-relative exponential is given by:","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5800},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential.rs","byte_start":1486314,"byte_end":1486323,"line_start":128,"line_end":128,"column_start":8,"column_end":17},"name":"exp_err_e","qualname":"::exponential::exp_err_e","value":"fn (x: f64, dx: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This function exponentiates x with an associated absolute error dx.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5801},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential.rs","byte_start":1486758,"byte_end":1486771,"line_start":136,"line_end":136,"column_start":8,"column_end":21},"name":"exp_err_e10_e","qualname":"::exponential::exp_err_e10_e","value":"fn (x: f64, dx: f64) -> (enums::Value, ::types::ResultE10)","parent":null,"children":[],"decl_id":null,"docs":" This function exponentiates a quantity x with an associated absolute error dx using the ::types::ResultE10 type to return a result with extended range.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5802},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential.rs","byte_start":1487193,"byte_end":1487207,"line_start":144,"line_end":144,"column_start":8,"column_end":22},"name":"exp_mult_err_e","qualname":"::exponential::exp_mult_err_e","value":"fn (x: f64, dx: f64, y: f64, dy: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the product y \\exp(x) for the quantities x, y with associated absolute errors dx, dy.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5803},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential.rs","byte_start":1487699,"byte_end":1487717,"line_start":152,"line_end":152,"column_start":8,"column_end":26},"name":"exp_mult_err_e10_e","qualname":"::exponential::exp_mult_err_e10_e","value":"fn (x: f64, dx: f64, y: f64, dy: f64) -> (enums::Value, ::types::ResultE10)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the product y \\exp(x) for the quantities x, y with associated absolute errors dx, dy using the gsl_sf_result_e10 type to return a result with extended range.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5804},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential_integrals.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"exponential_integrals","qualname":"::exponential_integrals","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential_integrals.rs","parent":null,"children":[{"krate":0,"index":5805},{"krate":0,"index":5806},{"krate":0,"index":5807},{"krate":0,"index":5808},{"krate":0,"index":5809},{"krate":0,"index":5810},{"krate":0,"index":5811},{"krate":0,"index":5812},{"krate":0,"index":5813},{"krate":0,"index":5814},{"krate":0,"index":5815},{"krate":0,"index":5816},{"krate":0,"index":5817},{"krate":0,"index":5818},{"krate":0,"index":5819},{"krate":0,"index":5820},{"krate":0,"index":5821},{"krate":0,"index":5822},{"krate":0,"index":5823},{"krate":0,"index":5824},{"krate":0,"index":5825},{"krate":0,"index":5826},{"krate":0,"index":5827}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5808},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential_integrals.rs","byte_start":1488304,"byte_end":1488306,"line_start":12,"line_end":12,"column_start":8,"column_end":10},"name":"E1","qualname":"::exponential_integrals::E1","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the exponential integral E_1(x),\n \n E_1(x) := \\Re \\int_1^\\infty dt \\exp(-xt)/t.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5809},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential_integrals.rs","byte_start":1488486,"byte_end":1488490,"line_start":19,"line_end":19,"column_start":8,"column_end":12},"name":"E1_e","qualname":"::exponential_integrals::E1_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the exponential integral E_1(x),\n \n E_1(x) := \\Re \\int_1^\\infty dt \\exp(-xt)/t.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5810},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential_integrals.rs","byte_start":1488885,"byte_end":1488887,"line_start":29,"line_end":29,"column_start":8,"column_end":10},"name":"E2","qualname":"::exponential_integrals::E2","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the second-order exponential integral E_2(x),\n \n E_2(x) := \\Re \\int_1^\\infty dt \\exp(-xt)/t^2.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5811},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential_integrals.rs","byte_start":1489082,"byte_end":1489086,"line_start":36,"line_end":36,"column_start":8,"column_end":12},"name":"E2_e","qualname":"::exponential_integrals::E2_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the second-order exponential integral E_2(x),\n \n E_2(x) := \\Re \\int_1^\\infty dt \\exp(-xt)/t^2.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5812},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential_integrals.rs","byte_start":1489479,"byte_end":1489481,"line_start":46,"line_end":46,"column_start":8,"column_end":10},"name":"En","qualname":"::exponential_integrals::En","value":"fn (n: i32, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the exponential integral E_n(x) of order n,\n \n E_n(x) := \\Re \\int_1^\\infty dt \\exp(-xt)/t^n.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5813},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential_integrals.rs","byte_start":1489685,"byte_end":1489689,"line_start":53,"line_end":53,"column_start":8,"column_end":12},"name":"En_e","qualname":"::exponential_integrals::En_e","value":"fn (n: i32, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the exponential integral E_n(x) of order n,\n \n E_n(x) := \\Re \\int_1^\\infty dt \\exp(-xt)/t^n.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5814},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential_integrals.rs","byte_start":1490144,"byte_end":1490146,"line_start":65,"line_end":65,"column_start":8,"column_end":10},"name":"Ei","qualname":"::exponential_integrals::Ei","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the exponential integral Ei(x),\n \n Ei(x) := - PV(\\int_{-x}^\\infty dt \\exp(-t)/t)\n \n where PV denotes the principal value of the integral.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5815},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential_integrals.rs","byte_start":1490390,"byte_end":1490394,"line_start":74,"line_end":74,"column_start":8,"column_end":12},"name":"Ei_e","qualname":"::exponential_integrals::Ei_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the exponential integral Ei(x),\n \n Ei(x) := - PV(\\int_{-x}^\\infty dt \\exp(-t)/t)\n \n where PV denotes the principal value of the integral.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5816},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential_integrals.rs","byte_start":1490734,"byte_end":1490737,"line_start":82,"line_end":82,"column_start":8,"column_end":11},"name":"Shi","qualname":"::exponential_integrals::Shi","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the integral Shi(x) = \\int_0^x dt \\sinh(t)/t.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5817},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential_integrals.rs","byte_start":1490871,"byte_end":1490876,"line_start":87,"line_end":87,"column_start":8,"column_end":13},"name":"Shi_e","qualname":"::exponential_integrals::Shi_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the integral Shi(x) = \\int_0^x dt \\sinh(t)/t.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5818},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential_integrals.rs","byte_start":1491314,"byte_end":1491317,"line_start":95,"line_end":95,"column_start":8,"column_end":11},"name":"Chi","qualname":"::exponential_integrals::Chi","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the integral Chi(x) := \\Re[ \\gamma_E + \\log(x) + \\int_0^x dt (\\cosh(t)-1)/t] , where \\gamma_E is the Euler constant (available as the macro M_EULER).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5819},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential_integrals.rs","byte_start":1491555,"byte_end":1491560,"line_start":100,"line_end":100,"column_start":8,"column_end":13},"name":"Chi_e","qualname":"::exponential_integrals::Chi_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the integral Chi(x) := \\Re[ \\gamma_E + \\log(x) + \\int_0^x dt (\\cosh(t)-1)/t] , where \\gamma_E is the Euler constant (available as the macro M_EULER).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5820},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential_integrals.rs","byte_start":1491929,"byte_end":1491931,"line_start":108,"line_end":108,"column_start":8,"column_end":10},"name":"_3","qualname":"::exponential_integrals::_3","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the third-order exponential integral Ei_3(x) = \\int_0^xdt \\exp(-t^3) for x >= 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5821},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential_integrals.rs","byte_start":1492105,"byte_end":1492109,"line_start":113,"line_end":113,"column_start":8,"column_end":12},"name":"_3_e","qualname":"::exponential_integrals::_3_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the third-order exponential integral Ei_3(x) = \\int_0^xdt \\exp(-t^3) for x >= 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5822},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential_integrals.rs","byte_start":1492451,"byte_end":1492453,"line_start":121,"line_end":121,"column_start":8,"column_end":10},"name":"Si","qualname":"::exponential_integrals::Si","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Sine integral Si(x) = \\int_0^x dt \\sin(t)/t.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5823},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential_integrals.rs","byte_start":1492589,"byte_end":1492593,"line_start":126,"line_end":126,"column_start":8,"column_end":12},"name":"Si_e","qualname":"::exponential_integrals::Si_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Sine integral Si(x) = \\int_0^x dt \\sin(t)/t.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5824},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential_integrals.rs","byte_start":1492947,"byte_end":1492949,"line_start":134,"line_end":134,"column_start":8,"column_end":10},"name":"Ci","qualname":"::exponential_integrals::Ci","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Cosine integral Ci(x) = -\\int_x^\\infty dt \\cos(t)/t for x > 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5825},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential_integrals.rs","byte_start":1493103,"byte_end":1493107,"line_start":139,"line_end":139,"column_start":8,"column_end":12},"name":"Ci_e","qualname":"::exponential_integrals::Ci_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Cosine integral Ci(x) = -\\int_x^\\infty dt \\cos(t)/t for x > 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5826},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential_integrals.rs","byte_start":1493478,"byte_end":1493485,"line_start":147,"line_end":147,"column_start":8,"column_end":15},"name":"atanint","qualname":"::exponential_integrals::atanint","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Arctangent integral, which is defined as AtanInt(x) = \\int_0^x dt \\arctan(t)/t.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5827},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/exponential_integrals.rs","byte_start":1493661,"byte_end":1493670,"line_start":152,"line_end":152,"column_start":8,"column_end":17},"name":"atanint_e","qualname":"::exponential_integrals::atanint_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Arctangent integral, which is defined as AtanInt(x) = \\int_0^x dt \\arctan(t)/t.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5828},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fermi_dirac.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"fermi_dirac","qualname":"::fermi_dirac","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fermi_dirac.rs","parent":null,"children":[{"krate":0,"index":5829},{"krate":0,"index":5849}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5829},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fermi_dirac.rs","byte_start":1494279,"byte_end":1494297,"line_start":10,"line_end":10,"column_start":9,"column_end":27},"name":"complete_integrals","qualname":"::fermi_dirac::complete_integrals","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fermi_dirac.rs","parent":null,"children":[{"krate":0,"index":5830},{"krate":0,"index":5831},{"krate":0,"index":5832},{"krate":0,"index":5833},{"krate":0,"index":5834},{"krate":0,"index":5835},{"krate":0,"index":5836},{"krate":0,"index":5837},{"krate":0,"index":5838},{"krate":0,"index":5839},{"krate":0,"index":5840},{"krate":0,"index":5841},{"krate":0,"index":5842},{"krate":0,"index":5843},{"krate":0,"index":5844},{"krate":0,"index":5845},{"krate":0,"index":5846},{"krate":0,"index":5847},{"krate":0,"index":5848}],"decl_id":null,"docs":" The complete Fermi-Dirac integral F_j(x) is given by,\n \n F_j(x)   := (1/\\Gamma(j+1)) \\int_0^\\infty dt (t^j / (\\exp(t-x) + 1))\n \n Note that the Fermi-Dirac integral is sometimes defined without the normalisation factor in other texts.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5833},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fermi_dirac.rs","byte_start":1494514,"byte_end":1494528,"line_start":17,"line_end":17,"column_start":12,"column_end":26},"name":"fermi_dirac_m1","qualname":"::fermi_dirac::complete_integrals::fermi_dirac_m1","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the complete Fermi-Dirac integral with an index of -1.\n This integral is given by F_{-1}(x) = e^x / (1 + e^x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5834},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fermi_dirac.rs","byte_start":1494761,"byte_end":1494777,"line_start":23,"line_end":23,"column_start":12,"column_end":28},"name":"fermi_dirac_m1_e","qualname":"::fermi_dirac::complete_integrals::fermi_dirac_m1_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the complete Fermi-Dirac integral with an index of -1.\n This integral is given by F_{-1}(x) = e^x / (1 + e^x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5835},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fermi_dirac.rs","byte_start":1495215,"byte_end":1495228,"line_start":32,"line_end":32,"column_start":12,"column_end":25},"name":"fermi_dirac_0","qualname":"::fermi_dirac::complete_integrals::fermi_dirac_0","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the complete Fermi-Dirac integral with an index of 0.\n This integral is given by F_0(x) = \\ln(1 + e^x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5836},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fermi_dirac.rs","byte_start":1495453,"byte_end":1495468,"line_start":38,"line_end":38,"column_start":12,"column_end":27},"name":"fermi_dirac_0_e","qualname":"::fermi_dirac::complete_integrals::fermi_dirac_0_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the complete Fermi-Dirac integral with an index of 0.\n This integral is given by F_0(x) = \\ln(1 + e^x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5837},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fermi_dirac.rs","byte_start":1495894,"byte_end":1495907,"line_start":46,"line_end":46,"column_start":12,"column_end":25},"name":"fermi_dirac_1","qualname":"::fermi_dirac::complete_integrals::fermi_dirac_1","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the complete Fermi-Dirac integral with an index of 1, F_1(x) = \\int_0^\\infty dt (t /(\\exp(t-x)+1)).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5838},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fermi_dirac.rs","byte_start":1496121,"byte_end":1496136,"line_start":51,"line_end":51,"column_start":12,"column_end":27},"name":"fermi_dirac_1_e","qualname":"::fermi_dirac::complete_integrals::fermi_dirac_1_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the complete Fermi-Dirac integral with an index of 1, F_1(x) = \\int_0^\\infty dt (t /(\\exp(t-x)+1)).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5839},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fermi_dirac.rs","byte_start":1496570,"byte_end":1496583,"line_start":59,"line_end":59,"column_start":12,"column_end":25},"name":"fermi_dirac_2","qualname":"::fermi_dirac::complete_integrals::fermi_dirac_2","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the complete Fermi-Dirac integral with an index of 2, F_2(x) = (1/2) \\int_0^\\infty dt (t^2 /(\\exp(t-x)+1)).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5840},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fermi_dirac.rs","byte_start":1496805,"byte_end":1496820,"line_start":64,"line_end":64,"column_start":12,"column_end":27},"name":"fermi_dirac_2_e","qualname":"::fermi_dirac::complete_integrals::fermi_dirac_2_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the complete Fermi-Dirac integral with an index of 2, F_2(x) = (1/2) \\int_0^\\infty dt (t^2 /(\\exp(t-x)+1)).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5841},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fermi_dirac.rs","byte_start":1497272,"byte_end":1497287,"line_start":72,"line_end":72,"column_start":12,"column_end":27},"name":"fermi_dirac_int","qualname":"::fermi_dirac::complete_integrals::fermi_dirac_int","value":"fn (j: i32, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the complete Fermi-Dirac integral with an integer index of j, F_j(x) = (1/\\Gamma(j+1)) \\int_0^\\infty dt (t^j /(\\exp(t-x)+1)).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5842},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fermi_dirac.rs","byte_start":1497540,"byte_end":1497557,"line_start":77,"line_end":77,"column_start":12,"column_end":29},"name":"fermi_dirac_int_e","qualname":"::fermi_dirac::complete_integrals::fermi_dirac_int_e","value":"fn (j: i32, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the complete Fermi-Dirac integral with an integer index of j, F_j(x) = (1/\\Gamma(j+1)) \\int_0^\\infty dt (t^j /(\\exp(t-x)+1)).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5843},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fermi_dirac.rs","byte_start":1497943,"byte_end":1497960,"line_start":85,"line_end":85,"column_start":12,"column_end":29},"name":"fermi_dirac_mhalf","qualname":"::fermi_dirac::complete_integrals::fermi_dirac_mhalf","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the complete Fermi-Dirac integral F_{-1/2}(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5844},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fermi_dirac.rs","byte_start":1498125,"byte_end":1498144,"line_start":90,"line_end":90,"column_start":12,"column_end":31},"name":"fermi_dirac_mhalf_e","qualname":"::fermi_dirac::complete_integrals::fermi_dirac_mhalf_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the complete Fermi-Dirac integral F_{-1/2}(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5845},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fermi_dirac.rs","byte_start":1498520,"byte_end":1498536,"line_start":98,"line_end":98,"column_start":12,"column_end":28},"name":"fermi_dirac_half","qualname":"::fermi_dirac::complete_integrals::fermi_dirac_half","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the complete Fermi-Dirac integral F_{1/2}(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5846},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fermi_dirac.rs","byte_start":1498699,"byte_end":1498717,"line_start":103,"line_end":103,"column_start":12,"column_end":30},"name":"fermi_dirac_half_e","qualname":"::fermi_dirac::complete_integrals::fermi_dirac_half_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the complete Fermi-Dirac integral F_{1/2}(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5847},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fermi_dirac.rs","byte_start":1499092,"byte_end":1499109,"line_start":111,"line_end":111,"column_start":12,"column_end":29},"name":"fermi_dirac_3half","qualname":"::fermi_dirac::complete_integrals::fermi_dirac_3half","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the complete Fermi-Dirac integral F_{3/2}(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5848},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fermi_dirac.rs","byte_start":1499273,"byte_end":1499292,"line_start":116,"line_end":116,"column_start":12,"column_end":31},"name":"fermi_dirac_3half_e","qualname":"::fermi_dirac::complete_integrals::fermi_dirac_3half_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the complete Fermi-Dirac integral F_{3/2}(x).\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5849},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fermi_dirac.rs","byte_start":1499733,"byte_end":1499753,"line_start":127,"line_end":127,"column_start":9,"column_end":29},"name":"incomplete_integrals","qualname":"::fermi_dirac::incomplete_integrals","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fermi_dirac.rs","parent":null,"children":[{"krate":0,"index":5850},{"krate":0,"index":5851},{"krate":0,"index":5852},{"krate":0,"index":5853},{"krate":0,"index":5854}],"decl_id":null,"docs":" The incomplete Fermi-Dirac integral F_j(x,b) is given by,\n \n F_j(x,b)   := (1/\\Gamma(j+1)) \\int_b^\\infty dt (t^j / (\\Exp(t-x) + 1))\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5853},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fermi_dirac.rs","byte_start":1499948,"byte_end":1499965,"line_start":133,"line_end":133,"column_start":12,"column_end":29},"name":"fermi_dirac_inc_0","qualname":"::fermi_dirac::incomplete_integrals::fermi_dirac_inc_0","value":"fn (x: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the incomplete Fermi-Dirac integral with an index of zero, F_0(x,b) = \\ln(1 + e^{b-x}) - (b-x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5854},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fermi_dirac.rs","byte_start":1500190,"byte_end":1500209,"line_start":138,"line_end":138,"column_start":12,"column_end":31},"name":"fermi_dirac_inc_0_e","qualname":"::fermi_dirac::incomplete_integrals::fermi_dirac_inc_0_e","value":"fn (x: f64, b: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the incomplete Fermi-Dirac integral with an index of zero, F_0(x,b) = \\ln(1 + e^{b-x}) - (b-x).\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5855},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fft.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"fft","qualname":"::fft","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fft.rs","parent":null,"children":[{"krate":0,"index":5856},{"krate":0,"index":5867},{"krate":0,"index":5877}],"decl_id":null,"docs":"#Fast Fourier Transforms (FFTs)","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5856},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fft.rs","byte_start":1511327,"byte_end":1511333,"line_start":167,"line_end":167,"column_start":9,"column_end":15},"name":"radix2","qualname":"::fft::radix2","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fft.rs","parent":null,"children":[{"krate":0,"index":5857},{"krate":0,"index":5858},{"krate":0,"index":5859},{"krate":0,"index":5860},{"krate":0,"index":5861},{"krate":0,"index":5862},{"krate":0,"index":5863},{"krate":0,"index":5864},{"krate":0,"index":5865},{"krate":0,"index":5866}],"decl_id":null,"docs":" These functions compute forward, backward and inverse FFTs of length n with stride stride, on the packed complex array data using an in-place radix-2\n decimation-in-time algorithm. The length of the transform is restricted to powers of two. For the transform version of the function\n the sign argument can be either forward (-1) or backward (+1).","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5859},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fft.rs","byte_start":1511376,"byte_end":1511383,"line_start":171,"line_end":171,"column_start":12,"column_end":19},"name":"forward","qualname":"::fft::radix2::forward","value":"fn (data: &mut [f64], stride: usize, n: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5860},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fft.rs","byte_start":1511567,"byte_end":1511576,"line_start":175,"line_end":175,"column_start":12,"column_end":21},"name":"transform","qualname":"::fft::radix2::transform","value":"fn (data: &mut [f64], stride: usize, n: usize, sign: ::FftDirection) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5861},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fft.rs","byte_start":1511797,"byte_end":1511805,"line_start":179,"line_end":179,"column_start":12,"column_end":20},"name":"backward","qualname":"::fft::radix2::backward","value":"fn (data: &mut [f64], stride: usize, n: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5862},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fft.rs","byte_start":1511990,"byte_end":1511997,"line_start":183,"line_end":183,"column_start":12,"column_end":19},"name":"inverse","qualname":"::fft::radix2::inverse","value":"fn (data: &mut [f64], stride: usize, n: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5863},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fft.rs","byte_start":1512258,"byte_end":1512269,"line_start":188,"line_end":188,"column_start":12,"column_end":23},"name":"dif_forward","qualname":"::fft::radix2::dif_forward","value":"fn (data: &mut [f64], stride: usize, n: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This is decimation-in-frequency version of the radix-2 FFT function.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5864},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fft.rs","byte_start":1512534,"byte_end":1512547,"line_start":193,"line_end":193,"column_start":12,"column_end":25},"name":"dif_transform","qualname":"::fft::radix2::dif_transform","value":"fn (data: &mut [f64], stride: usize, n: usize, sign: ::FftDirection) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This is decimation-in-frequency version of the radix-2 FFT function.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5865},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fft.rs","byte_start":1512849,"byte_end":1512861,"line_start":198,"line_end":198,"column_start":12,"column_end":24},"name":"dif_backward","qualname":"::fft::radix2::dif_backward","value":"fn (data: &mut [f64], stride: usize, n: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This is decimation-in-frequency version of the radix-2 FFT function.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5866},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fft.rs","byte_start":1513127,"byte_end":1513138,"line_start":203,"line_end":203,"column_start":12,"column_end":23},"name":"dif_inverse","qualname":"::fft::radix2::dif_inverse","value":"fn (data: &mut [f64], stride: usize, n: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This is decimation-in-frequency version of the radix-2 FFT function.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5867},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fft.rs","byte_start":1514280,"byte_end":1514291,"line_start":223,"line_end":223,"column_start":9,"column_end":20},"name":"mixed_radix","qualname":"::fft::mixed_radix","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fft.rs","parent":null,"children":[{"krate":0,"index":5868},{"krate":0,"index":5869},{"krate":0,"index":5870},{"krate":0,"index":5873},{"krate":0,"index":5874},{"krate":0,"index":5875},{"krate":0,"index":5876}],"decl_id":null,"docs":" These functions compute forward, backward and inverse FFTs of length n with stride stride, on the packed complex array data, using a\n mixed radix decimation-in-frequency algorithm. There is no restriction on the length n. Efficient modules are provided for subtransforms\n of length 2, 3, 4, 5, 6 and 7. Any remaining factors are computed with a slow, O(n^2), general-n module. The caller must supply a\n wavetable containing the trigonometric lookup tables and a workspace work. For the transform version of the function the sign argument\n can be either forward (-1) or backward (+1).","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5873},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fft.rs","byte_start":1514393,"byte_end":1514400,"line_start":228,"line_end":228,"column_start":12,"column_end":19},"name":"forward","qualname":"::fft::mixed_radix::forward","value":"fn (data: &mut [f64], stride: usize, n: usize, wavetable: &FftComplexWaveTable, work: &mut FftComplexWorkspace) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5874},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fft.rs","byte_start":1514722,"byte_end":1514731,"line_start":233,"line_end":233,"column_start":12,"column_end":21},"name":"transform","qualname":"::fft::mixed_radix::transform","value":"fn (data: &mut [f64], stride: usize, n: usize, wavetable: &FftComplexWaveTable, work: &mut FftComplexWorkspace, sign: ::FftDirection) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5875},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fft.rs","byte_start":1515090,"byte_end":1515098,"line_start":238,"line_end":238,"column_start":12,"column_end":20},"name":"backward","qualname":"::fft::mixed_radix::backward","value":"fn (data: &mut [f64], stride: usize, n: usize, wavetable: &FftComplexWaveTable, work: &mut FftComplexWorkspace) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5876},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fft.rs","byte_start":1515421,"byte_end":1515428,"line_start":243,"line_end":243,"column_start":12,"column_end":19},"name":"inverse","qualname":"::fft::mixed_radix::inverse","value":"fn (data: &mut [f64], stride: usize, n: usize, wavetable: &FftComplexWaveTable, work: &mut FftComplexWorkspace) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5877},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fft.rs","byte_start":1515915,"byte_end":1515926,"line_start":251,"line_end":251,"column_start":9,"column_end":20},"name":"real_radix2","qualname":"::fft::real_radix2","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fft.rs","parent":null,"children":[{"krate":0,"index":5878},{"krate":0,"index":5879},{"krate":0,"index":5880},{"krate":0,"index":5881},{"krate":0,"index":5882},{"krate":0,"index":5883}],"decl_id":null,"docs":" This section describes radix-2 FFT algorithms for real data. They use the Cooley-Tukey algorithm to compute in-place FFTs for lengths which\n are a power of 2.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5880},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fft.rs","byte_start":1517742,"byte_end":1517751,"line_start":282,"line_end":282,"column_start":12,"column_end":21},"name":"transform","qualname":"::fft::real_radix2::transform","value":"fn (data: &mut [f64], stride: usize, n: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes an in-place radix-2 FFT of length n and stride stride on the real array data. The output is a half-complex sequence,\n which is stored in-place. The arrangement of the half-complex terms uses the following scheme: for k < n/2 the real part of the k-th term\n is stored in location k, and the corresponding imaginary part is stored in location n-k. Terms with k > n/2 can be reconstructed using the\n symmetry z_k = z^*_{n-k}. The terms for k=0 and k=n/2 are both purely real, and count as a special case. Their real parts are stored in\n locations 0 and n/2 respectively, while their imaginary parts which are zero are not stored.","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5881},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fft.rs","byte_start":1518200,"byte_end":1518207,"line_start":288,"line_end":288,"column_start":12,"column_end":19},"name":"inverse","qualname":"::fft::real_radix2::inverse","value":"fn (data: &mut [f64], stride: usize, n: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the inverse or backwards in-place radix-2 FFT of length n and stride stride on the half-complex sequence data\n stored according the output scheme used by gsl_fft_real_radix2. The result is a real array stored in natural order.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5882},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fft.rs","byte_start":1518661,"byte_end":1518669,"line_start":294,"line_end":294,"column_start":12,"column_end":20},"name":"backward","qualname":"::fft::real_radix2::backward","value":"fn (data: &mut [f64], stride: usize, n: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the inverse or backwards in-place radix-2 FFT of length n and stride stride on the half-complex sequence data\n stored according the output scheme used by gsl_fft_real_radix2. The result is a real array stored in natural order.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5883},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fft.rs","byte_start":1520072,"byte_end":1520078,"line_start":328,"line_end":328,"column_start":12,"column_end":18},"name":"unpack","qualname":"::fft::real_radix2::unpack","value":"fn (halfcomplex_coefficient: &mut [f64], complex_coefficient: &mut [f64], stride: usize, n: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function converts halfcomplex_coefficient, an array of half-complex coefficients as returned by gsl_fft_real_radix2_transform,\n into an ordinary complex array, complex_coefficient. It fills in the complex array using the symmetry z_k = z_{n-k}^* to reconstruct\n the redundant elements. The algorithm for the conversion is,","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5884},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fit.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"fit","qualname":"::fit","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fit.rs","parent":null,"children":[{"krate":0,"index":5885},{"krate":0,"index":5886},{"krate":0,"index":5887},{"krate":0,"index":5888},{"krate":0,"index":5889},{"krate":0,"index":5890},{"krate":0,"index":5891}],"decl_id":null,"docs":"Linear Regression","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5886},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fit.rs","byte_start":1521368,"byte_end":1521374,"line_start":16,"line_end":16,"column_start":8,"column_end":14},"name":"linear","qualname":"::fit::linear","value":"fn (x: &[f64], xstride: usize, y: &[f64], ystride: usize, n: usize, c0: &mut f64, c1: &mut f64, cov00: &mut f64, cov01: &mut f64, cov11: &mut f64, sumsq: f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the best-fit linear regression coefficients (c0,c1) of the model Y = c_0 + c_1 X for the dataset (x, y), two vectors of length n with strides xstride and ystride.\n The errors on y are assumed unknown so the variance-covariance matrix for the parameters (c0, c1) is estimated from the scatter of the points around the best-fit line and returned via the parameters (cov00, cov01, cov11).\n The sum of squares of the residuals from the best-fit line is returned in sumsq. Note: the correlation coefficient of the data can be computed using gsl_stats_correlation (see [`Correlation`](http://www.gnu.org/software/gsl/manual/html_node/Correlation.html#Correlation)), it does not depend on the fit.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5887},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fit.rs","byte_start":1522310,"byte_end":1522317,"line_start":27,"line_end":27,"column_start":8,"column_end":15},"name":"wlinear","qualname":"::fit::wlinear","value":"fn (x: &[f64], xstride: usize, w: &[f64], wstride: usize, y: &[f64], ystride: usize, n: usize, c0: &mut f64, c1: &mut f64, cov00: &mut f64, cov01: &mut f64, cov11: &mut f64, chisq: &mut f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the best-fit linear regression coefficients (c0,c1) of the model Y = c_0 + c_1 X for the weighted dataset (x, y), two vectors of length n with strides xstride and ystride.\n The vector w, of length n and stride wstride, specifies the weight of each datapoint.\n The weight is the reciprocal of the variance for each datapoint in y.\n \n The covariance matrix for the parameters (c0, c1) is computed using the weights and returned via the parameters (cov00, cov01, cov11).\n The weighted sum of squares of the residuals from the best-fit line, \\chi^2, is returned in chisq.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5888},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fit.rs","byte_start":1522932,"byte_end":1522942,"line_start":34,"line_end":34,"column_start":8,"column_end":18},"name":"linear_est","qualname":"::fit::linear_est","value":"fn (x: f64, c0: f64, c1: f64, cov00: f64, cov01: f64, cov11: f64, y: &mut f64, y_err: &mut f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function uses the best-fit linear regression coefficients c0, c1 and their covariance cov00, cov01, cov11 to compute the fitted function y and its standard deviation y_err for the model Y = c_0 + c_1 X at the point x.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5889},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fit.rs","byte_start":1523613,"byte_end":1523616,"line_start":41,"line_end":41,"column_start":8,"column_end":11},"name":"mul","qualname":"::fit::mul","value":"fn (x: &[f64], xstride: usize, y: &[f64], ystride: usize, n: usize, c1: &mut f64, cov11: &mut f64, sumsq: &mut f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the best-fit linear regression coefficient c1 of the model Y = c_1 X for the datasets (x, y), two vectors of length n with strides xstride and ystride.\n The errors on y are assumed unknown so the variance of the parameter c1 is estimated from the scatter of the points around the best-fit line and returned via the parameter cov11.\n The sum of squares of the residuals from the best-fit line is returned in sumsq.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5890},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fit.rs","byte_start":1524439,"byte_end":1524443,"line_start":51,"line_end":51,"column_start":8,"column_end":12},"name":"wmul","qualname":"::fit::wmul","value":"fn (x: &[f64], xstride: usize, w: &[f64], wstride: usize, y: &[f64], ystride: usize, n: usize, c1: &mut f64, cov11: &mut f64, sumsq: &mut f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the best-fit linear regression coefficient c1 of the model Y = c_1 X for the weighted datasets (x, y), two vectors of length n with strides xstride and ystride.\n The vector w, of length n and stride wstride, specifies the weight of each datapoint.\n The weight is the reciprocal of the variance for each datapoint in y.\n \n The variance of the parameter c1 is computed using the weights and returned via the parameter cov11.\n The weighted sum of squares of the residuals from the best-fit line, \\chi^2, is returned in chisq.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5891},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/fit.rs","byte_start":1524954,"byte_end":1524961,"line_start":57,"line_end":57,"column_start":8,"column_end":15},"name":"mul_est","qualname":"::fit::mul_est","value":"fn (x: f64, c1: f64, cov11: f64, y: &mut f64, y_err: &mut f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function uses the best-fit linear regression coefficient c1 and its covariance cov11 to compute the fitted function y and its standard deviation y_err for the model Y = c_1 X at the point x.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5892},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"gamma_beta","qualname":"::gamma_beta","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","parent":null,"children":[{"krate":0,"index":5893},{"krate":0,"index":5907},{"krate":0,"index":5925},{"krate":0,"index":5936},{"krate":0,"index":5944},{"krate":0,"index":5954}],"decl_id":null,"docs":" This following routines compute the gamma and beta functions in their full and incomplete forms, as well as various kinds of factorials.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5893},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1525669,"byte_end":1525674,"line_start":13,"line_end":13,"column_start":9,"column_end":14},"name":"gamma","qualname":"::gamma_beta::gamma","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","parent":null,"children":[{"krate":0,"index":5894},{"krate":0,"index":5895},{"krate":0,"index":5896},{"krate":0,"index":5897},{"krate":0,"index":5898},{"krate":0,"index":5899},{"krate":0,"index":5900},{"krate":0,"index":5901},{"krate":0,"index":5902},{"krate":0,"index":5903},{"krate":0,"index":5904},{"krate":0,"index":5905},{"krate":0,"index":5906}],"decl_id":null,"docs":" The Gamma function is defined by the following integral,","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5897},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1526046,"byte_end":1526051,"line_start":20,"line_end":20,"column_start":12,"column_end":17},"name":"gamma","qualname":"::gamma_beta::gamma::gamma","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" These routines compute the Gamma function \\Gamma(x), subject to x not being a negative integer or zero. The function is computed using the real Lanczos method.\n The maximum value of x such that \\Gamma(x) is not considered an overflow is given by the macro GSL_SF_GAMMA_XMAX and is 171.0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5898},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1526229,"byte_end":1526236,"line_start":25,"line_end":25,"column_start":12,"column_end":19},"name":"gamma_e","qualname":"::gamma_beta::gamma::gamma_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine provides an exponential function \\exp(x) using GSL semantics and error checking.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5899},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1526822,"byte_end":1526829,"line_start":34,"line_end":34,"column_start":12,"column_end":19},"name":"lngamma","qualname":"::gamma_beta::gamma::lngamma","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Gamma function \\Gamma(x), subject to x not being a negative integer or zero.\n The function is computed using the real Lanczos method. The maximum value of x such that \\Gamma(x) is not considered an overflow is given by the macro GSL_SF_GAMMA_XMAX and is 171.0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5900},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1527209,"byte_end":1527218,"line_start":40,"line_end":40,"column_start":12,"column_end":21},"name":"lngamma_e","qualname":"::gamma_beta::gamma::lngamma_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Gamma function \\Gamma(x), subject to x not being a negative integer or zero.\n The function is computed using the real Lanczos method. The maximum value of x such that \\Gamma(x) is not considered an overflow is given by the macro GSL_SF_GAMMA_XMAX and is 171.0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5901},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1527899,"byte_end":1527912,"line_start":50,"line_end":50,"column_start":12,"column_end":25},"name":"lngamma_sgn_e","qualname":"::gamma_beta::gamma::lngamma_sgn_e","value":"fn (x: f64, sgn: &mut f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the sign of the gamma function and the logarithm of its magnitude, subject to x not being a negative integer or zero.\n The function is computed using the real Lanczos method.\n The value of the gamma function and its error can be reconstructed using the relation \\Gamma(x) = sgn * \\exp(result\\_lg), taking into account the two components of result_lg.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5902},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1528569,"byte_end":1528578,"line_start":66,"line_end":66,"column_start":12,"column_end":21},"name":"gammastar","qualname":"::gamma_beta::gamma::gammastar","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the regulated Gamma Function \\Gamma^*(x) for x > 0. The regulated gamma function is given by,","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5903},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1529005,"byte_end":1529016,"line_start":79,"line_end":79,"column_start":12,"column_end":23},"name":"gammastar_e","qualname":"::gamma_beta::gamma::gammastar_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the regulated Gamma Function \\Gamma^*(x) for x > 0. The regulated gamma function is given by,","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5904},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1529415,"byte_end":1529423,"line_start":87,"line_end":87,"column_start":12,"column_end":20},"name":"gammainv","qualname":"::gamma_beta::gamma::gammainv","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the reciprocal of the gamma function, 1/\\Gamma(x) using the real Lanczos method.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5905},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1529613,"byte_end":1529623,"line_start":92,"line_end":92,"column_start":12,"column_end":22},"name":"gammainv_e","qualname":"::gamma_beta::gamma::gammainv_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the reciprocal of the gamma function, 1/\\Gamma(x) using the real Lanczos method.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5906},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1530426,"byte_end":1530443,"line_start":102,"line_end":102,"column_start":12,"column_end":29},"name":"lngamma_complex_e","qualname":"::gamma_beta::gamma::lngamma_complex_e","value":"fn (zr: f64, zi: f64) -> (enums::Value, ::types::Result, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes \\log(\\Gamma(z)) for complex z=z_r+i z_i and z not a negative integer or zero, using the complex Lanczos method.\n The returned parameters are lnr = \\log|\\Gamma(z)| and arg = \\arg(\\Gamma(z)) in (-\\pi,\\pi]. Note that the phase part (arg) is not well-determined when |z| is very large, due to inevitable roundoff in restricting to (-\\pi,\\pi].\n This will result in a GSL_ELOSS error when it occurs. The absolute value part (lnr), however, never suffers from loss of precision.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5907},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1531172,"byte_end":1531182,"line_start":113,"line_end":113,"column_start":9,"column_end":19},"name":"factorials","qualname":"::gamma_beta::factorials","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","parent":null,"children":[{"krate":0,"index":5908},{"krate":0,"index":5909},{"krate":0,"index":5910},{"krate":0,"index":5911},{"krate":0,"index":5912},{"krate":0,"index":5913},{"krate":0,"index":5914},{"krate":0,"index":5915},{"krate":0,"index":5916},{"krate":0,"index":5917},{"krate":0,"index":5918},{"krate":0,"index":5919},{"krate":0,"index":5920},{"krate":0,"index":5921},{"krate":0,"index":5922},{"krate":0,"index":5923},{"krate":0,"index":5924}],"decl_id":null,"docs":" Although factorials can be computed from the Gamma function, using the relation n! = \\Gamma(n+1) for non-negative integer n, it is usually more\n efficient to call the functions in this section, particularly for small values of n, whose factorial values are maintained in hardcoded tables.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5911},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1531488,"byte_end":1531492,"line_start":120,"line_end":120,"column_start":12,"column_end":16},"name":"fact","qualname":"::gamma_beta::factorials::fact","value":"fn (n: u32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the factorial n!. The factorial is related to the Gamma function by n! = \\Gamma(n+1).\n The maximum value of n such that n! is not considered an overflow is given by the macro SF_FACT_NMAX and is 170.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5912},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1531804,"byte_end":1531810,"line_start":126,"line_end":126,"column_start":12,"column_end":18},"name":"fact_e","qualname":"::gamma_beta::factorials::fact_e","value":"fn (n: u32) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the factorial n!. The factorial is related to the Gamma function by n! = \\Gamma(n+1).\n The maximum value of n such that n! is not considered an overflow is given by the macro SF_FACT_NMAX and is 170.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5913},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1532297,"byte_end":1532307,"line_start":135,"line_end":135,"column_start":12,"column_end":22},"name":"doublefact","qualname":"::gamma_beta::factorials::doublefact","value":"fn (n: u32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the double factorial n!! = n(n-2)(n-4) \\dots.\n The maximum value of n such that n!! is not considered an overflow is given by the macro SF_DOUBLEFACT_NMAX and is 297.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5914},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1532592,"byte_end":1532604,"line_start":141,"line_end":141,"column_start":12,"column_end":24},"name":"doublefact_e","qualname":"::gamma_beta::factorials::doublefact_e","value":"fn (n: u32) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the double factorial n!! = n(n-2)(n-4) \\dots.\n The maximum value of n such that n!! is not considered an overflow is given by the macro SF_DOUBLEFACT_NMAX and is 297.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5915},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1533091,"byte_end":1533097,"line_start":150,"line_end":150,"column_start":12,"column_end":18},"name":"lnfact","qualname":"::gamma_beta::factorials::lnfact","value":"fn (n: u32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the logarithm of the factorial of n, \\log(n!).\n The algorithm is faster than computing \\ln(\\Gamma(n+1)) via gsl_sf_lngamma for n < 170, but defers for larger n.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5916},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1533372,"byte_end":1533380,"line_start":156,"line_end":156,"column_start":12,"column_end":20},"name":"lnfact_e","qualname":"::gamma_beta::factorials::lnfact_e","value":"fn (n: u32) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the logarithm of the factorial of n, \\log(n!).\n The algorithm is faster than computing \\ln(\\Gamma(n+1)) via gsl_sf_lngamma for n < 170, but defers for larger n.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5917},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1533750,"byte_end":1533762,"line_start":164,"line_end":164,"column_start":12,"column_end":24},"name":"lndoublefact","qualname":"::gamma_beta::factorials::lndoublefact","value":"fn (n: u32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the logarithm of the double factorial of n, \\log(n!!).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5918},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1533930,"byte_end":1533944,"line_start":169,"line_end":169,"column_start":12,"column_end":26},"name":"lndoublefact_e","qualname":"::gamma_beta::factorials::lndoublefact_e","value":"fn (n: u32) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the logarithm of the double factorial of n, \\log(n!!).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5919},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1534317,"byte_end":1534323,"line_start":177,"line_end":177,"column_start":12,"column_end":18},"name":"choose","qualname":"::gamma_beta::factorials::choose","value":"fn (n: u32, m: u32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the combinatorial factor n choose m = n!/(m!(n-m)!)\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5920},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1534493,"byte_end":1534501,"line_start":182,"line_end":182,"column_start":12,"column_end":20},"name":"choose_e","qualname":"::gamma_beta::factorials::choose_e","value":"fn (n: u32, m: u32) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the combinatorial factor n choose m = n!/(m!(n-m)!)\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5921},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1534922,"byte_end":1534930,"line_start":190,"line_end":190,"column_start":12,"column_end":20},"name":"lnchoose","qualname":"::gamma_beta::factorials::lnchoose","value":"fn (n: u32, m: u32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the logarithm of n choose m. This is equivalent to the sum \\log(n!) - \\log(m!) - \\log((n-m)!).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5922},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1535145,"byte_end":1535155,"line_start":195,"line_end":195,"column_start":12,"column_end":22},"name":"lnchoose_e","qualname":"::gamma_beta::factorials::lnchoose_e","value":"fn (n: u32, m: u32) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the logarithm of n choose m. This is equivalent to the sum \\log(n!) - \\log(m!) - \\log((n-m)!).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5923},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1535535,"byte_end":1535546,"line_start":203,"line_end":203,"column_start":12,"column_end":23},"name":"taylorcoeff","qualname":"::gamma_beta::factorials::taylorcoeff","value":"fn (n: i32, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Taylor coefficient x^n / n! for x >= 0, n >= 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5924},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1535721,"byte_end":1535734,"line_start":208,"line_end":208,"column_start":12,"column_end":25},"name":"taylorcoeff_e","qualname":"::gamma_beta::factorials::taylorcoeff_e","value":"fn (n: i32, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Taylor coefficient x^n / n! for x >= 0, n >= 0.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5925},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1536034,"byte_end":1536051,"line_start":216,"line_end":216,"column_start":9,"column_end":26},"name":"pochhammer_symbol","qualname":"::gamma_beta::pochhammer_symbol","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","parent":null,"children":[{"krate":0,"index":5926},{"krate":0,"index":5927},{"krate":0,"index":5928},{"krate":0,"index":5929},{"krate":0,"index":5930},{"krate":0,"index":5931},{"krate":0,"index":5932},{"krate":0,"index":5933},{"krate":0,"index":5934},{"krate":0,"index":5935}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5929},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1536400,"byte_end":1536404,"line_start":224,"line_end":224,"column_start":12,"column_end":16},"name":"poch","qualname":"::gamma_beta::pochhammer_symbol::poch","value":"fn (a: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Pochhammer symbol (a)_x = \\Gamma(a + x)/\\Gamma(a).\n The Pochhammer symbol is also known as the Apell symbol and sometimes written as (a,x).\n When a and a+x are negative integers or zero, the limiting value of the ratio is returned.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5930},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1536770,"byte_end":1536776,"line_start":231,"line_end":231,"column_start":12,"column_end":18},"name":"poch_e","qualname":"::gamma_beta::pochhammer_symbol::poch_e","value":"fn (a: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Pochhammer symbol (a)_x = \\Gamma(a + x)/\\Gamma(a).\n The Pochhammer symbol is also known as the Apell symbol and sometimes written as (a,x).\n When a and a+x are negative integers or zero, the limiting value of the ratio is returned.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5931},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1537185,"byte_end":1537191,"line_start":239,"line_end":239,"column_start":12,"column_end":18},"name":"lnpoch","qualname":"::gamma_beta::pochhammer_symbol::lnpoch","value":"fn (a: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the logarithm of the Pochhammer symbol, \\log((a)_x) = \\log(\\Gamma(a + x)/\\Gamma(a)).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5932},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1537394,"byte_end":1537402,"line_start":244,"line_end":244,"column_start":12,"column_end":20},"name":"lnpoch_e","qualname":"::gamma_beta::pochhammer_symbol::lnpoch_e","value":"fn (a: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the logarithm of the Pochhammer symbol, \\log((a)_x) = \\log(\\Gamma(a + x)/\\Gamma(a)).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5933},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1537952,"byte_end":1537964,"line_start":253,"line_end":253,"column_start":12,"column_end":24},"name":"lnpoch_sgn_e","qualname":"::gamma_beta::pochhammer_symbol::lnpoch_sgn_e","value":"fn (a: f64, x: f64, sgn: &mut f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" These routines compute the sign of the Pochhammer symbol and the logarithm of its magnitude.\n The computed parameters are result = \\log(|(a)_x|) with a corresponding error term, and sgn = \\sgn((a)_x) where (a)_x = \\Gamma(a + x)/\\Gamma(a).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5934},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1538398,"byte_end":1538405,"line_start":261,"line_end":261,"column_start":12,"column_end":19},"name":"pochrel","qualname":"::gamma_beta::pochhammer_symbol::pochrel","value":"fn (a: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the relative Pochhammer symbol ((a)_x - 1)/x where (a)_x = \\Gamma(a + x)/\\Gamma(a).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5935},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1538608,"byte_end":1538617,"line_start":266,"line_end":266,"column_start":12,"column_end":21},"name":"pochrel_e","qualname":"::gamma_beta::pochhammer_symbol::pochrel_e","value":"fn (a: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the relative Pochhammer symbol ((a)_x - 1)/x where (a)_x = \\Gamma(a + x)/\\Gamma(a).\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5936},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1538913,"byte_end":1538917,"line_start":274,"line_end":274,"column_start":9,"column_end":13},"name":"beta","qualname":"::gamma_beta::beta","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","parent":null,"children":[{"krate":0,"index":5937},{"krate":0,"index":5938},{"krate":0,"index":5939},{"krate":0,"index":5940},{"krate":0,"index":5941},{"krate":0,"index":5942},{"krate":0,"index":5943}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5940},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1539123,"byte_end":1539127,"line_start":280,"line_end":280,"column_start":12,"column_end":16},"name":"beta","qualname":"::gamma_beta::beta::beta","value":"fn (a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Beta Function, B(a,b) = \\Gamma(a)\\Gamma(b)/\\Gamma(a+b) subject to a and b not being negative integers.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5941},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1539350,"byte_end":1539356,"line_start":285,"line_end":285,"column_start":12,"column_end":18},"name":"beta_e","qualname":"::gamma_beta::beta::beta_e","value":"fn (a: f64, b: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Beta Function, B(a,b) = \\Gamma(a)\\Gamma(b)/\\Gamma(a+b) subject to a and b not being negative integers.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5942},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1539777,"byte_end":1539783,"line_start":293,"line_end":293,"column_start":12,"column_end":18},"name":"lnbeta","qualname":"::gamma_beta::beta::lnbeta","value":"fn (a: f64, b: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the logarithm of the Beta Function, \\log(B(a,b)) subject to a and b not being negative integers.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5943},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1539998,"byte_end":1540006,"line_start":298,"line_end":298,"column_start":12,"column_end":20},"name":"lnbeta_e","qualname":"::gamma_beta::beta::lnbeta_e","value":"fn (a: f64, b: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the logarithm of the Beta Function, \\log(B(a,b)) subject to a and b not being negative integers.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5944},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1540301,"byte_end":1540317,"line_start":306,"line_end":306,"column_start":9,"column_end":25},"name":"incomplete_gamma","qualname":"::gamma_beta::incomplete_gamma","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","parent":null,"children":[{"krate":0,"index":5945},{"krate":0,"index":5946},{"krate":0,"index":5947},{"krate":0,"index":5948},{"krate":0,"index":5949},{"krate":0,"index":5950},{"krate":0,"index":5951},{"krate":0,"index":5952},{"krate":0,"index":5953}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5948},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1540530,"byte_end":1540539,"line_start":312,"line_end":312,"column_start":12,"column_end":21},"name":"gamma_inc","qualname":"::gamma_beta::incomplete_gamma::gamma_inc","value":"fn (a: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the unnormalized incomplete Gamma Function \\Gamma(a,x) = \\int_x^\\infty dt t^{a-1} \\exp(-t) for a real and x >= 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5949},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1540774,"byte_end":1540785,"line_start":317,"line_end":317,"column_start":12,"column_end":23},"name":"gamma_inc_e","qualname":"::gamma_beta::incomplete_gamma::gamma_inc_e","value":"fn (a: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the unnormalized incomplete Gamma Function \\Gamma(a,x) = \\int_x^\\infty dt t^{a-1} \\exp(-t) for a real and x >= 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5950},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1541229,"byte_end":1541240,"line_start":325,"line_end":325,"column_start":12,"column_end":23},"name":"gamma_inc_Q","qualname":"::gamma_beta::incomplete_gamma::gamma_inc_Q","value":"fn (a: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the normalized incomplete Gamma Function Q(a,x) = 1/\\Gamma(a) \\int_x^\\infty dt t^{a-1} \\exp(-t) for a > 0, x >= 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5951},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1541478,"byte_end":1541491,"line_start":330,"line_end":330,"column_start":12,"column_end":25},"name":"gamma_inc_Q_e","qualname":"::gamma_beta::incomplete_gamma::gamma_inc_Q_e","value":"fn (a: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the normalized incomplete Gamma Function Q(a,x) = 1/\\Gamma(a) \\int_x^\\infty dt t^{a-1} \\exp(-t) for a > 0, x >= 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5952},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1542062,"byte_end":1542073,"line_start":340,"line_end":340,"column_start":12,"column_end":23},"name":"gamma_inc_P","qualname":"::gamma_beta::incomplete_gamma::gamma_inc_P","value":"fn (a: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the complementary normalized incomplete Gamma Function P(a,x) = 1 - Q(a,x) = 1/\\Gamma(a) \\int_0^x dt t^{a-1} \\exp(-t) for a > 0, x >= 0.","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5953},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1542436,"byte_end":1542449,"line_start":347,"line_end":347,"column_start":12,"column_end":25},"name":"gamma_inc_P_e","qualname":"::gamma_beta::incomplete_gamma::gamma_inc_P_e","value":"fn (a: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the complementary normalized incomplete Gamma Function P(a,x) = 1 - Q(a,x) = 1/\\Gamma(a) \\int_0^x dt t^{a-1} \\exp(-t) for a > 0, x >= 0.","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5954},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1542749,"byte_end":1542764,"line_start":355,"line_end":355,"column_start":9,"column_end":24},"name":"incomplete_beta","qualname":"::gamma_beta::incomplete_beta","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","parent":null,"children":[{"krate":0,"index":5955},{"krate":0,"index":5956},{"krate":0,"index":5957},{"krate":0,"index":5958},{"krate":0,"index":5959}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5958},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1543190,"byte_end":1543198,"line_start":363,"line_end":363,"column_start":12,"column_end":20},"name":"beta_inc","qualname":"::gamma_beta::incomplete_beta::beta_inc","value":"fn (a: f64, b: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the normalized incomplete Beta function I_x(a,b)=B_x(a,b)/B(a,b) where B_x(a,b) = \\int_0^x t^{a-1} (1-t)^{b-1} dt for 0 <= x <= 1.\n For a > 0, b > 0 the value is computed using a continued fraction expansion.\n For all other values it is computed using the relation I_x(a,b,x) = (1/a) x^a 2F1(a,1-b,a+1,x)/B(a,b).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5959},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gamma_beta.rs","byte_start":1543656,"byte_end":1543666,"line_start":370,"line_end":370,"column_start":12,"column_end":22},"name":"beta_inc_e","qualname":"::gamma_beta::incomplete_beta::beta_inc_e","value":"fn (a: f64, b: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the normalized incomplete Beta function I_x(a,b)=B_x(a,b)/B(a,b) where B_x(a,b) = \\int_0^x t^{a-1} (1-t)^{b-1} dt for 0 <= x <= 1.\n For a > 0, b > 0 the value is computed using a continued fraction expansion.\n For all other values it is computed using the relation I_x(a,b,x) = (1/a) x^a 2F1(a,1-b,a+1,x)/B(a,b).\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5960},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gegenbauer.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"gegenbauer","qualname":"::gegenbauer","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gegenbauer.rs","parent":null,"children":[{"krate":0,"index":5961},{"krate":0,"index":5962},{"krate":0,"index":5963},{"krate":0,"index":5964},{"krate":0,"index":5965},{"krate":0,"index":5966},{"krate":0,"index":5967},{"krate":0,"index":5968},{"krate":0,"index":5969},{"krate":0,"index":5970},{"krate":0,"index":5971},{"krate":0,"index":5972}],"decl_id":null,"docs":" The Gegenbauer polynomials are defined in Abramowitz & Stegun, Chapter 22, where they are known as Ultraspherical polynomials.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5964},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gegenbauer.rs","byte_start":1544362,"byte_end":1544373,"line_start":12,"line_end":12,"column_start":8,"column_end":19},"name":"gegenpoly_1","qualname":"::gegenbauer::gegenpoly_1","value":"fn (lambda: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function evaluates the Gegenbauer polynomials C^{(\\lambda)}_n(x) using explicit representations for n =1, 2, 3.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5965},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gegenbauer.rs","byte_start":1544585,"byte_end":1544596,"line_start":17,"line_end":17,"column_start":8,"column_end":19},"name":"gegenpoly_2","qualname":"::gegenbauer::gegenpoly_2","value":"fn (lambda: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function evaluates the Gegenbauer polynomials C^{(\\lambda)}_n(x) using explicit representations for n =1, 2, 3.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5966},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gegenbauer.rs","byte_start":1544808,"byte_end":1544819,"line_start":22,"line_end":22,"column_start":8,"column_end":19},"name":"gegenpoly_3","qualname":"::gegenbauer::gegenpoly_3","value":"fn (lambda: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function evaluates the Gegenbauer polynomials C^{(\\lambda)}_n(x) using explicit representations for n =1, 2, 3.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5967},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gegenbauer.rs","byte_start":1545031,"byte_end":1545044,"line_start":27,"line_end":27,"column_start":8,"column_end":21},"name":"gegenpoly_1_e","qualname":"::gegenbauer::gegenpoly_1_e","value":"fn (lambda: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This function evaluates the Gegenbauer polynomials C^{(\\lambda)}_n(x) using explicit representations for n =1, 2, 3.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5968},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gegenbauer.rs","byte_start":1545456,"byte_end":1545469,"line_start":35,"line_end":35,"column_start":8,"column_end":21},"name":"gegenpoly_2_e","qualname":"::gegenbauer::gegenpoly_2_e","value":"fn (lambda: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This function evaluates the Gegenbauer polynomials C^{(\\lambda)}_n(x) using explicit representations for n =1, 2, 3.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5969},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gegenbauer.rs","byte_start":1545881,"byte_end":1545894,"line_start":43,"line_end":43,"column_start":8,"column_end":21},"name":"gegenpoly_3_e","qualname":"::gegenbauer::gegenpoly_3_e","value":"fn (lambda: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This function evaluates the Gegenbauer polynomials C^{(\\lambda)}_n(x) using explicit representations for n =1, 2, 3.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5970},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gegenbauer.rs","byte_start":1546330,"byte_end":1546341,"line_start":51,"line_end":51,"column_start":8,"column_end":19},"name":"gegenpoly_n","qualname":"::gegenbauer::gegenpoly_n","value":"fn (n: i32, lambda: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function evaluates the Gegenbauer polynomial C^{(\\lambda)}_n(x) for a specific value of n, lambda, x subject to \\lambda > -1/2, n >= 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5971},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gegenbauer.rs","byte_start":1546588,"byte_end":1546601,"line_start":56,"line_end":56,"column_start":8,"column_end":21},"name":"gegenpoly_n_e","qualname":"::gegenbauer::gegenpoly_n_e","value":"fn (n: i32, lambda: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This function evaluates the Gegenbauer polynomial C^{(\\lambda)}_n(x) for a specific value of n, lambda, x subject to \\lambda > -1/2, n >= 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5972},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/gegenbauer.rs","byte_start":1547052,"byte_end":1547067,"line_start":64,"line_end":64,"column_start":8,"column_end":23},"name":"gegenpoly_array","qualname":"::gegenbauer::gegenpoly_array","value":"fn (lambda: f64, x: f64, result_array: &mut [f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes an array of Gegenbauer polynomials C^{(\\lambda)}_n(x) for n = 0, 1, 2, \\dots, nmax, subject to \\lambda > -1/2, nmax >= 0.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5973},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/hypergeometric.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"hypergeometric","qualname":"::hypergeometric","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/hypergeometric.rs","parent":null,"children":[{"krate":0,"index":5974},{"krate":0,"index":5975},{"krate":0,"index":5976},{"krate":0,"index":5977},{"krate":0,"index":5978},{"krate":0,"index":5979},{"krate":0,"index":5980},{"krate":0,"index":5981},{"krate":0,"index":5982},{"krate":0,"index":5983},{"krate":0,"index":5984},{"krate":0,"index":5985},{"krate":0,"index":5986},{"krate":0,"index":5987},{"krate":0,"index":5988},{"krate":0,"index":5989},{"krate":0,"index":5990},{"krate":0,"index":5991},{"krate":0,"index":5992},{"krate":0,"index":5993},{"krate":0,"index":5994},{"krate":0,"index":5995},{"krate":0,"index":5996},{"krate":0,"index":5997},{"krate":0,"index":5998}],"decl_id":null,"docs":" Hypergeometric functions are described in Abramowitz & Stegun, Chapters 13 and 15.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5977},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/hypergeometric.rs","byte_start":1547569,"byte_end":1547579,"line_start":12,"line_end":12,"column_start":8,"column_end":18},"name":"hyperg_0F1","qualname":"::hypergeometric::hyperg_0F1","value":"fn (c: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the hypergeometric function 0F1(c,x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5978},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/hypergeometric.rs","byte_start":1547723,"byte_end":1547735,"line_start":17,"line_end":17,"column_start":8,"column_end":20},"name":"hyperg_0F1_e","qualname":"::hypergeometric::hyperg_0F1_e","value":"fn (c: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the hypergeometric function 0F1(c,x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5979},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/hypergeometric.rs","byte_start":1548134,"byte_end":1548148,"line_start":25,"line_end":25,"column_start":8,"column_end":22},"name":"hyperg_1F1_int","qualname":"::hypergeometric::hyperg_1F1_int","value":"fn (m: i32, n: i32, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the confluent hypergeometric function 1F1(m,n,x) = M(m,n,x) for integer parameters m, n.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5980},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/hypergeometric.rs","byte_start":1548358,"byte_end":1548374,"line_start":30,"line_end":30,"column_start":8,"column_end":24},"name":"hyperg_1F1_int_e","qualname":"::hypergeometric::hyperg_1F1_int_e","value":"fn (m: i32, n: i32, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the confluent hypergeometric function 1F1(m,n,x) = M(m,n,x) for integer parameters m, n.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5981},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/hypergeometric.rs","byte_start":1548788,"byte_end":1548798,"line_start":38,"line_end":38,"column_start":8,"column_end":18},"name":"hyperg_1F1","qualname":"::hypergeometric::hyperg_1F1","value":"fn (a: f64, b: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the confluent hypergeometric function 1F1(a,b,x) = M(a,b,x) for general parameters a, b.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5982},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/hypergeometric.rs","byte_start":1549004,"byte_end":1549016,"line_start":43,"line_end":43,"column_start":8,"column_end":20},"name":"hyperg_1F1_e","qualname":"::hypergeometric::hyperg_1F1_e","value":"fn (a: f64, b: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the confluent hypergeometric function 1F1(a,b,x) = M(a,b,x) for general parameters a, b.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5983},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/hypergeometric.rs","byte_start":1549413,"byte_end":1549429,"line_start":51,"line_end":51,"column_start":8,"column_end":24},"name":"hyperg_1F1_U_int","qualname":"::hypergeometric::hyperg_1F1_U_int","value":"fn (m: i32, n: i32, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the confluent hypergeometric function U(m,n,x) for integer parameters m, n.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5984},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/hypergeometric.rs","byte_start":1549624,"byte_end":1549642,"line_start":56,"line_end":56,"column_start":8,"column_end":26},"name":"hyperg_1F1_U_int_e","qualname":"::hypergeometric::hyperg_1F1_U_int_e","value":"fn (m: i32, n: i32, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the confluent hypergeometric function U(m,n,x) for integer parameters m, n.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5985},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/hypergeometric.rs","byte_start":1550149,"byte_end":1550171,"line_start":65,"line_end":65,"column_start":8,"column_end":30},"name":"hyperg_1F1_U_int_e10_e","qualname":"::hypergeometric::hyperg_1F1_U_int_e10_e","value":"fn (m: i32, n: i32, x: f64) -> (enums::Value, ::types::ResultE10)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the confluent hypergeometric function U(m,n,x) for integer parameters m, n using the\n [`ResultE10]`(types/result/struct.ResultE10.html) type to return a result with extended range.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5986},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/hypergeometric.rs","byte_start":1550573,"byte_end":1550581,"line_start":73,"line_end":73,"column_start":8,"column_end":16},"name":"hyperg_U","qualname":"::hypergeometric::hyperg_U","value":"fn (a: f64, b: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the confluent hypergeometric function U(a,b,x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5987},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/hypergeometric.rs","byte_start":1550744,"byte_end":1550754,"line_start":78,"line_end":78,"column_start":8,"column_end":18},"name":"hyperg_U_e","qualname":"::hypergeometric::hyperg_U_e","value":"fn (a: f64, b: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the confluent hypergeometric function U(a,b,x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5988},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/hypergeometric.rs","byte_start":1551229,"byte_end":1551243,"line_start":87,"line_end":87,"column_start":8,"column_end":22},"name":"hyperg_U_e10_e","qualname":"::hypergeometric::hyperg_U_e10_e","value":"fn (a: f64, b: f64, x: f64) -> (enums::Value, ::types::ResultE10)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the confluent hypergeometric function U(a,b,x) using the\n [`ResultE10]`(types/result/struct.ResultE10.html) type to return a result with extended range.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5989},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/hypergeometric.rs","byte_start":1551935,"byte_end":1551945,"line_start":99,"line_end":99,"column_start":8,"column_end":18},"name":"hyperg_2F1","qualname":"::hypergeometric::hyperg_2F1","value":"fn (a: f64, b: f64, c: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Gauss hypergeometric function 2F1(a,b,c,x) = F(a,b,c,x) for |x| < 1.\n \n If the arguments (a,b,c,x) are too close to a singularity then the function can return the error code\n [`MaxIter`](enums/type.Value.html) when the series approximation converges too slowly.\n This occurs in the region of x=1, c - a - b = m for integer m.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5990},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/hypergeometric.rs","byte_start":1552415,"byte_end":1552427,"line_start":108,"line_end":108,"column_start":8,"column_end":20},"name":"hyperg_2F1_e","qualname":"::hypergeometric::hyperg_2F1_e","value":"fn (a: f64, b: f64, c: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Gauss hypergeometric function 2F1(a,b,c,x) = F(a,b,c,x) for |x| < 1.\n \n If the arguments (a,b,c,x) are too close to a singularity then the function can return the error code\n [`MaxIter`](enums/type.Value.html) when the series approximation converges too slowly.\n This occurs in the region of x=1, c - a - b = m for integer m.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5991},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/hypergeometric.rs","byte_start":1552866,"byte_end":1552881,"line_start":116,"line_end":116,"column_start":8,"column_end":23},"name":"hyperg_2F1_conj","qualname":"::hypergeometric::hyperg_2F1_conj","value":"fn (aR: f64, aI: f64, c: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Gauss hypergeometric function 2F1(a_R + i a_I, a_R - i a_I, c, x) with complex parameters for |x| < 1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5992},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/hypergeometric.rs","byte_start":1553125,"byte_end":1553142,"line_start":121,"line_end":121,"column_start":8,"column_end":25},"name":"hyperg_2F1_conj_e","qualname":"::hypergeometric::hyperg_2F1_conj_e","value":"fn (aR: f64, aI: f64, c: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Gauss hypergeometric function 2F1(a_R + i a_I, a_R - i a_I, c, x) with complex parameters for |x| < 1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5993},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/hypergeometric.rs","byte_start":1553568,"byte_end":1553585,"line_start":129,"line_end":129,"column_start":8,"column_end":25},"name":"hyperg_2F1_renorm","qualname":"::hypergeometric::hyperg_2F1_renorm","value":"fn (a: f64, b: f64, c: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the renormalized Gauss hypergeometric function 2F1(a,b,c,x) / \\Gamma(c) for |x| < 1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5994},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/hypergeometric.rs","byte_start":1553805,"byte_end":1553824,"line_start":134,"line_end":134,"column_start":8,"column_end":27},"name":"hyperg_2F1_renorm_e","qualname":"::hypergeometric::hyperg_2F1_renorm_e","value":"fn (a: f64, b: f64, c: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the renormalized Gauss hypergeometric function 2F1(a,b,c,x) / \\Gamma(c) for |x| < 1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5995},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/hypergeometric.rs","byte_start":1554271,"byte_end":1554293,"line_start":142,"line_end":142,"column_start":8,"column_end":30},"name":"hyperg_2F1_conj_renorm","qualname":"::hypergeometric::hyperg_2F1_conj_renorm","value":"fn (aR: f64, aI: f64, c: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the renormalized Gauss hypergeometric function 2F1(a_R + i a_I, a_R - i a_I, c, x) / \\Gamma(c) for |x| < 1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5996},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/hypergeometric.rs","byte_start":1554545,"byte_end":1554569,"line_start":147,"line_end":147,"column_start":8,"column_end":32},"name":"hyperg_2F1_conj_renorm_e","qualname":"::hypergeometric::hyperg_2F1_conj_renorm_e","value":"fn (aR: f64, aI: f64, c: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the renormalized Gauss hypergeometric function 2F1(a_R + i a_I, a_R - i a_I, c, x) / \\Gamma(c) for |x| < 1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5997},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/hypergeometric.rs","byte_start":1555090,"byte_end":1555100,"line_start":156,"line_end":156,"column_start":8,"column_end":18},"name":"hyperg_2F0","qualname":"::hypergeometric::hyperg_2F0","value":"fn (a: f64, b: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the hypergeometric function 2F0(a,b,x). The series representation is a divergent hypergeometric series.\n However, for x < 0 we have 2F0(a,b,x) = (-1/x)^a U(a,1+a-b,-1/x)\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":5998},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/hypergeometric.rs","byte_start":1555390,"byte_end":1555402,"line_start":162,"line_end":162,"column_start":8,"column_end":20},"name":"hyperg_2F0_e","qualname":"::hypergeometric::hyperg_2F0_e","value":"fn (a: f64, b: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the hypergeometric function 2F0(a,b,x). The series representation is a divergent hypergeometric series.\n However, for x < 0 we have 2F0(a,b,x) = (-1/x)^a U(a,1+a-b,-1/x)\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":5999},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/integration.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"integration","qualname":"::integration","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/integration.rs","parent":null,"children":[{"krate":0,"index":6000},{"krate":0,"index":6001},{"krate":0,"index":6002},{"krate":0,"index":6003},{"krate":0,"index":6004},{"krate":0,"index":6027},{"krate":0,"index":6036},{"krate":0,"index":6045},{"krate":0,"index":6054},{"krate":0,"index":6063},{"krate":0,"index":6072},{"krate":0,"index":6081},{"krate":0,"index":6083}],"decl_id":null,"docs":"##Introduction","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6004},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/integration.rs","byte_start":1561449,"byte_end":1561452,"line_start":115,"line_end":115,"column_start":8,"column_end":11},"name":"qng","qualname":"::integration::qng","value":"fn <T> (f: ::function<T>, arg: &mut T, a: f64, b: f64, eps_abs: f64, eps_rel: f64, result: &mut f64, abs_err: &mut f64, n_eval: &mut usize) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":" This function applies the Gauss-Kronrod 10-point, 21-point, 43-point and 87-point integration rules in succession until an estimate of the\n integral of f over (a,b) is achieved within the desired absolute and relative error limits, eps_abs and eps_rel. The function returns the final\n approximation, result, an estimate of the absolute error, abserr and the number of function evaluations used, neval. The Gauss-Kronrod rules\n are designed in such a way that each rule uses all the results of its predecessors, in order to minimize the total number of function\n evaluations.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6027},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/integration.rs","byte_start":1573178,"byte_end":1573182,"line_start":423,"line_end":423,"column_start":8,"column_end":12},"name":"qk15","qualname":"::integration::qk15","value":"fn <T> (f: ::function<T>, arg: &mut T, a: f64, b: f64, result: &mut f64, abserr: &mut f64, resabs: &mut f64, resasc: &mut f64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" Gauss quadrature weights and kronrod quadrature abscissae and weights as evaluated with 80 decimal digit arithmetic by L. W.\n Fullerton, Bell Labs, Nov. 1981.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6036},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/integration.rs","byte_start":1574826,"byte_end":1574830,"line_start":465,"line_end":465,"column_start":8,"column_end":12},"name":"qk21","qualname":"::integration::qk21","value":"fn <T> (f: ::function<T>, arg: &mut T, a: f64, b: f64, result: &mut f64, abserr: &mut f64, resabs: &mut f64, resasc: &mut f64) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6045},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/integration.rs","byte_start":1576819,"byte_end":1576823,"line_start":514,"line_end":514,"column_start":8,"column_end":12},"name":"qk31","qualname":"::integration::qk31","value":"fn <T> (f: ::function<T>, arg: &mut T, a: f64, b: f64, result: &mut f64, abserr: &mut f64, resabs: &mut f64, resasc: &mut f64) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6054},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/integration.rs","byte_start":1579436,"byte_end":1579440,"line_start":576,"line_end":576,"column_start":8,"column_end":12},"name":"qk41","qualname":"::integration::qk41","value":"fn <T> (f: ::function<T>, arg: &mut T, a: f64, b: f64, result: &mut f64, abserr: &mut f64, resabs: &mut f64, resasc: &mut f64) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6063},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/integration.rs","byte_start":1582678,"byte_end":1582682,"line_start":651,"line_end":651,"column_start":8,"column_end":12},"name":"qk51","qualname":"::integration::qk51","value":"fn <T> (f: ::function<T>, arg: &mut T, a: f64, b: f64, result: &mut f64, abserr: &mut f64, resabs: &mut f64, resasc: &mut f64) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6072},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/integration.rs","byte_start":1586497,"byte_end":1586501,"line_start":739,"line_end":739,"column_start":8,"column_end":12},"name":"qk61","qualname":"::integration::qk61","value":"fn <T> (f: ::function<T>, arg: &mut T, a: f64, b: f64, result: &mut f64, abserr: &mut f64, resabs: &mut f64, resasc: &mut f64) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6081},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/integration.rs","byte_start":1590891,"byte_end":1590893,"line_start":838,"line_end":838,"column_start":8,"column_end":10},"name":"qk","qualname":"::integration::qk","value":"fn <T> (xgk: &[f64], wg: &[f64], wgk: &[f64], fv1: &mut [f64], fv2: &mut [f64], f: ::function<T>, arg: &mut T, a: f64, b: f64, result: &mut f64, abserr: &mut f64, resabs: &mut f64, resasc: &mut f64) -> ()","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6083},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/integration.rs","byte_start":1594916,"byte_end":1594920,"line_start":939,"line_end":939,"column_start":8,"column_end":12},"name":"qawf","qualname":"::integration::qawf","value":"fn <T> (f: ::function<T>, arg: &mut T, a: f64, epsabs: f64, limit: usize, workspace: &mut ::IntegrationWorkspace, cycle_workspace: &mut ::IntegrationWorkspace, wf: &mut ::IntegrationQawoTable, result: &mut f64, abserr: &mut f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function attempts to compute a Fourier integral of the function f over the semi-infinite interval [a,+\\infty).","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6085},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/interpolation.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"interpolation","qualname":"::interpolation","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/interpolation.rs","parent":null,"children":[{"krate":0,"index":6086},{"krate":0,"index":6087},{"krate":0,"index":6088},{"krate":0,"index":6089},{"krate":0,"index":6090},{"krate":0,"index":6091},{"krate":0,"index":6092},{"krate":0,"index":6093},{"krate":0,"index":6094},{"krate":0,"index":6095},{"krate":0,"index":6096}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6088},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/interpolation.rs","byte_start":1600645,"byte_end":1600652,"line_start":10,"line_end":10,"column_start":8,"column_end":15},"name":"bsearch","qualname":"::interpolation::bsearch","value":"fn (x_array: &[f64], x: f64, index_lo: usize, index_hi: usize) -> usize","parent":null,"children":[],"decl_id":null,"docs":" This function returns the index i of the array x_array such that x_array[i] <= x < x_array[i+1]. The index is searched for in the\n range [index_lo,index_hi].\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6089},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/interpolation.rs","byte_start":1601079,"byte_end":1601083,"line_start":16,"line_end":16,"column_start":8,"column_end":12},"name":"eval","qualname":"::interpolation::eval","value":"fn (interp: &::Interp, xa: &[f64], ya: &[f64], x: f64, acc: &mut ::InterpAccel) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the interpolated value of y for a given point x, using the interpolation object interp, data arrays xa and ya and\n the accelerator acc. When x is outside the range of xa, the error code ::Dom is returned with a value of rgsl::NAN for y.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6090},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/interpolation.rs","byte_start":1601548,"byte_end":1601554,"line_start":22,"line_end":22,"column_start":8,"column_end":14},"name":"eval_e","qualname":"::interpolation::eval_e","value":"fn (interp: &::Interp, xa: &[f64], ya: &[f64], x: f64, acc: &mut ::InterpAccel, y: &mut f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function returns the interpolated value of y for a given point x, using the interpolation object interp, data arrays xa and ya and\n the accelerator acc. When x is outside the range of xa, the error code ::Dom is returned with a value of rgsl::NAN for y.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6091},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/interpolation.rs","byte_start":1601994,"byte_end":1602004,"line_start":30,"line_end":30,"column_start":8,"column_end":18},"name":"eval_deriv","qualname":"::interpolation::eval_deriv","value":"fn (interp: &::Interp, xa: &[f64], ya: &[f64], x: f64, acc: &mut ::InterpAccel) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the derivative d of an interpolated function for a given point x, using the interpolation object interp, data\n arrays xa and ya and the accelerator acc.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6092},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/interpolation.rs","byte_start":1602403,"byte_end":1602415,"line_start":38,"line_end":38,"column_start":8,"column_end":20},"name":"eval_deriv_e","qualname":"::interpolation::eval_deriv_e","value":"fn (interp: &::Interp, xa: &[f64], ya: &[f64], x: f64, acc: &mut ::InterpAccel, d: &mut f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function returns the derivative d of an interpolated function for a given point x, using the interpolation object interp, data\n arrays xa and ya and the accelerator acc.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6093},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/interpolation.rs","byte_start":1602869,"byte_end":1602880,"line_start":46,"line_end":46,"column_start":8,"column_end":19},"name":"eval_deriv2","qualname":"::interpolation::eval_deriv2","value":"fn (interp: &::Interp, xa: &[f64], ya: &[f64], x: f64, acc: &mut ::InterpAccel) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the second derivative d2 of an interpolated function for a given point x, using the interpolation object interp,\n data arrays xa and ya and the accelerator acc.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6094},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/interpolation.rs","byte_start":1603276,"byte_end":1603289,"line_start":52,"line_end":52,"column_start":8,"column_end":21},"name":"eval_deriv2_e","qualname":"::interpolation::eval_deriv2_e","value":"fn (interp: &::Interp, xa: &[f64], ya: &[f64], x: f64, acc: &mut ::InterpAccel, d2: &mut f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function returns the second derivative d2 of an interpolated function for a given point x, using the interpolation object interp,\n data arrays xa and ya and the accelerator acc.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6095},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/interpolation.rs","byte_start":1603753,"byte_end":1603763,"line_start":60,"line_end":60,"column_start":8,"column_end":18},"name":"eval_integ","qualname":"::interpolation::eval_integ","value":"fn (interp: &::Interp, xa: &[f64], ya: &[f64], a: f64, b: f64, acc: &mut ::InterpAccel) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the numerical integral result of an interpolated function over the range [a, b], using the interpolation object\n interp, data arrays xa and ya and the accelerator acc.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6096},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/interpolation.rs","byte_start":1604188,"byte_end":1604200,"line_start":68,"line_end":68,"column_start":8,"column_end":20},"name":"eval_integ_e","qualname":"::interpolation::eval_integ_e","value":"fn (interp: &::Interp, xa: &[f64], ya: &[f64], a: f64, b: f64, acc: &mut ::InterpAccel, result: &mut f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function returns the numerical integral result of an interpolated function over the range [a, b], using the interpolation object\n interp, data arrays xa and ya and the accelerator acc.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6097},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/jacobian_elliptic.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"jacobian_elliptic","qualname":"::jacobian_elliptic","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/jacobian_elliptic.rs","parent":null,"children":[{"krate":0,"index":6098},{"krate":0,"index":6099}],"decl_id":null,"docs":"The Jacobian Elliptic functions are defined in Abramowitz & Stegun, Chapter 16.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6099},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/jacobian_elliptic.rs","byte_start":1604802,"byte_end":1604810,"line_start":12,"line_end":12,"column_start":8,"column_end":16},"name":"elljac_e","qualname":"::jacobian_elliptic::elljac_e","value":"fn (u: f64, m: f64, sn: &mut f64, cn: &mut f64, dn: &mut f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the Jacobian elliptic functions sn(u|m), cn(u|m), dn(u|m) by descending Landen transformations.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6100},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/laguerre.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"laguerre","qualname":"::laguerre","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/laguerre.rs","parent":null,"children":[{"krate":0,"index":6101},{"krate":0,"index":6102},{"krate":0,"index":6103},{"krate":0,"index":6104},{"krate":0,"index":6105},{"krate":0,"index":6106},{"krate":0,"index":6107},{"krate":0,"index":6108},{"krate":0,"index":6109},{"krate":0,"index":6110},{"krate":0,"index":6111}],"decl_id":null,"docs":"The generalized Laguerre polynomials are defined in terms of confluent hypergeometric functions as L^a_n(x) = ((a+1)_n / n!) 1F1(-n,a+1,x), and are sometimes referred to as the associated Laguerre polynomials.\nThey are related to the plain Laguerre polynomials L_n(x) by L^0_n(x) = L_n(x) and L^k_n(x) = (-1)^k (d^k/dx^k) L_(n+k)(x). For more information see Abramowitz & Stegun, Chapter 22.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6104},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/laguerre.rs","byte_start":1605636,"byte_end":1605646,"line_start":15,"line_end":15,"column_start":8,"column_end":18},"name":"laguerre_1","qualname":"::laguerre::laguerre_1","value":"fn (a: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function evaluates the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6105},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/laguerre.rs","byte_start":1605852,"byte_end":1605862,"line_start":20,"line_end":20,"column_start":8,"column_end":18},"name":"laguerre_2","qualname":"::laguerre::laguerre_2","value":"fn (a: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function evaluates the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6106},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/laguerre.rs","byte_start":1606068,"byte_end":1606078,"line_start":25,"line_end":25,"column_start":8,"column_end":18},"name":"laguerre_3","qualname":"::laguerre::laguerre_3","value":"fn (a: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function evaluates the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6107},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/laguerre.rs","byte_start":1606284,"byte_end":1606296,"line_start":30,"line_end":30,"column_start":8,"column_end":20},"name":"laguerre_1_e","qualname":"::laguerre::laguerre_1_e","value":"fn (a: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This function evaluates the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6108},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/laguerre.rs","byte_start":1606702,"byte_end":1606714,"line_start":38,"line_end":38,"column_start":8,"column_end":20},"name":"laguerre_2_e","qualname":"::laguerre::laguerre_2_e","value":"fn (a: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This function evaluates the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6109},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/laguerre.rs","byte_start":1607120,"byte_end":1607132,"line_start":46,"line_end":46,"column_start":8,"column_end":20},"name":"laguerre_3_e","qualname":"::laguerre::laguerre_3_e","value":"fn (a: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This function evaluates the generalized Laguerre polynomials L^a_1(x), L^a_2(x), L^a_3(x) using explicit representations.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6110},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/laguerre.rs","byte_start":1607482,"byte_end":1607492,"line_start":54,"line_end":54,"column_start":8,"column_end":18},"name":"laguerre_n","qualname":"::laguerre::laguerre_n","value":"fn (n: i32, a: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" the generalized Laguerre polynomials L^a_n(x) for a > -1, n >= 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6111},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/laguerre.rs","byte_start":1607653,"byte_end":1607665,"line_start":59,"line_end":59,"column_start":8,"column_end":20},"name":"laguerre_n_e","qualname":"::laguerre::laguerre_n_e","value":"fn (n: i32, a: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" the generalized Laguerre polynomials L^a_n(x) for a > -1, n >= 0.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6112},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lambert_w.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"lambert_w","qualname":"::lambert_w","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lambert_w.rs","parent":null,"children":[{"krate":0,"index":6113},{"krate":0,"index":6114},{"krate":0,"index":6115},{"krate":0,"index":6116},{"krate":0,"index":6117},{"krate":0,"index":6118},{"krate":0,"index":6119}],"decl_id":null,"docs":"Lambert’s W functions, W(x), are defined to be solutions of the equation W(x) \\exp(W(x)) = x. This function has multiple branches for x < 0; however, it has only two real-valued branches.\nWe define W_0(x) to be the principal branch, where W > -1 for x < 0, and W_{-1}(x) to be the other real branch, where W < -1 for x < 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6116},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lambert_w.rs","byte_start":1608500,"byte_end":1608510,"line_start":15,"line_end":15,"column_start":8,"column_end":18},"name":"lambert_W0","qualname":"::lambert_w::lambert_W0","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This computes the principal branch of the Lambert W function, W_0(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6117},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lambert_w.rs","byte_start":1608653,"byte_end":1608665,"line_start":20,"line_end":20,"column_start":8,"column_end":20},"name":"lambert_W0_e","qualname":"::lambert_w::lambert_W0_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This computes the principal branch of the Lambert W function, W_0(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6118},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lambert_w.rs","byte_start":1609023,"byte_end":1609034,"line_start":28,"line_end":28,"column_start":8,"column_end":19},"name":"lambert_Wm1","qualname":"::lambert_w::lambert_Wm1","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This computes the secondary real-valued branch of the Lambert W function, W_{-1}(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6119},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lambert_w.rs","byte_start":1609193,"byte_end":1609206,"line_start":33,"line_end":33,"column_start":8,"column_end":21},"name":"lambert_Wm1_e","qualname":"::lambert_w::lambert_Wm1_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This computes the secondary real-valued branch of the Lambert W function, W_{-1}(x).\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6120},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"legendre","qualname":"::legendre","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","parent":null,"children":[{"krate":0,"index":6121},{"krate":0,"index":6141},{"krate":0,"index":6153},{"krate":0,"index":6169}],"decl_id":null,"docs":" The Legendre Functions and Legendre Polynomials are described in Abramowitz & Stegun, Chapter 8.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6121},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1609671,"byte_end":1609682,"line_start":7,"line_end":7,"column_start":9,"column_end":20},"name":"polynomials","qualname":"::legendre::polynomials","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","parent":null,"children":[{"krate":0,"index":6122},{"krate":0,"index":6123},{"krate":0,"index":6124},{"krate":0,"index":6125},{"krate":0,"index":6126},{"krate":0,"index":6127},{"krate":0,"index":6128},{"krate":0,"index":6129},{"krate":0,"index":6130},{"krate":0,"index":6131},{"krate":0,"index":6132},{"krate":0,"index":6133},{"krate":0,"index":6134},{"krate":0,"index":6135},{"krate":0,"index":6136},{"krate":0,"index":6137},{"krate":0,"index":6138},{"krate":0,"index":6139},{"krate":0,"index":6140}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6125},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1609861,"byte_end":1609872,"line_start":13,"line_end":13,"column_start":12,"column_end":23},"name":"legendre_P1","qualname":"::legendre::polynomials::legendre_P1","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function evaluates the Legendre polynomials P_l(x) using explicit representations for l=1, 2, 3.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6126},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1610064,"byte_end":1610075,"line_start":18,"line_end":18,"column_start":12,"column_end":23},"name":"legendre_P2","qualname":"::legendre::polynomials::legendre_P2","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function evaluates the Legendre polynomials P_l(x) using explicit representations for l=1, 2, 3.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6127},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1610267,"byte_end":1610278,"line_start":23,"line_end":23,"column_start":12,"column_end":23},"name":"legendre_P3","qualname":"::legendre::polynomials::legendre_P3","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function evaluates the Legendre polynomials P_l(x) using explicit representations for l=1, 2, 3.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6128},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1610470,"byte_end":1610483,"line_start":28,"line_end":28,"column_start":12,"column_end":25},"name":"legendre_P1_e","qualname":"::legendre::polynomials::legendre_P1_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This function evaluates the Legendre polynomials P_l(x) using explicit representations for l=1, 2, 3.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6129},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1610883,"byte_end":1610896,"line_start":36,"line_end":36,"column_start":12,"column_end":25},"name":"legendre_P2_e","qualname":"::legendre::polynomials::legendre_P2_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This function evaluates the Legendre polynomials P_l(x) using explicit representations for l=1, 2, 3.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6130},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1611296,"byte_end":1611309,"line_start":44,"line_end":44,"column_start":12,"column_end":25},"name":"legendre_P3_e","qualname":"::legendre::polynomials::legendre_P3_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This function evaluates the Legendre polynomials P_l(x) using explicit representations for l=1, 2, 3.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6131},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1611719,"byte_end":1611730,"line_start":52,"line_end":52,"column_start":12,"column_end":23},"name":"legendre_Pl","qualname":"::legendre::polynomials::legendre_Pl","value":"fn (l: i32, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function evaluates the Legendre polynomial P_l(x) for a specific value of l, x subject to l >= 0, |x| <= 1\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6132},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1611943,"byte_end":1611956,"line_start":57,"line_end":57,"column_start":12,"column_end":25},"name":"legendre_Pl_e","qualname":"::legendre::polynomials::legendre_Pl_e","value":"fn (l: i32, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This function evaluates the Legendre polynomial P_l(x) for a specific value of l, x subject to l >= 0, |x| <= 1\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6133},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1612387,"byte_end":1612404,"line_start":65,"line_end":65,"column_start":12,"column_end":29},"name":"legendre_Pl_array","qualname":"::legendre::polynomials::legendre_Pl_array","value":"fn (x: f64, result_array: &mut [f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes arrays of Legendre polynomials P_l(x) and derivatives dP_l(x)/dx, for l = 0, \\dots, lmax, |x| <= 1\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6134},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1612751,"byte_end":1612774,"line_start":72,"line_end":72,"column_start":12,"column_end":35},"name":"legendre_Pl_deriv_array","qualname":"::legendre::polynomials::legendre_Pl_deriv_array","value":"fn (x: f64, result_array: &mut [f64], result_deriv_array: &mut [f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes arrays of Legendre polynomials P_l(x) and derivatives dP_l(x)/dx, for l = 0, \\dots, lmax, |x| <= 1\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6135},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1613314,"byte_end":1613325,"line_start":86,"line_end":86,"column_start":12,"column_end":23},"name":"legendre_Q0","qualname":"::legendre::polynomials::legendre_Q0","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the Legendre function Q_0(x) for x > -1, x != 1\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6136},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1613486,"byte_end":1613499,"line_start":91,"line_end":91,"column_start":12,"column_end":25},"name":"legendre_Q0_e","qualname":"::legendre::polynomials::legendre_Q0_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This function computes the Legendre function Q_0(x) for x > -1, x != 1\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6137},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1613869,"byte_end":1613880,"line_start":99,"line_end":99,"column_start":12,"column_end":23},"name":"legendre_Q1","qualname":"::legendre::polynomials::legendre_Q1","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the Legendre function Q_0(x) for x > -1, x != 1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6138},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1614042,"byte_end":1614055,"line_start":104,"line_end":104,"column_start":12,"column_end":25},"name":"legendre_Q1_e","qualname":"::legendre::polynomials::legendre_Q1_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This function computes the Legendre function Q_0(x) for x > -1, x != 1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6139},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1614436,"byte_end":1614447,"line_start":112,"line_end":112,"column_start":12,"column_end":23},"name":"legendre_Ql","qualname":"::legendre::polynomials::legendre_Ql","value":"fn (l: i32, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the Legendre function Q_l(x) for x > -1, x != 1 and l >= 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6140},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1614631,"byte_end":1614644,"line_start":117,"line_end":117,"column_start":12,"column_end":25},"name":"legendre_Ql_e","qualname":"::legendre::polynomials::legendre_Ql_e","value":"fn (l: i32, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This function computes the Legendre function Q_l(x) for x > -1, x != 1 and l >= 0.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6141},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1615604,"byte_end":1615626,"line_start":131,"line_end":131,"column_start":9,"column_end":31},"name":"associated_polynomials","qualname":"::legendre::associated_polynomials","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","parent":null,"children":[{"krate":0,"index":6142},{"krate":0,"index":6143},{"krate":0,"index":6144},{"krate":0,"index":6145},{"krate":0,"index":6146},{"krate":0,"index":6147},{"krate":0,"index":6148},{"krate":0,"index":6149},{"krate":0,"index":6150},{"krate":0,"index":6151},{"krate":0,"index":6152}],"decl_id":null,"docs":" The following functions compute the associated Legendre Polynomials P_l^m(x).\n Note that this function grows combinatorially with l and can overflow for l larger than about 150.\n There is no trouble for small m, but overflow occurs when m and l are both large.\n Rather than allow overflows, these functions refuse to calculate P_l^m(x) and return [`OvrFlw`](enums/type.Value.html) when they can sense that l and m are too big.\n \n If you want to calculate a spherical harmonic, then do not use these functions. Instead use [`legendre_sphPlm`](fn.legendre_sphPlm.html) below, which uses a similar recursion, but with the normalized functions.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6145},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1615799,"byte_end":1615811,"line_start":137,"line_end":137,"column_start":12,"column_end":24},"name":"legendre_Plm","qualname":"::legendre::associated_polynomials::legendre_Plm","value":"fn (l: i32, m: i32, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the associated Legendre polynomial P_l^m(x) for m >= 0, l >= m, |x| <= 1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6146},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1616020,"byte_end":1616034,"line_start":142,"line_end":142,"column_start":12,"column_end":26},"name":"legendre_Plm_e","qualname":"::legendre::associated_polynomials::legendre_Plm_e","value":"fn (l: i32, m: i32, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the associated Legendre polynomial P_l^m(x) for m >= 0, l >= m, |x| <= 1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6147},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1617567,"byte_end":1617582,"line_start":165,"line_end":165,"column_start":12,"column_end":27},"name":"legendre_sphPlm","qualname":"::legendre::associated_polynomials::legendre_sphPlm","value":"fn (l: i32, m: i32, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the normalized associated Legendre polynomial \\sqrt{(2l+1)/(4\\pi)} \\sqrt{(l-m)!/(l+m)!} P_l^m(x) suitable for use in spherical harmonics.\n The parameters must satisfy m >= 0, l >= m, |x| <= 1.\n This routine avoids the overflows that occur for the standard normalization of P_l^m(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6148},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1618017,"byte_end":1618034,"line_start":172,"line_end":172,"column_start":12,"column_end":29},"name":"legendre_sphPlm_e","qualname":"::legendre::associated_polynomials::legendre_sphPlm_e","value":"fn (l: i32, m: i32, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the normalized associated Legendre polynomial \\sqrt{(2l+1)/(4\\pi)} \\sqrt{(l-m)!/(l+m)!} P_l^m(x) suitable for use in spherical harmonics.\n The parameters must satisfy m >= 0, l >= m, |x| <= 1.\n This routine avoids the overflows that occur for the standard normalization of P_l^m(x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6149},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1619776,"byte_end":1619792,"line_start":200,"line_end":200,"column_start":12,"column_end":28},"name":"legendre_array_n","qualname":"::legendre::associated_polynomials::legendre_array_n","value":"fn (lmax: usize) -> usize","parent":null,"children":[],"decl_id":null,"docs":" Returns the size of the array needed for these functions, including GSL workspace.\n","sig":null,"attributes":[{"value":"cfg(feature = \"v2\")","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1619742,"byte_end":1619764,"line_start":199,"line_end":199,"column_start":5,"column_end":27}}]},{"kind":"Function","id":{"krate":0,"index":6150},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1619926,"byte_end":1619946,"line_start":205,"line_end":205,"column_start":12,"column_end":32},"name":"legendre_array_index","qualname":"::legendre::associated_polynomials::legendre_array_index","value":"fn (l: usize, m: usize) -> usize","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"cfg(feature = \"v2\")","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1619892,"byte_end":1619914,"line_start":204,"line_end":204,"column_start":5,"column_end":27}}]},{"kind":"Function","id":{"krate":0,"index":6151},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1620096,"byte_end":1620110,"line_start":210,"line_end":210,"column_start":12,"column_end":26},"name":"legendre_array","qualname":"::legendre::associated_polynomials::legendre_array","value":"fn (norm: enums::SfLegendreNorm, lmax: usize, x: f64, result: &mut [f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"cfg(feature = \"v2\")","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1620062,"byte_end":1620084,"line_start":209,"line_end":209,"column_start":5,"column_end":27}}]},{"kind":"Function","id":{"krate":0,"index":6152},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1620412,"byte_end":1620432,"line_start":222,"line_end":222,"column_start":12,"column_end":32},"name":"legendre_deriv_array","qualname":"::legendre::associated_polynomials::legendre_deriv_array","value":"fn (norm: enums::SfLegendreNorm, lmax: usize, x: f64, result: &mut [f64], deriv: &mut [f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[{"value":"cfg(feature = \"v2\")","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1620378,"byte_end":1620400,"line_start":221,"line_end":221,"column_start":5,"column_end":27}}]},{"kind":"Mod","id":{"krate":0,"index":6153},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1620937,"byte_end":1620944,"line_start":237,"line_end":237,"column_start":9,"column_end":16},"name":"conical","qualname":"::legendre::conical","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","parent":null,"children":[{"krate":0,"index":6154},{"krate":0,"index":6155},{"krate":0,"index":6156},{"krate":0,"index":6157},{"krate":0,"index":6158},{"krate":0,"index":6159},{"krate":0,"index":6160},{"krate":0,"index":6161},{"krate":0,"index":6162},{"krate":0,"index":6163},{"krate":0,"index":6164},{"krate":0,"index":6165},{"krate":0,"index":6166},{"krate":0,"index":6167},{"krate":0,"index":6168}],"decl_id":null,"docs":" The Conical Functions P^\\mu_{-(1/2)+i\\lambda}(x) and Q^\\mu_{-(1/2)+i\\lambda} are described in Abramowitz & Stegun, Section 8.12.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6157},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1621126,"byte_end":1621130,"line_start":243,"line_end":243,"column_start":12,"column_end":16},"name":"half","qualname":"::legendre::conical::half","value":"fn (lambda: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the irregular Spherical Conical Function P^{1/2}_{-1/2 + i \\lambda}(x) for x > -1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6158},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1621348,"byte_end":1621354,"line_start":248,"line_end":248,"column_start":12,"column_end":18},"name":"half_e","qualname":"::legendre::conical::half_e","value":"fn (lambda: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the irregular Spherical Conical Function P^{1/2}_{-1/2 + i \\lambda}(x) for x > -1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6159},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1621779,"byte_end":1621784,"line_start":256,"line_end":256,"column_start":12,"column_end":17},"name":"mhalf","qualname":"::legendre::conical::mhalf","value":"fn (lambda: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the regular Spherical Conical Function P^{-1/2}_{-1/2 + i \\lambda}(x) for x > -1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6160},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1622002,"byte_end":1622009,"line_start":261,"line_end":261,"column_start":12,"column_end":19},"name":"mhalf_e","qualname":"::legendre::conical::mhalf_e","value":"fn (lambda: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the regular Spherical Conical Function P^{-1/2}_{-1/2 + i \\lambda}(x) for x > -1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6161},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1622412,"byte_end":1622414,"line_start":269,"line_end":269,"column_start":12,"column_end":14},"name":"_0","qualname":"::legendre::conical::_0","value":"fn (lambda: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the conical function P^0_{-1/2 + i \\lambda}(x) for x > -1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6162},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1622605,"byte_end":1622609,"line_start":274,"line_end":274,"column_start":12,"column_end":16},"name":"_0_e","qualname":"::legendre::conical::_0_e","value":"fn (lambda: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the conical function P^0_{-1/2 + i \\lambda}(x) for x > -1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6163},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1623008,"byte_end":1623010,"line_start":282,"line_end":282,"column_start":12,"column_end":14},"name":"_1","qualname":"::legendre::conical::_1","value":"fn (lambda: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the conical function P^1_{-1/2 + i \\lambda}(x) for x > -1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6164},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1623201,"byte_end":1623205,"line_start":287,"line_end":287,"column_start":12,"column_end":16},"name":"_1_e","qualname":"::legendre::conical::_1_e","value":"fn (lambda: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the conical function P^1_{-1/2 + i \\lambda}(x) for x > -1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6165},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1623638,"byte_end":1623645,"line_start":295,"line_end":295,"column_start":12,"column_end":19},"name":"sph_reg","qualname":"::legendre::conical::sph_reg","value":"fn (l: i32, lambda: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Regular Spherical Conical Function P^{-1/2-l}_{-1/2 + i \\lambda}(x) for x > -1, l >= -1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6166},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1623887,"byte_end":1623896,"line_start":300,"line_end":300,"column_start":12,"column_end":21},"name":"sph_reg_e","qualname":"::legendre::conical::sph_reg_e","value":"fn (l: i32, lambda: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Regular Spherical Conical Function P^{-1/2-l}_{-1/2 + i \\lambda}(x) for x > -1, l >= -1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6167},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1624344,"byte_end":1624351,"line_start":308,"line_end":308,"column_start":12,"column_end":19},"name":"cyl_reg","qualname":"::legendre::conical::cyl_reg","value":"fn (m: i32, lambda: f64, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Regular Cylindrical Conical Function P^{-m}_{-1/2 + i \\lambda}(x) for x > -1, m >= -1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6168},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1624591,"byte_end":1624600,"line_start":313,"line_end":313,"column_start":12,"column_end":21},"name":"cyl_reg_e","qualname":"::legendre::conical::cyl_reg_e","value":"fn (m: i32, lambda: f64, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Regular Cylindrical Conical Function P^{-m}_{-1/2 + i \\lambda}(x) for x > -1, m >= -1.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6169},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1625199,"byte_end":1625205,"line_start":323,"line_end":323,"column_start":9,"column_end":15},"name":"radial","qualname":"::legendre::radial","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","parent":null,"children":[{"krate":0,"index":6170},{"krate":0,"index":6171},{"krate":0,"index":6172},{"krate":0,"index":6173},{"krate":0,"index":6174},{"krate":0,"index":6175},{"krate":0,"index":6176},{"krate":0,"index":6177},{"krate":0,"index":6178},{"krate":0,"index":6179}],"decl_id":null,"docs":" The following spherical functions are specializations of Legendre functions which give the regular eigenfunctions of the Laplacian on a 3-dimensional hyperbolic space H3d.\n Of particular interest is the flat limit, \\lambda \\to \\infty, \\eta \\to 0, \\lambda\\eta fixed.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6173},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1625563,"byte_end":1625577,"line_start":330,"line_end":330,"column_start":12,"column_end":26},"name":"legendre_H3d_0","qualname":"::legendre::radial::legendre_H3d_0","value":"fn (lambda: f64, eta: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the zeroth radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space, L^{H3d}_0(\\lambda,\\eta) := \\sin(\\lambda\\eta)/(\\lambda\\sinh(\\eta)) for \\eta >= 0.\n In the flat limit this takes the form L^{H3d}_0(\\lambda,\\eta) = j_0(\\lambda\\eta).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6174},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1625976,"byte_end":1625992,"line_start":336,"line_end":336,"column_start":12,"column_end":28},"name":"legendre_H3d_0_e","qualname":"::legendre::radial::legendre_H3d_0_e","value":"fn (lambda: f64, eta: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the zeroth radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space, L^{H3d}_0(\\lambda,\\eta) := \\sin(\\lambda\\eta)/(\\lambda\\sinh(\\eta)) for \\eta >= 0.\n In the flat limit this takes the form L^{H3d}_0(\\lambda,\\eta) = j_0(\\lambda\\eta).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6175},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1626673,"byte_end":1626687,"line_start":346,"line_end":346,"column_start":12,"column_end":26},"name":"legendre_H3d_1","qualname":"::legendre::radial::legendre_H3d_1","value":"fn (lambda: f64, eta: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the first radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space, L^{H3d}_1(\\lambda,\\eta) := 1/\\sqrt{\\lambda^2 + 1} \\sin(\\lambda \\eta)/(\\lambda \\sinh(\\eta))\n (\\coth(\\eta) - \\lambda \\cot(\\lambda\\eta)) for \\eta >= 0.\n In the flat limit this takes the form L^{H3d}_1(\\lambda,\\eta) = j_1(\\lambda\\eta).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6176},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1627160,"byte_end":1627176,"line_start":353,"line_end":353,"column_start":12,"column_end":28},"name":"legendre_H3d_1_e","qualname":"::legendre::radial::legendre_H3d_1_e","value":"fn (lambda: f64, eta: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the first radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space, L^{H3d}_1(\\lambda,\\eta) := 1/\\sqrt{\\lambda^2 + 1} \\sin(\\lambda \\eta)/(\\lambda \\sinh(\\eta))\n (\\coth(\\eta) - \\lambda \\cot(\\lambda\\eta)) for \\eta >= 0.\n In the flat limit this takes the form L^{H3d}_1(\\lambda,\\eta) = j_1(\\lambda\\eta).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6177},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1627710,"byte_end":1627722,"line_start":361,"line_end":361,"column_start":12,"column_end":24},"name":"legendre_H3d","qualname":"::legendre::radial::legendre_H3d","value":"fn (l: i32, lambda: f64, eta: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the l-th radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space \\eta >= 0, l >= 0. In the flat limit this takes the form L^{H3d}_l(\\lambda,\\eta) = j_l(\\lambda\\eta).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6178},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1628057,"byte_end":1628071,"line_start":366,"line_end":366,"column_start":12,"column_end":26},"name":"legendre_H3d_e","qualname":"::legendre::radial::legendre_H3d_e","value":"fn (l: i32, lambda: f64, eta: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the l-th radial eigenfunction of the Laplacian on the 3-dimensional hyperbolic space \\eta >= 0, l >= 0. In the flat limit this takes the form L^{H3d}_l(\\lambda,\\eta) = j_l(\\lambda\\eta).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6179},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/legendre.rs","byte_start":1628508,"byte_end":1628526,"line_start":374,"line_end":374,"column_start":12,"column_end":30},"name":"legendre_H3d_array","qualname":"::legendre::radial::legendre_H3d_array","value":"fn (lambda: f64, eta: f64, result_array: &mut [f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes an array of radial eigenfunctions L^{H3d}_l(\\lambda, \\eta) for 0 <= l <= lmax.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6180},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"linear_algebra","qualname":"::linear_algebra","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","parent":null,"children":[{"krate":0,"index":6181},{"krate":0,"index":6182},{"krate":0,"index":6183},{"krate":0,"index":6184},{"krate":0,"index":6185},{"krate":0,"index":6186},{"krate":0,"index":6187},{"krate":0,"index":6188},{"krate":0,"index":6189},{"krate":0,"index":6190},{"krate":0,"index":6191},{"krate":0,"index":6192},{"krate":0,"index":6193},{"krate":0,"index":6194},{"krate":0,"index":6195},{"krate":0,"index":6196},{"krate":0,"index":6197},{"krate":0,"index":6198},{"krate":0,"index":6199},{"krate":0,"index":6200},{"krate":0,"index":6201},{"krate":0,"index":6202},{"krate":0,"index":6203},{"krate":0,"index":6204},{"krate":0,"index":6205},{"krate":0,"index":6206},{"krate":0,"index":6207},{"krate":0,"index":6208},{"krate":0,"index":6209},{"krate":0,"index":6210},{"krate":0,"index":6211},{"krate":0,"index":6212},{"krate":0,"index":6213},{"krate":0,"index":6214},{"krate":0,"index":6215},{"krate":0,"index":6216},{"krate":0,"index":6217},{"krate":0,"index":6218},{"krate":0,"index":6219},{"krate":0,"index":6220},{"krate":0,"index":6221},{"krate":0,"index":6222},{"krate":0,"index":6223},{"krate":0,"index":6224},{"krate":0,"index":6225},{"krate":0,"index":6226},{"krate":0,"index":6227},{"krate":0,"index":6228},{"krate":0,"index":6229},{"krate":0,"index":6230},{"krate":0,"index":6231},{"krate":0,"index":6232},{"krate":0,"index":6233},{"krate":0,"index":6234},{"krate":0,"index":6235},{"krate":0,"index":6236},{"krate":0,"index":6237},{"krate":0,"index":6238},{"krate":0,"index":6239},{"krate":0,"index":6240},{"krate":0,"index":6241},{"krate":0,"index":6242},{"krate":0,"index":6243},{"krate":0,"index":6244},{"krate":0,"index":6245},{"krate":0,"index":6246},{"krate":0,"index":6247},{"krate":0,"index":6248},{"krate":0,"index":6249},{"krate":0,"index":6250},{"krate":0,"index":6251},{"krate":0,"index":6252},{"krate":0,"index":6253},{"krate":0,"index":6254},{"krate":0,"index":6255},{"krate":0,"index":6256},{"krate":0,"index":6257},{"krate":0,"index":6258},{"krate":0,"index":6259},{"krate":0,"index":6260},{"krate":0,"index":6261},{"krate":0,"index":6262},{"krate":0,"index":6263},{"krate":0,"index":6264}],"decl_id":null,"docs":"#Linear Algebra","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6184},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1638042,"byte_end":1638051,"line_start":184,"line_end":184,"column_start":8,"column_end":17},"name":"LU_decomp","qualname":"::linear_algebra::LU_decomp","value":"fn (a: &mut ::MatrixF64, p: &mut ::Permutation, signum: &mut i32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" Factorise a general N x N matrix A into,","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6185},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1639081,"byte_end":1639098,"line_start":207,"line_end":207,"column_start":8,"column_end":25},"name":"complex_LU_decomp","qualname":"::linear_algebra::complex_LU_decomp","value":"fn (a: &mut ::MatrixComplexF64, p: &mut ::Permutation, signum: &mut i32) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" Factorise a general N x N complex matrix A into,","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6186},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1639578,"byte_end":1639586,"line_start":220,"line_end":220,"column_start":8,"column_end":16},"name":"LU_solve","qualname":"::linear_algebra::LU_solve","value":"fn (lu: &::MatrixF64, p: &::Permutation, b: &::VectorF64, x: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function solves the square system A x = b using the LU decomposition of A into (LU, p) given by LU_decomp or LU_decomp as input.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6187},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1640131,"byte_end":1640147,"line_start":235,"line_end":235,"column_start":8,"column_end":24},"name":"complex_LU_solve","qualname":"::linear_algebra::complex_LU_solve","value":"fn (lu: &::MatrixComplexF64, p: &::Permutation, b: &::VectorComplexF64, x: &mut ::VectorComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function solves the square system A x = b using the LU decomposition of A into (LU, p) given by LU_decomp or LU_decomp as input.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6188},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1640822,"byte_end":1640828,"line_start":251,"line_end":251,"column_start":8,"column_end":14},"name":"LU_svx","qualname":"::linear_algebra::LU_svx","value":"fn (lu: &::MatrixF64, p: &::Permutation, x: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function solves the square system A x = b in-place using the precomputed LU decomposition of A into (LU,p). On input x should contain\n the right-hand side b, which is replaced by the solution on output.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6189},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1641347,"byte_end":1641361,"line_start":261,"line_end":261,"column_start":8,"column_end":22},"name":"complex_LU_svx","qualname":"::linear_algebra::complex_LU_svx","value":"fn (lu: &::MatrixComplexF64, p: &::Permutation, x: &mut ::VectorComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function solves the square system A x = b in-place using the precomputed LU decomposition of A into (LU,p). On input x should contain\n the right-hand side b, which is replaced by the solution on output.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6190},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1641985,"byte_end":1641994,"line_start":274,"line_end":274,"column_start":8,"column_end":17},"name":"LU_refine","qualname":"::linear_algebra::LU_refine","value":"fn (a: &::MatrixF64, lu: &::MatrixF64, p: &::Permutation, b: &::VectorF64, x: &mut ::VectorF64, residual: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function applies an iterative improvement to x, the solution of A x = b, from the precomputed LU decomposition of A into (LU,p). The\n initial residual r = A x - b is also computed and stored in residual.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6191},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1642880,"byte_end":1642897,"line_start":293,"line_end":293,"column_start":8,"column_end":25},"name":"complex_LU_refine","qualname":"::linear_algebra::complex_LU_refine","value":"fn (a: &mut ::MatrixComplexF64, lu: &::MatrixComplexF64, p: &::Permutation, b: &::VectorComplexF64, x: &mut ::VectorComplexF64, residual: &mut ::VectorComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function applies an iterative improvement to x, the solution of A x = b, from the precomputed LU decomposition of A into (LU,p). The\n initial residual r = A x - b is also computed and stored in residual.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6192},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1644173,"byte_end":1644182,"line_start":314,"line_end":314,"column_start":8,"column_end":17},"name":"LU_invert","qualname":"::linear_algebra::LU_invert","value":"fn (lu: &::MatrixF64, p: &::Permutation, inverse: &mut ::MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the inverse of a matrix A from its LU decomposition (LU,p), storing the result in the matrix inverse. The inverse\n is computed by solving the system A x = b for each column of the identity matrix. It is preferable to avoid direct use of the inverse\n whenever possible, as the linear solver functions can obtain the same result more efficiently and reliably (consult any introductory\n textbook on numerical linear algebra for details).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6193},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1644978,"byte_end":1644995,"line_start":326,"line_end":326,"column_start":8,"column_end":25},"name":"complex_LU_invert","qualname":"::linear_algebra::complex_LU_invert","value":"fn (lu: &::MatrixComplexF64, p: &::Permutation, inverse: &mut ::MatrixComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the inverse of a matrix A from its LU decomposition (LU,p), storing the result in the matrix inverse. The inverse\n is computed by solving the system A x = b for each column of the identity matrix. It is preferable to avoid direct use of the inverse\n whenever possible, as the linear solver functions can obtain the same result more efficiently and reliably (consult any introductory\n textbook on numerical linear algebra for details).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6194},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1645582,"byte_end":1645588,"line_start":340,"line_end":340,"column_start":8,"column_end":14},"name":"LU_det","qualname":"::linear_algebra::LU_det","value":"fn (lu: &mut ::MatrixF64, signum: i32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the determinant of a matrix A from its LU decomposition, LU. The determinant is computed as the product of the\n diagonal elements of U and the sign of the row permutation signum.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6195},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1645927,"byte_end":1645941,"line_start":346,"line_end":346,"column_start":8,"column_end":22},"name":"complex_LU_det","qualname":"::linear_algebra::complex_LU_det","value":"fn (lu: &mut ::MatrixComplexF64, signum: i32) -> ::ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the determinant of a matrix A from its LU decomposition, LU. The determinant is computed as the product of the\n diagonal elements of U and the sign of the row permutation signum.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6196},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1646351,"byte_end":1646359,"line_start":352,"line_end":352,"column_start":8,"column_end":16},"name":"LU_lndet","qualname":"::linear_algebra::LU_lndet","value":"fn (lu: &mut ::MatrixF64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" These functions compute the logarithm of the absolute value of the determinant of a matrix A, \\ln|\\det(A)|, from its LU decomposition,\n LU. This function may be useful if the direct computation of the determinant would overflow or underflow.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6197},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1646719,"byte_end":1646735,"line_start":358,"line_end":358,"column_start":8,"column_end":24},"name":"complex_LU_lndet","qualname":"::linear_algebra::complex_LU_lndet","value":"fn (lu: &mut ::MatrixComplexF64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" These functions compute the logarithm of the absolute value of the determinant of a matrix A, \\ln|\\det(A)|, from its LU decomposition,\n LU. This function may be useful if the direct computation of the determinant would overflow or underflow.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6198},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1646997,"byte_end":1647006,"line_start":363,"line_end":363,"column_start":8,"column_end":17},"name":"LU_sgndet","qualname":"::linear_algebra::LU_sgndet","value":"fn (lu: &mut ::MatrixF64, signum: i32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the sign or phase factor of the determinant of a matrix A, \\det(A)/|\\det(A)|, from its LU decomposition, LU.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6199},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1647275,"byte_end":1647292,"line_start":368,"line_end":368,"column_start":8,"column_end":25},"name":"complex_LU_sgndet","qualname":"::linear_algebra::complex_LU_sgndet","value":"fn (lu: &mut ::MatrixComplexF64, signum: i32) -> ::ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the sign or phase factor of the determinant of a matrix A, \\det(A)/|\\det(A)|, from its LU decomposition, LU.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6200},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1648232,"byte_end":1648241,"line_start":379,"line_end":379,"column_start":8,"column_end":17},"name":"QR_decomp","qualname":"::linear_algebra::QR_decomp","value":"fn (a: &mut ::MatrixF64, tau: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function factorizes the M-by-N matrix A into the QR decomposition A = Q R. On output the diagonal and upper triangular part of the\n input matrix contain the matrix R. The vector tau and the columns of the lower triangular part of the matrix A contain the Householder\n coefficients and Householder vectors which encode the orthogonal matrix Q. The vector tau must be of length k=\\min(M,N). The matrix Q\n is related to these components by, Q = Q_k ... Q_2 Q_1 where Q_i = I - \\tau_i v_i v_i^T and v_i is the Householder vector v_i =\n (0,...,1,A(i+1,i),A(i+2,i),...,A(m,i)). This is the same storage scheme as used by LAPACK.","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6201},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1648700,"byte_end":1648708,"line_start":387,"line_end":387,"column_start":8,"column_end":16},"name":"QR_solve","qualname":"::linear_algebra::QR_solve","value":"fn (qr: &::MatrixF64, tau: &::VectorF64, b: &::VectorF64, x: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function solves the square system A x = b using the QR decomposition of A held in (QR, tau) which must have been computed previously\n with gsl_linalg_QR_decomp. The least-squares solution for rectangular systems can be found using QR_lssolve.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6202},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1649390,"byte_end":1649396,"line_start":403,"line_end":403,"column_start":8,"column_end":14},"name":"QR_svx","qualname":"::linear_algebra::QR_svx","value":"fn (qr: &::MatrixF64, tau: &::VectorF64, x: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function solves the square system A x = b in-place using the QR decomposition of A held in (QR,tau) which must have been computed\n previously by gsl_linalg_QR_decomp. On input x should contain the right-hand side b, which is replaced by the solution on output.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6203},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1650131,"byte_end":1650141,"line_start":415,"line_end":415,"column_start":8,"column_end":18},"name":"QR_lssolve","qualname":"::linear_algebra::QR_lssolve","value":"fn (qr: &::MatrixF64, tau: &::VectorF64, b: &::VectorF64, x: &mut ::VectorF64, residual: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function finds the least squares solution to the overdetermined system A x = b where the matrix A has more rows than columns. The\n least squares solution minimizes the Euclidean norm of the residual, ||Ax - b||.The routine requires as input the QR decomposition of\n A into (QR, tau) given by gsl_linalg_QR_decomp. The solution is returned in x. The residual is computed as a by-product and stored in\n residual.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6204},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1650999,"byte_end":1651007,"line_start":432,"line_end":432,"column_start":8,"column_end":16},"name":"QR_QTvec","qualname":"::linear_algebra::QR_QTvec","value":"fn (qr: &::MatrixF64, tau: &::VectorF64, v: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function applies the matrix Q^T encoded in the decomposition (QR,tau) to the vector v, storing the result Q^T v in v. The matrix\n multiplication is carried out directly using the encoding of the Householder vectors without needing to form the full matrix Q^T.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6205},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1651585,"byte_end":1651592,"line_start":442,"line_end":442,"column_start":8,"column_end":15},"name":"QR_Qvec","qualname":"::linear_algebra::QR_Qvec","value":"fn (qr: &::MatrixF64, tau: &::VectorF64, v: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function applies the matrix Q encoded in the decomposition (QR,tau) to the vector v, storing the result Q v in v. The matrix\n multiplication is carried out directly using the encoding of the Householder vectors without needing to form the full matrix Q.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6206},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1652173,"byte_end":1652181,"line_start":452,"line_end":452,"column_start":8,"column_end":16},"name":"QR_QTmat","qualname":"::linear_algebra::QR_QTmat","value":"fn (qr: &::MatrixF64, tau: &::VectorF64, v: &mut ::MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function applies the matrix Q^T encoded in the decomposition (QR,tau) to the matrix A, storing the result Q^T A in A. The matrix\n multiplication is carried out directly using the encoding of the Householder vectors without needing to form the full matrix Q^T.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6207},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1652655,"byte_end":1652664,"line_start":462,"line_end":462,"column_start":8,"column_end":17},"name":"QR_Rsolve","qualname":"::linear_algebra::QR_Rsolve","value":"fn (qr: &::MatrixF64, b: &::VectorF64, x: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function solves the triangular system R x = b for x. It may be useful if the product b' = Q^T b has already been computed using\n gsl_linalg_QR_QTvec.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6208},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1653248,"byte_end":1653255,"line_start":472,"line_end":472,"column_start":8,"column_end":15},"name":"QR_Rsvx","qualname":"::linear_algebra::QR_Rsvx","value":"fn (qr: &::MatrixF64, x: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function solves the triangular system R x = b for x in-place. On input x should contain the right-hand side b and is replaced by\n the solution on output. This function may be useful if the product b' = Q^T b has already been computed using gsl_linalg_QR_QTvec.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6209},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1653577,"byte_end":1653586,"line_start":479,"line_end":479,"column_start":8,"column_end":17},"name":"QR_unpack","qualname":"::linear_algebra::QR_unpack","value":"fn (qr: &::MatrixF64, tau: &::VectorF64, q: &mut ::MatrixF64, r: &mut ::MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function unpacks the encoded QR decomposition (QR,tau) into the matrices Q and R, where Q is M-by-M and R is M-by-N.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6210},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1654156,"byte_end":1654166,"line_start":495,"line_end":495,"column_start":8,"column_end":18},"name":"QR_QRsolve","qualname":"::linear_algebra::QR_QRsolve","value":"fn (q: &mut ::MatrixF64, r: &mut ::MatrixF64, b: &::VectorF64, x: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function solves the system R x = Q^T b for x. It can be used when the QR decomposition of a matrix is available in unpacked\n form as (Q, R).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6211},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1654832,"byte_end":1654841,"line_start":511,"line_end":511,"column_start":8,"column_end":17},"name":"QR_update","qualname":"::linear_algebra::QR_update","value":"fn (q: &mut ::MatrixF64, r: &mut ::MatrixF64, mut w: ::VectorF64, v: &::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function performs a rank-1 update w v^T of the QR decomposition (Q, R). The update is given by Q'R' = Q (R + w v^T) where the\n output matrices Q' and R' are also orthogonal and right triangular. Note that w is destroyed by the update.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6212},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1655340,"byte_end":1655347,"line_start":526,"line_end":526,"column_start":8,"column_end":15},"name":"R_solve","qualname":"::linear_algebra::R_solve","value":"fn (r: &::MatrixF64, b: &::VectorF64, x: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function solves the triangular system R x = b for the N-by-N matrix R.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6213},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1655813,"byte_end":1655818,"line_start":536,"line_end":536,"column_start":8,"column_end":13},"name":"R_svx","qualname":"::linear_algebra::R_svx","value":"fn (r: &::MatrixF64, x: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function solves the triangular system R x = b in-place. On input x should contain the right-hand side b, which is replaced by\n the solution on output.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6214},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1657067,"byte_end":1657078,"line_start":551,"line_end":551,"column_start":8,"column_end":19},"name":"QRPT_decomp","qualname":"::linear_algebra::QRPT_decomp","value":"fn (a: &mut ::MatrixF64, tau: &mut ::VectorF64, p: &mut ::Permutation, signum: &mut i32, norm: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function factorizes the M-by-N matrix A into the QRP^T decomposition A = Q R P^T. On output the diagonal and upper triangular part\n of the input matrix contain the matrix R. The permutation matrix P is stored in the permutation p. The sign of the permutation is given\n by signum. It has the value (-1)^n, where n is the number of interchanges in the permutation. The vector tau and the columns of the lower\n triangular part of the matrix A contain the Householder coefficients and vectors which encode the orthogonal matrix Q. The vector tau must\n be of length k=\\min(M,N). The matrix Q is related to these components by, Q = Q_k ... Q_2 Q_1 where Q_i = I - \\tau_i v_i v_i^T and v_i is\n the Householder vector v_i = (0,...,1,A(i+1,i),A(i+2,i),...,A(m,i)). This is the same storage scheme as used by LAPACK. The vector norm is\n a workspace of length N used for column pivoting.","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6215},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1657748,"byte_end":1657760,"line_start":569,"line_end":569,"column_start":8,"column_end":20},"name":"QRPT_decomp2","qualname":"::linear_algebra::QRPT_decomp2","value":"fn (a: &::MatrixF64, q: &mut ::MatrixF64, r: &mut ::MatrixF64, tau: &mut ::VectorF64, p: &mut ::Permutation, signum: &mut i32, norm: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function factorizes the matrix A into the decomposition A = Q R P^T without modifying A itself and storing the output in the separate\n matrices q and r.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6216},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1658614,"byte_end":1658624,"line_start":591,"line_end":591,"column_start":8,"column_end":18},"name":"QRPT_solve","qualname":"::linear_algebra::QRPT_solve","value":"fn (qr: &::MatrixF64, tau: &::VectorF64, p: &::Permutation, b: &::VectorF64, x: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function solves the square system A x = b using the QRP^T decomposition of A held in (QR, tau, p) which must have been computed previously\n by QRPT_decomp.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6217},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1659340,"byte_end":1659348,"line_start":609,"line_end":609,"column_start":8,"column_end":16},"name":"QRPT_svx","qualname":"::linear_algebra::QRPT_svx","value":"fn (qr: &::MatrixF64, tau: &::VectorF64, p: &::Permutation, x: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function solves the square system A x = b in-place using the QRP^T decomposition of A held in (QR,tau,p). On input x should contain the\n right-hand side b, which is replaced by the solution on output.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6218},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1659923,"byte_end":1659935,"line_start":625,"line_end":625,"column_start":8,"column_end":20},"name":"QRPT_QRsolve","qualname":"::linear_algebra::QRPT_QRsolve","value":"fn (q: &::MatrixF64, r: &::MatrixF64, p: &::Permutation, b: &::VectorF64, x: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function solves the square system R P^T x = Q^T b for x. It can be used when the QR decomposition of a matrix is available in unpacked\n form as (Q, R).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6219},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1660731,"byte_end":1660742,"line_start":643,"line_end":643,"column_start":8,"column_end":19},"name":"QRPT_update","qualname":"::linear_algebra::QRPT_update","value":"fn (q: &::MatrixF64, r: &::MatrixF64, p: &::Permutation, w: &mut ::VectorF64, v: &::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function performs a rank-1 update w v^T of the QRP^T decomposition (Q, R, p). The update is given by Q'R' = Q (R + w v^T P) where the\n output matrices Q' and R' are also orthogonal and right triangular. Note that w is destroyed by the update. The permutation p is not changed.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6220},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1661344,"byte_end":1661355,"line_start":660,"line_end":660,"column_start":8,"column_end":19},"name":"QRPT_Rsolve","qualname":"::linear_algebra::QRPT_Rsolve","value":"fn (qr: &::MatrixF64, p: &::Permutation, b: &::VectorF64, x: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function solves the triangular system R P^T x = b for the N-by-N matrix R contained in QR.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6221},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1661981,"byte_end":1661990,"line_start":676,"line_end":676,"column_start":8,"column_end":17},"name":"QRPT_Rsvx","qualname":"::linear_algebra::QRPT_Rsvx","value":"fn (qr: &::MatrixF64, p: &::Permutation, x: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function solves the triangular system R P^T x = b in-place for the N-by-N matrix R contained in QR. On input x should contain the\n right-hand side b, which is replaced by the solution on output.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6222},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1662875,"byte_end":1662884,"line_start":690,"line_end":690,"column_start":8,"column_end":17},"name":"SV_decomp","qualname":"::linear_algebra::SV_decomp","value":"fn (a: &mut ::MatrixF64, v: &mut ::MatrixF64, s: &mut ::VectorF64, work: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function factorizes the M-by-N matrix A into the singular value decomposition A = U S V^T for M >= N. On output the matrix A is replaced\n by U. The diagonal elements of the singular value matrix S are stored in the vector S. The singular values are non-negative and form a\n non-increasing sequence from S_1 to S_N. The matrix V contains the elements of V in untransposed form. To form the product U S V^T it is\n necessary to take the transpose of V. A workspace of length N is required in work.","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6223},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1663511,"byte_end":1663524,"line_start":706,"line_end":706,"column_start":8,"column_end":21},"name":"SV_decomp_mod","qualname":"::linear_algebra::SV_decomp_mod","value":"fn (a: &mut ::MatrixF64, x: &mut ::MatrixF64, v: &mut ::MatrixF64, s: &mut ::VectorF64, work: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the SVD using the modified Golub-Reinsch algorithm, which is faster for M>>N. It requires the vector work of length\n N and the N-by-N matrix X as additional working space.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6224},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1664305,"byte_end":1664321,"line_start":724,"line_end":724,"column_start":8,"column_end":24},"name":"SV_decomp_jacobi","qualname":"::linear_algebra::SV_decomp_jacobi","value":"fn (a: &mut ::MatrixF64, v: &mut ::MatrixF64, s: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the SVD of the M-by-N matrix A using one-sided Jacobi orthogonalization for M >= N. The Jacobi method can compute\n singular values to higher relative accuracy than Golub-Reinsch algorithms (see references for details).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6225},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1665261,"byte_end":1665269,"line_start":740,"line_end":740,"column_start":8,"column_end":16},"name":"SV_solve","qualname":"::linear_algebra::SV_solve","value":"fn (u: &::MatrixF64, v: &::MatrixF64, s: &::VectorF64, b: &::VectorF64, x: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function solves the system A x = b using the singular value decomposition (U, S, V) of A which must have been computed previously\n with gsl_linalg_SV_decomp.","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6226},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1666065,"byte_end":1666076,"line_start":759,"line_end":759,"column_start":8,"column_end":19},"name":"SV_leverage","qualname":"::linear_algebra::SV_leverage","value":"fn (u: &::MatrixF64, h: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the statistical leverage values h_i of a matrix A using its singular value decomposition (U, S, V) previously computed\n with gsl_linalg_SV_decomp. h_i are the diagonal values of the matrix A (A^T A)^{-1} A^T and depend only on the matrix U which is the input to\n this function.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6227},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1667030,"byte_end":1667045,"line_start":772,"line_end":772,"column_start":8,"column_end":23},"name":"cholesky_decomp","qualname":"::linear_algebra::cholesky_decomp","value":"fn (a: &mut ::MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function factorizes the symmetric, positive-definite square matrix A into the Cholesky decomposition A = L L^T (or A = L L^H for\n the complex case). On input, the values from the diagonal and lower-triangular part of the matrix A are used (the upper triangular part\n is ignored). On output the diagonal and lower triangular part of the input matrix A contain the matrix L, while the upper triangular part\n of the input matrix is overwritten with L^T (the diagonal terms being identical for both L and L^T). If the matrix is not positive-definite\n then the decomposition will fail, returning the error code ::Dom.","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6228},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1667946,"byte_end":1667969,"line_start":783,"line_end":783,"column_start":8,"column_end":31},"name":"complex_cholesky_decomp","qualname":"::linear_algebra::complex_cholesky_decomp","value":"fn (a: &mut ::MatrixComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function factorizes the symmetric, positive-definite square matrix A into the Cholesky decomposition A = L L^T (or A = L L^H for\n the complex case). On input, the values from the diagonal and lower-triangular part of the matrix A are used (the upper triangular part\n is ignored). On output the diagonal and lower triangular part of the input matrix A contain the matrix L, while the upper triangular part\n of the input matrix is overwritten with L^T (the diagonal terms being identical for both L and L^T). If the matrix is not positive-definite\n then the decomposition will fail, returning the error code ::Dom.","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6229},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1668365,"byte_end":1668379,"line_start":791,"line_end":791,"column_start":8,"column_end":22},"name":"cholesky_solve","qualname":"::linear_algebra::cholesky_solve","value":"fn (cholesky: &::MatrixF64, b: &::VectorF64, x: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function solves the system A x = b using the Cholesky decomposition of A held in the matrix cholesky which must have been previously\n computed by gsl_linalg_cholesky_decomp or gsl_linalg_complex_cholesky_decomp.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6230},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1668956,"byte_end":1668978,"line_start":805,"line_end":805,"column_start":8,"column_end":30},"name":"complex_cholesky_solve","qualname":"::linear_algebra::complex_cholesky_solve","value":"fn (cholesky: &::MatrixComplexF64, b: &::VectorComplexF64, x: &mut ::VectorComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function solves the system A x = b using the Cholesky decomposition of A held in the matrix cholesky which must have been previously\n computed by gsl_linalg_cholesky_decomp or gsl_linalg_complex_cholesky_decomp.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6231},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1669707,"byte_end":1669719,"line_start":820,"line_end":820,"column_start":8,"column_end":20},"name":"cholesky_svx","qualname":"::linear_algebra::cholesky_svx","value":"fn (cholesky: &::MatrixF64, x: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function solves the system A x = b in-place using the Cholesky decomposition of A held in the matrix cholesky which must have been\n previously computed by gsl_linalg_cholesky_decomp or gsl_linalg_complex_cholesky_decomp. On input x should contain the right-hand side\n b, which is replaced by the solution on output.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6232},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1670300,"byte_end":1670320,"line_start":830,"line_end":830,"column_start":8,"column_end":28},"name":"complex_cholesky_svx","qualname":"::linear_algebra::complex_cholesky_svx","value":"fn (cholesky: &::MatrixComplexF64, x: &mut ::VectorComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function solves the system A x = b in-place using the Cholesky decomposition of A held in the matrix cholesky which must have been\n previously computed by gsl_linalg_cholesky_decomp or gsl_linalg_complex_cholesky_decomp. On input x should contain the right-hand side\n b, which is replaced by the solution on output.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6233},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1670862,"byte_end":1670877,"line_start":839,"line_end":839,"column_start":8,"column_end":23},"name":"cholesky_invert","qualname":"::linear_algebra::cholesky_invert","value":"fn (cholesky: &mut ::MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the inverse of a matrix from its Cholesky decomposition cholesky, which must have been previously computed by\n gsl_linalg_cholesky_decomp or gsl_linalg_complex_cholesky_decomp. On output, the inverse is stored in-place in cholesky.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6234},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1671310,"byte_end":1671333,"line_start":847,"line_end":847,"column_start":8,"column_end":31},"name":"complex_cholesky_invert","qualname":"::linear_algebra::complex_cholesky_invert","value":"fn (cholesky: &mut ::MatrixComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the inverse of a matrix from its Cholesky decomposition cholesky, which must have been previously computed by\n gsl_linalg_cholesky_decomp or gsl_linalg_complex_cholesky_decomp. On output, the inverse is stored in-place in cholesky.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6235},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1672021,"byte_end":1672034,"line_start":857,"line_end":857,"column_start":8,"column_end":21},"name":"symmtd_decomp","qualname":"::linear_algebra::symmtd_decomp","value":"fn (a: &mut ::MatrixF64, tau: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function factorizes the symmetric square matrix A into the symmetric tridiagonal decomposition Q T Q^T. On output the diagonal and\n subdiagonal part of the input matrix A contain the tridiagonal matrix T. The remaining lower triangular part of the input matrix contains\n the Householder vectors which, together with the Householder coefficients tau, encode the orthogonal matrix Q. This storage scheme is\n the same as used by LAPACK. The upper triangular part of A is not referenced.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6236},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1672483,"byte_end":1672496,"line_start":865,"line_end":865,"column_start":8,"column_end":21},"name":"symmtd_unpack","qualname":"::linear_algebra::symmtd_unpack","value":"fn (a: &::MatrixF64, tau: &::VectorF64, q: &mut ::MatrixF64, diag: &mut ::VectorF64, subdiag: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function unpacks the encoded symmetric tridiagonal decomposition (A, tau) obtained from gsl_linalg_symmtd_decomp into the orthogonal\n matrix Q, the vector of diagonal elements diag and the vector of subdiagonal elements subdiag.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6237},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1673229,"byte_end":1673244,"line_start":883,"line_end":883,"column_start":8,"column_end":23},"name":"symmtd_unpack_T","qualname":"::linear_algebra::symmtd_unpack_T","value":"fn (a: &::MatrixF64, diag: &mut ::VectorF64, subdiag: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function unpacks the diagonal and subdiagonal of the encoded symmetric tridiagonal decomposition (A, tau) obtained from\n gsl_linalg_symmtd_decomp into the vectors diag and subdiag.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6238},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1674155,"byte_end":1674168,"line_start":899,"line_end":899,"column_start":8,"column_end":21},"name":"hermtd_decomp","qualname":"::linear_algebra::hermtd_decomp","value":"fn (a: &mut ::MatrixComplexF64, tau: &mut ::VectorComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function factorizes the hermitian matrix A into the symmetric tridiagonal decomposition U T U^T. On output the real parts of the\n diagonal and subdiagonal part of the input matrix A contain the tridiagonal matrix T. The remaining lower triangular part of the input\n matrix contains the Householder vectors which, together with the Householder coefficients tau, encode the unitary matrix U. This storage\n scheme is the same as used by LAPACK. The upper triangular part of A and imaginary parts of the diagonal are not referenced.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6239},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1674628,"byte_end":1674641,"line_start":907,"line_end":907,"column_start":8,"column_end":21},"name":"hermtd_unpack","qualname":"::linear_algebra::hermtd_unpack","value":"fn (a: &::MatrixComplexF64, tau: &::VectorComplexF64, u: &mut ::MatrixComplexF64, diag: &mut ::VectorF64, subdiag: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function unpacks the encoded tridiagonal decomposition (A, tau) obtained from gsl_linalg_hermtd_decomp into the unitary matrix U,\n the real vector of diagonal elements diag and the real vector of subdiagonal elements subdiag.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6240},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1675394,"byte_end":1675409,"line_start":925,"line_end":925,"column_start":8,"column_end":23},"name":"hermtd_unpack_T","qualname":"::linear_algebra::hermtd_unpack_T","value":"fn (a: &::MatrixComplexF64, diag: &mut ::VectorF64, subdiag: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function unpacks the diagonal and subdiagonal of the encoded tridiagonal decomposition (A, tau) obtained from the\n gsl_linalg_hermtd_decomp into the real vectors diag and subdiag.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6241},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1676287,"byte_end":1676304,"line_start":941,"line_end":941,"column_start":8,"column_end":25},"name":"hessenberg_decomp","qualname":"::linear_algebra::hessenberg_decomp","value":"fn (a: &mut ::MatrixF64, tau: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the Hessenberg decomposition of the matrix A by applying the similarity transformation H = U^T A U. On output, H\n is stored in the upper portion of A. The information required to construct the matrix U is stored in the lower triangular portion of A.\n U is a product of N - 2 Householder matrices. The Householder vectors are stored in the lower portion of A (below the subdiagonal) and\n the Householder coefficients are stored in the vector tau. tau must be of length N.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6242},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1676712,"byte_end":1676729,"line_start":949,"line_end":949,"column_start":8,"column_end":25},"name":"hessenberg_unpack","qualname":"::linear_algebra::hessenberg_unpack","value":"fn (h: &mut ::MatrixF64, tau: &mut ::VectorF64, u: &mut ::MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function constructs the orthogonal matrix U from the information stored in the Hessenberg matrix H along with the vector tau. H and\n tau are outputs from gsl_linalg_hessenberg_decomp.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6243},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1677452,"byte_end":1677475,"line_start":964,"line_end":964,"column_start":8,"column_end":31},"name":"hessenberg_unpack_accum","qualname":"::linear_algebra::hessenberg_unpack_accum","value":"fn (h: &mut ::MatrixF64, tau: &mut ::VectorF64, v: &mut ::MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function is similar to gsl_linalg_hessenberg_unpack, except it accumulates the matrix U into V, so that V' = VU. The matrix V must\n be initialized prior to calling this function. Setting V to the identity matrix provides the same result as gsl_linalg_hessenberg_unpack.\n If H is order N, then V must have N columns but may have any number of rows.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6244},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1678045,"byte_end":1678064,"line_start":978,"line_end":978,"column_start":8,"column_end":27},"name":"hessenberg_set_zero","qualname":"::linear_algebra::hessenberg_set_zero","value":"fn (h: &mut ::MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function sets the lower triangular portion of H, below the subdiagonal, to zero. It is useful for clearing out the Householder\n vectors after calling gsl_linalg_hessenberg_decomp.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6245},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1678513,"byte_end":1678527,"line_start":985,"line_end":985,"column_start":8,"column_end":22},"name":"hesstri_decomp","qualname":"::linear_algebra::hesstri_decomp","value":"fn (a: &mut ::MatrixF64, b: &mut ::MatrixF64, u: &mut ::MatrixF64, v: &mut ::MatrixF64, work: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the Hessenberg-Triangular decomposition of the matrix pair (A, B). On output, H is stored in A, and R is stored\n in B. If U and V are provided (they may be null), the similarity transformations are stored in them. Additional workspace of length N\n is needed in work.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6246},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1679564,"byte_end":1679577,"line_start":1005,"line_end":1005,"column_start":8,"column_end":21},"name":"bidiag_decomp","qualname":"::linear_algebra::bidiag_decomp","value":"fn (a: &mut ::MatrixF64, tau_u: &mut ::VectorF64, tau_v: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function factorizes the M-by-N matrix A into bidiagonal form U B V^T. The diagonal and superdiagonal of the matrix B are stored in\n the diagonal and superdiagonal of A. The orthogonal matrices U and V are stored as compressed Householder vectors in the remaining elements\n of A. The Householder coefficients are stored in the vectors tau_U and tau_V. The length of tau_U must equal the number of elements in\n the diagonal of A and the length of tau_V should be one element shorter.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6247},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1680259,"byte_end":1680272,"line_start":1020,"line_end":1020,"column_start":8,"column_end":21},"name":"bidiag_unpack","qualname":"::linear_algebra::bidiag_unpack","value":"fn (a: &mut ::MatrixF64, tau_u: &::VectorF64, u: &mut ::MatrixF64, tau_v: &::VectorF64, v: &mut ::MatrixF64, diag: &mut ::VectorF64, superdiag: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function unpacks the bidiagonal decomposition of A produced by gsl_linalg_bidiag_decomp, (A, tau_U, tau_V) into the separate orthogonal\n matrices U, V and the diagonal vector diag and superdiagonal superdiag. Note that U is stored as a compact M-by-N orthogonal matrix satisfying\n U^T U = I for efficiency.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6248},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1681269,"byte_end":1681283,"line_start":1042,"line_end":1042,"column_start":8,"column_end":22},"name":"bidiag_unpack2","qualname":"::linear_algebra::bidiag_unpack2","value":"fn (a: &mut ::MatrixF64, tau_u: &mut ::VectorF64, tau_v: &mut ::VectorF64, v: &mut ::MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function unpacks the bidiagonal decomposition of A produced by gsl_linalg_bidiag_decomp, (A, tau_U, tau_V) into the separate orthogonal\n matrices U, V and the diagonal vector diag and superdiagonal superdiag. The matrix U is stored in-place in A.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6249},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1681933,"byte_end":1681948,"line_start":1058,"line_end":1058,"column_start":8,"column_end":23},"name":"bidiag_unpack_B","qualname":"::linear_algebra::bidiag_unpack_B","value":"fn (a: &::MatrixF64, diag: &mut ::VectorF64, superdiag: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function unpacks the diagonal and superdiagonal of the bidiagonal decomposition of A from gsl_linalg_bidiag_decomp, into the diagonal\n vector diag and superdiagonal vector superdiag.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6250},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1682564,"byte_end":1682585,"line_start":1072,"line_end":1072,"column_start":8,"column_end":29},"name":"householder_transform","qualname":"::linear_algebra::householder_transform","value":"fn (v: &mut ::VectorF64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function prepares a Householder transformation P = I - \\tau v v^T which can be used to zero all the elements of the input vector except\n the first. On output the transformation is stored in the vector v and the scalar \\tau is returned.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6251},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1682955,"byte_end":1682984,"line_start":1078,"line_end":1078,"column_start":8,"column_end":37},"name":"complex_householder_transform","qualname":"::linear_algebra::complex_householder_transform","value":"fn (v: &mut ::VectorComplexF64) -> ::ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function prepares a Householder transformation P = I - \\tau v v^T which can be used to zero all the elements of the input vector except\n the first. On output the transformation is stored in the vector v and the scalar \\tau is returned.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6252},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1683343,"byte_end":1683357,"line_start":1086,"line_end":1086,"column_start":8,"column_end":22},"name":"householder_hm","qualname":"::linear_algebra::householder_hm","value":"fn (tau: f64, v: &::VectorF64, a: &mut ::MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function applies the Householder matrix P defined by the scalar tau and the vector v to the left-hand side of the matrix A. On output\n the result P A is stored in A.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6253},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1683751,"byte_end":1683773,"line_start":1094,"line_end":1094,"column_start":8,"column_end":30},"name":"complex_householder_hm","qualname":"::linear_algebra::complex_householder_hm","value":"fn (tau: &::ComplexF64, v: &::VectorComplexF64, a: &mut ::MatrixComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function applies the Householder matrix P defined by the scalar tau and the vector v to the left-hand side of the matrix A. On output\n the result P A is stored in A.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6254},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1684333,"byte_end":1684347,"line_start":1108,"line_end":1108,"column_start":8,"column_end":22},"name":"householder_mh","qualname":"::linear_algebra::householder_mh","value":"fn (tau: f64, v: &::VectorF64, a: &mut ::MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function applies the Householder matrix P defined by the scalar tau and the vector v to the right-hand side of the matrix A. On output\n the result A P is stored in A.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6255},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1684742,"byte_end":1684764,"line_start":1116,"line_end":1116,"column_start":8,"column_end":30},"name":"complex_householder_mh","qualname":"::linear_algebra::complex_householder_mh","value":"fn (tau: &::ComplexF64, v: &::VectorComplexF64, a: &mut ::MatrixComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function applies the Householder matrix P defined by the scalar tau and the vector v to the right-hand side of the matrix A. On output\n the result A P is stored in A.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6256},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1685309,"byte_end":1685323,"line_start":1130,"line_end":1130,"column_start":8,"column_end":22},"name":"householder_hv","qualname":"::linear_algebra::householder_hv","value":"fn (tau: f64, v: &::VectorF64, w: &mut ::MatrixF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function applies the Householder transformation P defined by the scalar tau and the vector v to the vector w. On output the result P\n w is stored in w.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6257},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1685703,"byte_end":1685725,"line_start":1138,"line_end":1138,"column_start":8,"column_end":30},"name":"complex_householder_hv","qualname":"::linear_algebra::complex_householder_hv","value":"fn (tau: &::ComplexF64, v: &::VectorComplexF64, w: &mut ::MatrixComplexF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function applies the Householder transformation P defined by the scalar tau and the vector v to the vector w. On output the result P\n w is stored in w.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6258},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1686321,"byte_end":1686329,"line_start":1152,"line_end":1152,"column_start":8,"column_end":16},"name":"HH_solve","qualname":"::linear_algebra::HH_solve","value":"fn (mut a: ::MatrixF64, b: &::VectorF64, x: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function solves the system A x = b directly using Householder transformations. On output the solution is stored in x and b is not\n modified. The matrix A is destroyed by the Householder transformations.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6259},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1686891,"byte_end":1686897,"line_start":1162,"line_end":1162,"column_start":8,"column_end":14},"name":"HH_svx","qualname":"::linear_algebra::HH_svx","value":"fn (mut a: ::MatrixF64, x: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function solves the system A x = b in-place using Householder transformations. On input x should contain the right-hand side b,\n which is replaced by the solution on output. The matrix A is destroyed by the Householder transformations.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6260},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1687491,"byte_end":1687504,"line_start":1177,"line_end":1177,"column_start":8,"column_end":21},"name":"solve_tridiag","qualname":"::linear_algebra::solve_tridiag","value":"fn (diag: &::VectorF64, e: &::VectorF64, f: &::VectorF64, b: &::VectorF64, x: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function solves the general N-by-N system A x = b where A is tridiagonal (N >= 2). The super-diagonal and sub-diagonal vectors\n e and f must be one element shorter than the diagonal vector diag. The form of A for the 4-by-4 case is shown below,","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6261},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1688397,"byte_end":1688415,"line_start":1202,"line_end":1202,"column_start":8,"column_end":26},"name":"solve_symm_tridiag","qualname":"::linear_algebra::solve_symm_tridiag","value":"fn (diag: &::VectorF64, e: &::VectorF64, b: &::VectorF64, x: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function solves the general N-by-N system A x = b where A is symmetric tridiagonal (N >= 2). The off-diagonal vector e must be one\n element shorter than the diagonal vector diag. The form of A for the 4-by-4 case is shown below,","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6262},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1689279,"byte_end":1689296,"line_start":1225,"line_end":1225,"column_start":8,"column_end":25},"name":"solve_cyc_tridiag","qualname":"::linear_algebra::solve_cyc_tridiag","value":"fn (diag: &::VectorF64, e: &::VectorF64, f: &::VectorF64, b: &::VectorF64, x: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function solves the general N-by-N system A x = b where A is cyclic tridiagonal (N >= 3). The cyclic super-diagonal and sub-diagonal\n vectors e and f must have the same number of elements as the diagonal vector diag. The form of A for the 4-by-4 case is shown below,","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6263},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1690231,"byte_end":1690253,"line_start":1250,"line_end":1250,"column_start":8,"column_end":30},"name":"solve_symm_cyc_tridiag","qualname":"::linear_algebra::solve_symm_cyc_tridiag","value":"fn (diag: &::VectorF64, e: &::VectorF64, b: &::VectorF64, x: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function solves the general N-by-N system A x = b where A is symmetric cyclic tridiagonal (N >= 3). The cyclic off-diagonal vector\n e must have the same number of elements as the diagonal vector diag. The form of A for the 4-by-4 case is shown below,","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6264},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/linear_algebra.rs","byte_start":1690877,"byte_end":1690891,"line_start":1266,"line_end":1266,"column_start":8,"column_end":22},"name":"balance_matrix","qualname":"::linear_algebra::balance_matrix","value":"fn (a: &mut ::MatrixF64, d: &mut ::VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function replaces the matrix A with its balanced counterpart and stores the diagonal elements of the similarity transformation into\n the vector D.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6265},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/logarithm.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"logarithm","qualname":"::logarithm","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/logarithm.rs","parent":null,"children":[{"krate":0,"index":6266},{"krate":0,"index":6267},{"krate":0,"index":6268},{"krate":0,"index":6269},{"krate":0,"index":6270},{"krate":0,"index":6271},{"krate":0,"index":6272},{"krate":0,"index":6273},{"krate":0,"index":6274},{"krate":0,"index":6275},{"krate":0,"index":6276},{"krate":0,"index":6277}],"decl_id":null,"docs":" Information on the properties of the Logarithm function can be found in Abramowitz & Stegun, Chapter 4.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6269},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/logarithm.rs","byte_start":1691407,"byte_end":1691410,"line_start":12,"line_end":12,"column_start":8,"column_end":11},"name":"log","qualname":"::logarithm::log","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the logarithm of x, \\log(x), for x > 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6270},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/logarithm.rs","byte_start":1691538,"byte_end":1691543,"line_start":17,"line_end":17,"column_start":8,"column_end":13},"name":"log_e","qualname":"::logarithm::log_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the logarithm of x, \\log(x), for x > 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6271},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/logarithm.rs","byte_start":1691892,"byte_end":1691899,"line_start":25,"line_end":25,"column_start":8,"column_end":15},"name":"log_abs","qualname":"::logarithm::log_abs","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the logarithm of the magnitude of x, \\log(|x|), for x \\ne 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6272},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/logarithm.rs","byte_start":1692052,"byte_end":1692061,"line_start":30,"line_end":30,"column_start":8,"column_end":17},"name":"log_abs_e","qualname":"::logarithm::log_abs_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the logarithm of the magnitude of x, \\log(|x|), for x \\ne 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6273},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/logarithm.rs","byte_start":1692527,"byte_end":1692540,"line_start":39,"line_end":39,"column_start":8,"column_end":21},"name":"complex_log_e","qualname":"::logarithm::complex_log_e","value":"fn (zr: f64, zi: f64) -> (enums::Value, ::types::Result, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the complex logarithm of z = z_r + i z_i.\n The results are returned as lnr, theta such that \\exp(lnr + i \\theta) = z_r + i z_i, where \\theta lies in the range [-\\pi,\\pi].\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6274},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/logarithm.rs","byte_start":1693052,"byte_end":1693062,"line_start":48,"line_end":48,"column_start":8,"column_end":18},"name":"log_1plusx","qualname":"::logarithm::log_1plusx","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes \\log(1 + x) for x > -1 using an algorithm that is accurate for small x.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6275},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/logarithm.rs","byte_start":1693229,"byte_end":1693241,"line_start":53,"line_end":53,"column_start":8,"column_end":20},"name":"log_1plusx_e","qualname":"::logarithm::log_1plusx_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes \\log(1 + x) for x > -1 using an algorithm that is accurate for small x.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6276},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/logarithm.rs","byte_start":1693612,"byte_end":1693625,"line_start":61,"line_end":61,"column_start":8,"column_end":21},"name":"log_1plusx_mx","qualname":"::logarithm::log_1plusx_mx","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes \\log(1 + x) - x for x > -1 using an algorithm that is accurate for small x.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6277},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/logarithm.rs","byte_start":1693799,"byte_end":1693814,"line_start":66,"line_end":66,"column_start":8,"column_end":23},"name":"log_1plusx_mx_e","qualname":"::logarithm::log_1plusx_mx_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes \\log(1 + x) - x for x > -1 using an algorithm that is accurate for small x.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6278},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/minimizer.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"minimizer","qualname":"::minimizer","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/minimizer.rs","parent":null,"children":[{"krate":0,"index":6279},{"krate":0,"index":6280},{"krate":0,"index":6281}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6281},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/minimizer.rs","byte_start":1695101,"byte_end":1695114,"line_start":27,"line_end":27,"column_start":8,"column_end":21},"name":"test_interval","qualname":"::minimizer::test_interval","value":"fn (x_lower: f64, x_upper: f64, epsabs: f64, epsrel: f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function tests for the convergence of the interval [x_lower, x_upper] with absolute error epsabs and relative error epsrel. The \n test returns ::Value::Success if the following condition is achieved,","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6282},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/multifit.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"multifit","qualname":"::multifit","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/multifit.rs","parent":null,"children":[{"krate":0,"index":6283},{"krate":0,"index":6284},{"krate":0,"index":6285},{"krate":0,"index":6286}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6284},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/multifit.rs","byte_start":1695476,"byte_end":1695481,"line_start":8,"line_end":8,"column_start":8,"column_end":13},"name":"covar","qualname":"::multifit::covar","value":"fn (J: &::MatrixF64, epsrel: f64, covar: &mut ::MatrixF64) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":" Compute the covariance matrix cov = inv (J^T J) by QRP^T decomposition of J\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6285},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/multifit.rs","byte_start":1695694,"byte_end":1695704,"line_start":14,"line_end":14,"column_start":8,"column_end":18},"name":"test_delta","qualname":"::multifit::test_delta","value":"fn (dx: &::VectorF64, x: &::VectorF64, epsabs: f64, epsrel: f64) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6286},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/multifit.rs","byte_start":1696044,"byte_end":1696052,"line_start":23,"line_end":23,"column_start":8,"column_end":16},"name":"gradient","qualname":"::multifit::gradient","value":"fn (J: &::MatrixF64, f: &::VectorF64, g: &mut ::VectorF64) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6287},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/numerical_differentiation.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"numerical_differentiation","qualname":"::numerical_differentiation","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/numerical_differentiation.rs","parent":null,"children":[{"krate":0,"index":6288},{"krate":0,"index":6289},{"krate":0,"index":6290},{"krate":0,"index":6292},{"krate":0,"index":6294},{"krate":0,"index":6296},{"krate":0,"index":6298}],"decl_id":null,"docs":"#Numerical Differentiation","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6292},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/numerical_differentiation.rs","byte_start":1698732,"byte_end":1698745,"line_start":64,"line_end":64,"column_start":8,"column_end":21},"name":"deriv_central","qualname":"::numerical_differentiation::deriv_central","value":"fn <T> (f: ::function<T>, param: &mut T, x: f64, h: f64, result: &mut f64, abs_err: &mut f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the numerical derivative of the function f at the point x using an adaptive central difference algorithm with a step-size\n of h. The derivative is returned in result and an estimate of its absolute error is returned in abserr.\n \n The initial value of h is used to estimate an optimal step-size, based on the scaling of the truncation error and round-off error in the\n derivative calculation. The derivative is computed using a 5-point rule for equally spaced abscissae at x-h, x-h/2, x, x+h/2, x+h, with\n an error estimate taken from the difference between the 5-point rule and the corresponding 3-point rule x-h, x, x+h. Note that the value\n of the function at x does not contribute to the derivative calculation, so only 4-points are actually used.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6296},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/numerical_differentiation.rs","byte_start":1701313,"byte_end":1701326,"line_start":132,"line_end":132,"column_start":8,"column_end":21},"name":"deriv_forward","qualname":"::numerical_differentiation::deriv_forward","value":"fn <T> (f: ::function<T>, param: &mut T, x: f64, h: f64, result: &mut f64, abs_err: &mut f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the numerical derivative of the function f at the point x using an adaptive forward difference algorithm with a step-size\n of h. The function is evaluated only at points greater than x, and never at x itself. The derivative is returned in result and an estimate\n of its absolute error is returned in abserr. This function should be used if f(x) has a discontinuity at x, or is undefined for values less\n than x.\n \n The initial value of h is used to estimate an optimal step-size, based on the scaling of the truncation error and round-off error in the\n derivative calculation. The derivative at x is computed using an “open” 4-point rule for equally spaced abscissae at x+h/4, x+h/2, x+3h/4,\n x+h, with an error estimate taken from the difference between the 4-point rule and the corresponding 2-point rule x+h/2, x+h.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6298},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/numerical_differentiation.rs","byte_start":1702770,"byte_end":1702784,"line_start":172,"line_end":172,"column_start":8,"column_end":22},"name":"deriv_backward","qualname":"::numerical_differentiation::deriv_backward","value":"fn <T> (f: ::function<T>, param: &mut T, x: f64, h: f64, result: &mut f64, abs_err: &mut f64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes the numerical derivative of the function f at the point x using an adaptive backward difference algorithm with a\n step-size of h. The function is evaluated only at points less than x, and never at x itself. The derivative is returned in result and an\n estimate of its absolute error is returned in abserr. This function should be used if f(x) has a discontinuity at x, or is undefined for\n values greater than x.\n \n This function is equivalent to calling gsl_deriv_forward with a negative step-size.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6300},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"physical_constant","qualname":"::physical_constant","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","parent":null,"children":[{"krate":0,"index":6301},{"krate":0,"index":6302},{"krate":0,"index":6303},{"krate":0,"index":6304},{"krate":0,"index":6305},{"krate":0,"index":6306},{"krate":0,"index":6307},{"krate":0,"index":6308},{"krate":0,"index":6309},{"krate":0,"index":6310},{"krate":0,"index":6311},{"krate":0,"index":6312},{"krate":0,"index":6313},{"krate":0,"index":6314},{"krate":0,"index":6315},{"krate":0,"index":6316},{"krate":0,"index":6317},{"krate":0,"index":6318},{"krate":0,"index":6319},{"krate":0,"index":6320},{"krate":0,"index":6321},{"krate":0,"index":6322},{"krate":0,"index":6323},{"krate":0,"index":6324},{"krate":0,"index":6325},{"krate":0,"index":6326},{"krate":0,"index":6327},{"krate":0,"index":6328},{"krate":0,"index":6329},{"krate":0,"index":6330},{"krate":0,"index":6331},{"krate":0,"index":6332},{"krate":0,"index":6333},{"krate":0,"index":6334},{"krate":0,"index":6335},{"krate":0,"index":6336},{"krate":0,"index":6337},{"krate":0,"index":6338},{"krate":0,"index":6339},{"krate":0,"index":6340},{"krate":0,"index":6341},{"krate":0,"index":6342},{"krate":0,"index":6343},{"krate":0,"index":6344},{"krate":0,"index":6345},{"krate":0,"index":6346},{"krate":0,"index":6347},{"krate":0,"index":6348},{"krate":0,"index":6349},{"krate":0,"index":6350},{"krate":0,"index":6351},{"krate":0,"index":6352},{"krate":0,"index":6353},{"krate":0,"index":6354},{"krate":0,"index":6355},{"krate":0,"index":6356},{"krate":0,"index":6357},{"krate":0,"index":6358},{"krate":0,"index":6359},{"krate":0,"index":6360},{"krate":0,"index":6361},{"krate":0,"index":6362},{"krate":0,"index":6363},{"krate":0,"index":6364},{"krate":0,"index":6365},{"krate":0,"index":6366},{"krate":0,"index":6367},{"krate":0,"index":6368},{"krate":0,"index":6369},{"krate":0,"index":6370},{"krate":0,"index":6371},{"krate":0,"index":6372},{"krate":0,"index":6373},{"krate":0,"index":6374},{"krate":0,"index":6375},{"krate":0,"index":6376},{"krate":0,"index":6377},{"krate":0,"index":6378},{"krate":0,"index":6379},{"krate":0,"index":6380},{"krate":0,"index":6381},{"krate":0,"index":6382},{"krate":0,"index":6383},{"krate":0,"index":6384},{"krate":0,"index":6385},{"krate":0,"index":6386},{"krate":0,"index":6387},{"krate":0,"index":6388},{"krate":0,"index":6389},{"krate":0,"index":6390},{"krate":0,"index":6391},{"krate":0,"index":6392},{"krate":0,"index":6393},{"krate":0,"index":6394},{"krate":0,"index":6395},{"krate":0,"index":6396},{"krate":0,"index":6397},{"krate":0,"index":6398},{"krate":0,"index":6399},{"krate":0,"index":6400},{"krate":0,"index":6401},{"krate":0,"index":6402},{"krate":0,"index":6403},{"krate":0,"index":6404},{"krate":0,"index":6405},{"krate":0,"index":6406},{"krate":0,"index":6407},{"krate":0,"index":6408},{"krate":0,"index":6409},{"krate":0,"index":6410},{"krate":0,"index":6411},{"krate":0,"index":6412},{"krate":0,"index":6413},{"krate":0,"index":6414},{"krate":0,"index":6415},{"krate":0,"index":6416}],"decl_id":null,"docs":" Physical Constants","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6301},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1704055,"byte_end":1704074,"line_start":25,"line_end":25,"column_start":12,"column_end":31},"name":"MKSA_SPEED_OF_LIGHT","qualname":"::physical_constant::MKSA_SPEED_OF_LIGHT","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The speed of light in vacuum, c. m / s\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6302},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1704222,"byte_end":1704246,"line_start":28,"line_end":28,"column_start":12,"column_end":36},"name":"MKSA_VACUUM_PERMEABILITY","qualname":"::physical_constant::MKSA_VACUUM_PERMEABILITY","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The permeability of free space, \\mu_0. This constant is defined in the MKSA system only.\n `kg m / A^2 s^2`\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6303},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1704405,"byte_end":1704429,"line_start":31,"line_end":31,"column_start":12,"column_end":36},"name":"MKSA_VACUUM_PERMITTIVITY","qualname":"::physical_constant::MKSA_VACUUM_PERMITTIVITY","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The permittivity of free space, \\epsilon_0. This constant is defined in the MKSA system only.\n `A^2 s^4 / kg m^3`\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6304},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1704505,"byte_end":1704528,"line_start":33,"line_end":33,"column_start":12,"column_end":35},"name":"MKSA_PLANCKS_CONSTANT_H","qualname":"::physical_constant::MKSA_PLANCKS_CONSTANT_H","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" Planck’s constant, h. kg m^2 / s\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6305},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1704623,"byte_end":1704649,"line_start":35,"line_end":35,"column_start":12,"column_end":38},"name":"MKSA_PLANCKS_CONSTANT_HBAR","qualname":"::physical_constant::MKSA_PLANCKS_CONSTANT_HBAR","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" Planck’s constant divided by 2\\pi, \\hbar. kg m^2 / s\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6306},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1704726,"byte_end":1704738,"line_start":37,"line_end":37,"column_start":12,"column_end":24},"name":"NUM_AVOGADRO","qualname":"::physical_constant::NUM_AVOGADRO","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" Avogadro’s number, N_a. 1 / mol\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6307},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1704818,"byte_end":1704830,"line_start":39,"line_end":39,"column_start":12,"column_end":24},"name":"MKSA_FARADAY","qualname":"::physical_constant::MKSA_FARADAY","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The molar charge of 1 Faraday. A s / mol\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6308},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1704913,"byte_end":1704927,"line_start":41,"line_end":41,"column_start":12,"column_end":26},"name":"MKSA_BOLTZMANN","qualname":"::physical_constant::MKSA_BOLTZMANN","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The Boltzmann constant, k. kg m^2 / K s^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6309},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1705014,"byte_end":1705028,"line_start":43,"line_end":43,"column_start":12,"column_end":26},"name":"MKSA_MOLAR_GAS","qualname":"::physical_constant::MKSA_MOLAR_GAS","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The molar gas constant, R_0. kg m^2 / K mol s^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6310},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1705104,"byte_end":1705128,"line_start":45,"line_end":45,"column_start":12,"column_end":36},"name":"MKSA_STANDARD_GAS_VOLUME","qualname":"::physical_constant::MKSA_STANDARD_GAS_VOLUME","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The standard gas volume, V_0. m^3 / mol\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6311},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1705228,"byte_end":1705258,"line_start":47,"line_end":47,"column_start":12,"column_end":42},"name":"MKSA_STEFAN_BOLTZMANN_CONSTANT","qualname":"::physical_constant::MKSA_STEFAN_BOLTZMANN_CONSTANT","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The Stefan-Boltzmann radiation constant, \\sigma. kg / K^4 s^3\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6312},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1705342,"byte_end":1705352,"line_start":49,"line_end":49,"column_start":12,"column_end":22},"name":"MKSA_GAUSS","qualname":"::physical_constant::MKSA_GAUSS","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The magnetic field of 1 Gauss. kg / A s^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6313},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1705480,"byte_end":1705502,"line_start":53,"line_end":53,"column_start":12,"column_end":34},"name":"MKSA_ASTRONOMICAL_UNIT","qualname":"::physical_constant::MKSA_ASTRONOMICAL_UNIT","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The length of 1 astronomical unit (mean earth-sun distance), au. m\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6314},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1705588,"byte_end":1705615,"line_start":55,"line_end":55,"column_start":12,"column_end":39},"name":"MKSA_GRAVITATIONAL_CONSTANT","qualname":"::physical_constant::MKSA_GRAVITATIONAL_CONSTANT","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The gravitational constant, G. m^3 / kg s^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6315},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1705686,"byte_end":1705701,"line_start":57,"line_end":57,"column_start":12,"column_end":27},"name":"MKSA_LIGHT_YEAR","qualname":"::physical_constant::MKSA_LIGHT_YEAR","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The distance of 1 light-year, ly. m\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6316},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1705775,"byte_end":1705786,"line_start":59,"line_end":59,"column_start":12,"column_end":23},"name":"MKSA_PARSEC","qualname":"::physical_constant::MKSA_PARSEC","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The distance of 1 parsec, pc. m\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6317},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1705889,"byte_end":1705904,"line_start":61,"line_end":61,"column_start":12,"column_end":27},"name":"MKSA_GRAV_ACCEL","qualname":"::physical_constant::MKSA_GRAV_ACCEL","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The standard gravitational acceleration on Earth, g. m / s^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6318},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1705963,"byte_end":1705978,"line_start":63,"line_end":63,"column_start":12,"column_end":27},"name":"MKSA_SOLAR_MASS","qualname":"::physical_constant::MKSA_SOLAR_MASS","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The mass of the Sun. kg\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6319},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1706080,"byte_end":1706100,"line_start":67,"line_end":67,"column_start":12,"column_end":32},"name":"MKSA_ELECTRON_CHARGE","qualname":"::physical_constant::MKSA_ELECTRON_CHARGE","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The charge of the electron, e. A s\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6320},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1706189,"byte_end":1706207,"line_start":69,"line_end":69,"column_start":12,"column_end":30},"name":"MKSA_ELECTRON_VOLT","qualname":"::physical_constant::MKSA_ELECTRON_VOLT","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The energy of 1 electron volt, eV. kg m^2 / s^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6321},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1706281,"byte_end":1706305,"line_start":71,"line_end":71,"column_start":12,"column_end":36},"name":"MKSA_UNIFIED_ATOMIC_MASS","qualname":"::physical_constant::MKSA_UNIFIED_ATOMIC_MASS","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The unified atomic mass, amu. kg\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6322},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1706380,"byte_end":1706398,"line_start":73,"line_end":73,"column_start":12,"column_end":30},"name":"MKSA_MASS_ELECTRON","qualname":"::physical_constant::MKSA_MASS_ELECTRON","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The mass of the electron, m_e. kg\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6323},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1706470,"byte_end":1706484,"line_start":75,"line_end":75,"column_start":12,"column_end":26},"name":"MKSA_MASS_MUON","qualname":"::physical_constant::MKSA_MASS_MUON","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The mass of the muon, m_\\mu. kg\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6324},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1706556,"byte_end":1706572,"line_start":77,"line_end":77,"column_start":12,"column_end":28},"name":"MKSA_MASS_PROTON","qualname":"::physical_constant::MKSA_MASS_PROTON","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The mass of the proton, m_p. kg\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6325},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1706645,"byte_end":1706662,"line_start":79,"line_end":79,"column_start":12,"column_end":29},"name":"MKSA_MASS_NEUTRON","qualname":"::physical_constant::MKSA_MASS_NEUTRON","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The mass of the neutron, m_n. kg\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6326},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1706756,"byte_end":1706774,"line_start":81,"line_end":81,"column_start":12,"column_end":30},"name":"NUM_FINE_STRUCTURE","qualname":"::physical_constant::NUM_FINE_STRUCTURE","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The electromagnetic fine structure constant \\alpha. 1\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6327},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1706960,"byte_end":1706972,"line_start":84,"line_end":84,"column_start":12,"column_end":24},"name":"MKSA_RYDBERG","qualname":"::physical_constant::MKSA_RYDBERG","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The Rydberg constant, Ry, in units of energy. This is related to the Rydberg inverse\n wavelength `R_\\infty by Ry = h c R_\\infty. kg m^2 / s^2`\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6328},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1707039,"byte_end":1707055,"line_start":86,"line_end":86,"column_start":12,"column_end":28},"name":"MKSA_BOHR_RADIUS","qualname":"::physical_constant::MKSA_BOHR_RADIUS","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The Bohr radius, a_0. m\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6329},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1707124,"byte_end":1707137,"line_start":88,"line_end":88,"column_start":12,"column_end":25},"name":"MKSA_ANGSTROM","qualname":"::physical_constant::MKSA_ANGSTROM","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The length of 1 angstrom. m\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6330},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1707192,"byte_end":1707201,"line_start":90,"line_end":90,"column_start":12,"column_end":21},"name":"MKSA_BARN","qualname":"::physical_constant::MKSA_BARN","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The area of 1 barn. m^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6331},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1707264,"byte_end":1707282,"line_start":92,"line_end":92,"column_start":12,"column_end":30},"name":"MKSA_BOHR_MAGNETON","qualname":"::physical_constant::MKSA_BOHR_MAGNETON","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The Bohr Magneton, \\mu_B. A m^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6332},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1707357,"byte_end":1707378,"line_start":94,"line_end":94,"column_start":12,"column_end":33},"name":"MKSA_NUCLEAR_MAGNETON","qualname":"::physical_constant::MKSA_NUCLEAR_MAGNETON","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The Nuclear Magneton, \\mu_N. A m^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6333},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1707552,"byte_end":1707581,"line_start":97,"line_end":97,"column_start":12,"column_end":41},"name":"MKSA_ELECTRON_MAGNETIC_MOMENT","qualname":"::physical_constant::MKSA_ELECTRON_MAGNETIC_MOMENT","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The absolute value of the magnetic moment of the electron, \\mu_e. The physical magnetic moment\n of the electron is negative. A m^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6334},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1707669,"byte_end":1707696,"line_start":99,"line_end":99,"column_start":12,"column_end":39},"name":"MKSA_PROTON_MAGNETIC_MOMENT","qualname":"::physical_constant::MKSA_PROTON_MAGNETIC_MOMENT","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The magnetic moment of the proton, \\mu_p. A m^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6335},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1707778,"byte_end":1707804,"line_start":101,"line_end":101,"column_start":12,"column_end":38},"name":"MKSA_THOMSON_CROSS_SECTION","qualname":"::physical_constant::MKSA_THOMSON_CROSS_SECTION","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The Thomson cross section, \\sigma_T. m^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6336},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1707901,"byte_end":1707911,"line_start":103,"line_end":103,"column_start":12,"column_end":22},"name":"MKSA_DEBYE","qualname":"::physical_constant::MKSA_DEBYE","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The electric dipole moment of 1 Debye, D. A s^2 / m^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6337},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1708015,"byte_end":1708026,"line_start":107,"line_end":107,"column_start":12,"column_end":23},"name":"MKSA_MINUTE","qualname":"::physical_constant::MKSA_MINUTE","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The number of seconds in 1 minute. s\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6338},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1708093,"byte_end":1708102,"line_start":109,"line_end":109,"column_start":12,"column_end":21},"name":"MKSA_HOUR","qualname":"::physical_constant::MKSA_HOUR","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The number of seconds in 1 hour. s\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6339},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1708170,"byte_end":1708178,"line_start":111,"line_end":111,"column_start":12,"column_end":20},"name":"MKSA_DAY","qualname":"::physical_constant::MKSA_DAY","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The number of seconds in 1 day. s\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6340},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1708248,"byte_end":1708257,"line_start":113,"line_end":113,"column_start":12,"column_end":21},"name":"MKSA_WEEK","qualname":"::physical_constant::MKSA_WEEK","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The number of seconds in 1 week. s\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6341},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1708336,"byte_end":1708345,"line_start":117,"line_end":117,"column_start":12,"column_end":21},"name":"MKSA_INCH","qualname":"::physical_constant::MKSA_INCH","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The length of 1 inch. m\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6342},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1708402,"byte_end":1708411,"line_start":119,"line_end":119,"column_start":12,"column_end":21},"name":"MKSA_FOOT","qualname":"::physical_constant::MKSA_FOOT","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The length of 1 foot. m\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6343},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1708469,"byte_end":1708478,"line_start":121,"line_end":121,"column_start":12,"column_end":21},"name":"MKSA_YARD","qualname":"::physical_constant::MKSA_YARD","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The length of 1 yard. m\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6344},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1708536,"byte_end":1708545,"line_start":123,"line_end":123,"column_start":12,"column_end":21},"name":"MKSA_MILE","qualname":"::physical_constant::MKSA_MILE","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The length of 1 mile. m\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6345},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1708626,"byte_end":1708634,"line_start":125,"line_end":125,"column_start":12,"column_end":20},"name":"MKSA_MIL","qualname":"::physical_constant::MKSA_MIL","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The length of 1 mil (1/1000th of an inch). m\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6346},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1708737,"byte_end":1708761,"line_start":129,"line_end":129,"column_start":12,"column_end":36},"name":"MKSA_KILOMETERS_PER_HOUR","qualname":"::physical_constant::MKSA_KILOMETERS_PER_HOUR","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The speed of 1 kilometer per hour. m / s\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6347},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1708839,"byte_end":1708858,"line_start":131,"line_end":131,"column_start":12,"column_end":31},"name":"MKSA_MILES_PER_HOUR","qualname":"::physical_constant::MKSA_MILES_PER_HOUR","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The speed of 1 mile per hour. m / s\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6348},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1708926,"byte_end":1708944,"line_start":133,"line_end":133,"column_start":12,"column_end":30},"name":"MKSA_NAUTICAL_MILE","qualname":"::physical_constant::MKSA_NAUTICAL_MILE","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The length of 1 nautical mile. m\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6349},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1709003,"byte_end":1709014,"line_start":135,"line_end":135,"column_start":12,"column_end":23},"name":"MKSA_FATHOM","qualname":"::physical_constant::MKSA_FATHOM","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The length of 1 fathom. m\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6350},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1709075,"byte_end":1709084,"line_start":137,"line_end":137,"column_start":12,"column_end":21},"name":"MKSA_KNOT","qualname":"::physical_constant::MKSA_KNOT","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The speed of 1 knot. m / s\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6351},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1709194,"byte_end":1709204,"line_start":141,"line_end":141,"column_start":12,"column_end":22},"name":"MKSA_POINT","qualname":"::physical_constant::MKSA_POINT","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The length of 1 printer’s point (1/72 inch). m\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6352},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1709290,"byte_end":1709303,"line_start":143,"line_end":143,"column_start":12,"column_end":25},"name":"MKSA_TEXPOINT","qualname":"::physical_constant::MKSA_TEXPOINT","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The length of 1 TeX point (1/72.27 inch). m\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6353},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1709399,"byte_end":1709410,"line_start":147,"line_end":147,"column_start":12,"column_end":23},"name":"MKSA_MICRON","qualname":"::physical_constant::MKSA_MICRON","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The length of 1 micron. m\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6354},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1709467,"byte_end":1709479,"line_start":149,"line_end":149,"column_start":12,"column_end":24},"name":"MKSA_HECTARE","qualname":"::physical_constant::MKSA_HECTARE","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The area of 1 hectare. m^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6355},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1709532,"byte_end":1709541,"line_start":151,"line_end":151,"column_start":12,"column_end":21},"name":"MKSA_ACRE","qualname":"::physical_constant::MKSA_ACRE","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The area of 1 acre. m^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6356},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1709609,"byte_end":1709619,"line_start":153,"line_end":153,"column_start":12,"column_end":22},"name":"MKSA_LITER","qualname":"::physical_constant::MKSA_LITER","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The volume of 1 liter. m^3\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6357},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1709680,"byte_end":1709694,"line_start":155,"line_end":155,"column_start":12,"column_end":26},"name":"MKSA_US_GALLON","qualname":"::physical_constant::MKSA_US_GALLON","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The volume of 1 US gallon. m^3\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6358},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1709773,"byte_end":1709793,"line_start":157,"line_end":157,"column_start":12,"column_end":32},"name":"MKSA_CANADIAN_GALLON","qualname":"::physical_constant::MKSA_CANADIAN_GALLON","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The volume of 1 Canadian gallon. m^3\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6359},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1709860,"byte_end":1709874,"line_start":159,"line_end":159,"column_start":12,"column_end":26},"name":"MKSA_UK_GALLON","qualname":"::physical_constant::MKSA_UK_GALLON","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The volume of 1 UK gallon. m^3\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6360},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1709938,"byte_end":1709948,"line_start":161,"line_end":161,"column_start":12,"column_end":22},"name":"MKSA_QUART","qualname":"::physical_constant::MKSA_QUART","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The volume of 1 quart. m^3\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6361},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1710016,"byte_end":1710025,"line_start":163,"line_end":163,"column_start":12,"column_end":21},"name":"MKSA_PINT","qualname":"::physical_constant::MKSA_PINT","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The volume of 1 pint. m^3\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6362},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1710071,"byte_end":1710079,"line_start":165,"line_end":165,"column_start":12,"column_end":20},"name":"MKSA_CUP","qualname":"::physical_constant::MKSA_CUP","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" m^3\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6363},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1710165,"byte_end":1710180,"line_start":169,"line_end":169,"column_start":12,"column_end":27},"name":"MKSA_POUND_MASS","qualname":"::physical_constant::MKSA_POUND_MASS","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The mass of 1 pound. kg\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6364},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1710242,"byte_end":1710257,"line_start":171,"line_end":171,"column_start":12,"column_end":27},"name":"MKSA_OUNCE_MASS","qualname":"::physical_constant::MKSA_OUNCE_MASS","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The mass of 1 ounce. kg\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6365},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1710320,"byte_end":1710328,"line_start":173,"line_end":173,"column_start":12,"column_end":20},"name":"MKSA_TON","qualname":"::physical_constant::MKSA_TON","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The mass of 1 ton. kg\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6366},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1710404,"byte_end":1710419,"line_start":175,"line_end":175,"column_start":12,"column_end":27},"name":"MKSA_METRIC_TON","qualname":"::physical_constant::MKSA_METRIC_TON","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The mass of 1 metric ton (1000 kg). kg\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6367},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1710473,"byte_end":1710484,"line_start":177,"line_end":177,"column_start":12,"column_end":23},"name":"MKSA_UK_TON","qualname":"::physical_constant::MKSA_UK_TON","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The mass of 1 UK ton. kg\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6368},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1710553,"byte_end":1710568,"line_start":179,"line_end":179,"column_start":12,"column_end":27},"name":"MKSA_TROY_OUNCE","qualname":"::physical_constant::MKSA_TROY_OUNCE","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The mass of 1 troy ounce. kg\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6369},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1710630,"byte_end":1710640,"line_start":181,"line_end":181,"column_start":12,"column_end":22},"name":"MKSA_CARAT","qualname":"::physical_constant::MKSA_CARAT","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The mass of 1 carat. kg\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6370},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1710709,"byte_end":1710724,"line_start":183,"line_end":183,"column_start":12,"column_end":27},"name":"MKSA_GRAM_FORCE","qualname":"::physical_constant::MKSA_GRAM_FORCE","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The force of 1 gram weight. kg m / s^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6371},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1710800,"byte_end":1710816,"line_start":185,"line_end":185,"column_start":12,"column_end":28},"name":"MKSA_POUND_FORCE","qualname":"::physical_constant::MKSA_POUND_FORCE","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The force of 1 pound weight. kg m / s^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6372},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1710901,"byte_end":1710921,"line_start":187,"line_end":187,"column_start":12,"column_end":32},"name":"MKSA_KILOPOUND_FORCE","qualname":"::physical_constant::MKSA_KILOPOUND_FORCE","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The force of 1 kilopound weight. kg m / s^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6373},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1710997,"byte_end":1711009,"line_start":189,"line_end":189,"column_start":12,"column_end":24},"name":"MKSA_POUNDAL","qualname":"::physical_constant::MKSA_POUNDAL","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The force of 1 poundal. kg m / s^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6374},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1711112,"byte_end":1711124,"line_start":193,"line_end":193,"column_start":12,"column_end":24},"name":"MKSA_CALORIE","qualname":"::physical_constant::MKSA_CALORIE","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The energy of 1 calorie. kg m^2 / s^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6375},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1711214,"byte_end":1711222,"line_start":195,"line_end":195,"column_start":12,"column_end":20},"name":"MKSA_BTU","qualname":"::physical_constant::MKSA_BTU","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The energy of 1 British Thermal Unit, btu. kg m^2 / s^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6376},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1711299,"byte_end":1711309,"line_start":197,"line_end":197,"column_start":12,"column_end":22},"name":"MKSA_THERM","qualname":"::physical_constant::MKSA_THERM","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The energy of 1 Therm. kg m^2 / s^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6377},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1711384,"byte_end":1711399,"line_start":199,"line_end":199,"column_start":12,"column_end":27},"name":"MKSA_HORSEPOWER","qualname":"::physical_constant::MKSA_HORSEPOWER","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The power of 1 horsepower. kg m^2 / s^3\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6378},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1711479,"byte_end":1711487,"line_start":203,"line_end":203,"column_start":12,"column_end":20},"name":"MKSA_BAR","qualname":"::physical_constant::MKSA_BAR","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The pressure of 1 bar. kg / m s^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6379},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1711566,"byte_end":1711585,"line_start":205,"line_end":205,"column_start":12,"column_end":31},"name":"MKSA_STD_ATMOSPHERE","qualname":"::physical_constant::MKSA_STD_ATMOSPHERE","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The pressure of 1 standard atmosphere. kg / m s^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6380},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1711655,"byte_end":1711664,"line_start":207,"line_end":207,"column_start":12,"column_end":21},"name":"MKSA_TORR","qualname":"::physical_constant::MKSA_TORR","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The pressure of 1 torr. kg / m s^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6381},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1711752,"byte_end":1711773,"line_start":209,"line_end":209,"column_start":12,"column_end":33},"name":"MKSA_METER_OF_MERCURY","qualname":"::physical_constant::MKSA_METER_OF_MERCURY","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The pressure of 1 meter of mercury. kg / m s^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6382},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1711860,"byte_end":1711880,"line_start":211,"line_end":211,"column_start":12,"column_end":32},"name":"MKSA_INCH_OF_MERCURY","qualname":"::physical_constant::MKSA_INCH_OF_MERCURY","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The pressure of 1 inch of mercury. kg / m s^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6383},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1711965,"byte_end":1711983,"line_start":213,"line_end":213,"column_start":12,"column_end":30},"name":"MKSA_INCH_OF_WATER","qualname":"::physical_constant::MKSA_INCH_OF_WATER","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The pressure of 1 inch of water. kg / m s^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6384},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1712071,"byte_end":1712079,"line_start":215,"line_end":215,"column_start":12,"column_end":20},"name":"MKSA_PSI","qualname":"::physical_constant::MKSA_PSI","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The pressure of 1 pound per square inch. kg / m s^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6385},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1712181,"byte_end":1712191,"line_start":219,"line_end":219,"column_start":12,"column_end":22},"name":"MKSA_POISE","qualname":"::physical_constant::MKSA_POISE","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The dynamic viscosity of 1 poise. kg m^-1 s^-1\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6386},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1712266,"byte_end":1712277,"line_start":221,"line_end":221,"column_start":12,"column_end":23},"name":"MKSA_STOKES","qualname":"::physical_constant::MKSA_STOKES","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The kinematic viscosity of 1 stokes. m^2 / s\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6387},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1712369,"byte_end":1712379,"line_start":225,"line_end":225,"column_start":12,"column_end":22},"name":"MKSA_STILB","qualname":"::physical_constant::MKSA_STILB","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The luminance of 1 stilb. cd / m^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6388},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1712444,"byte_end":1712454,"line_start":227,"line_end":227,"column_start":12,"column_end":22},"name":"MKSA_LUMEN","qualname":"::physical_constant::MKSA_LUMEN","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The luminous flux of 1 lumen. cd sr\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6389},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1712521,"byte_end":1712529,"line_start":229,"line_end":229,"column_start":12,"column_end":20},"name":"MKSA_LUX","qualname":"::physical_constant::MKSA_LUX","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The illuminance of 1 lux. cd sr / m^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6390},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1712597,"byte_end":1712606,"line_start":231,"line_end":231,"column_start":12,"column_end":21},"name":"MKSA_PHOT","qualname":"::physical_constant::MKSA_PHOT","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The illuminance of 1 phot. cd sr / m^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6391},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1712680,"byte_end":1712695,"line_start":233,"line_end":233,"column_start":12,"column_end":27},"name":"MKSA_FOOTCANDLE","qualname":"::physical_constant::MKSA_FOOTCANDLE","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The illuminance of 1 footcandle. cd sr / m^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6392},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1712768,"byte_end":1712780,"line_start":235,"line_end":235,"column_start":12,"column_end":24},"name":"MKSA_LAMBERT","qualname":"::physical_constant::MKSA_LAMBERT","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The luminance of 1 lambert. cd sr / m^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6393},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1712853,"byte_end":1712869,"line_start":237,"line_end":237,"column_start":12,"column_end":28},"name":"MKSA_FOOTLAMBERT","qualname":"::physical_constant::MKSA_FOOTLAMBERT","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The luminance of 1 footlambert. cd sr / m^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6394},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1712956,"byte_end":1712966,"line_start":241,"line_end":241,"column_start":12,"column_end":22},"name":"MKSA_CURIE","qualname":"::physical_constant::MKSA_CURIE","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The activity of 1 curie. 1 / s\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6395},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1713035,"byte_end":1713048,"line_start":243,"line_end":243,"column_start":12,"column_end":25},"name":"MKSA_ROENTGEN","qualname":"::physical_constant::MKSA_ROENTGEN","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The exposure of 1 roentgen. A s / kg\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6396},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1713119,"byte_end":1713127,"line_start":245,"line_end":245,"column_start":12,"column_end":20},"name":"MKSA_RAD","qualname":"::physical_constant::MKSA_RAD","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The absorbed dose of 1 rad. m^2 / s^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6397},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1713221,"byte_end":1713232,"line_start":249,"line_end":249,"column_start":12,"column_end":23},"name":"MKSA_NEWTON","qualname":"::physical_constant::MKSA_NEWTON","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The SI unit of force, 1 Newton. kg m / s^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6398},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1713308,"byte_end":1713317,"line_start":251,"line_end":251,"column_start":12,"column_end":21},"name":"MKSA_DYNE","qualname":"::physical_constant::MKSA_DYNE","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The force of 1 Dyne = 10^-5 Newton. kg m / s^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6399},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1713392,"byte_end":1713402,"line_start":253,"line_end":253,"column_start":12,"column_end":22},"name":"MKSA_JOULE","qualname":"::physical_constant::MKSA_JOULE","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The SI unit of energy, 1 Joule. kg m^2 / s^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6400},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1713476,"byte_end":1713484,"line_start":255,"line_end":255,"column_start":12,"column_end":20},"name":"MKSA_ERG","qualname":"::physical_constant::MKSA_ERG","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The energy 1 erg = 10^-7 Joule. kg m^2 / s^2\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6401},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1713586,"byte_end":1713595,"line_start":259,"line_end":259,"column_start":12,"column_end":21},"name":"NUM_YOTTA","qualname":"::physical_constant::NUM_YOTTA","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" 10^24\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6402},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1713631,"byte_end":1713640,"line_start":261,"line_end":261,"column_start":12,"column_end":21},"name":"NUM_ZETTA","qualname":"::physical_constant::NUM_ZETTA","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" 10^21\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6403},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1713676,"byte_end":1713683,"line_start":263,"line_end":263,"column_start":12,"column_end":19},"name":"NUM_EXA","qualname":"::physical_constant::NUM_EXA","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" 10^18\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6404},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1713719,"byte_end":1713727,"line_start":265,"line_end":265,"column_start":12,"column_end":20},"name":"NUM_PETA","qualname":"::physical_constant::NUM_PETA","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" 10^15\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6405},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1713763,"byte_end":1713771,"line_start":267,"line_end":267,"column_start":12,"column_end":20},"name":"NUM_TERA","qualname":"::physical_constant::NUM_TERA","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" 10^12\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6406},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1713806,"byte_end":1713814,"line_start":269,"line_end":269,"column_start":12,"column_end":20},"name":"NUM_GIGA","qualname":"::physical_constant::NUM_GIGA","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" 10^9\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6407},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1713848,"byte_end":1713856,"line_start":271,"line_end":271,"column_start":12,"column_end":20},"name":"NUM_MEGA","qualname":"::physical_constant::NUM_MEGA","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" 10^6\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6408},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1713890,"byte_end":1713898,"line_start":273,"line_end":273,"column_start":12,"column_end":20},"name":"NUM_KILO","qualname":"::physical_constant::NUM_KILO","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" 10^3\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6409},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1713933,"byte_end":1713942,"line_start":275,"line_end":275,"column_start":12,"column_end":21},"name":"NUM_MILLI","qualname":"::physical_constant::NUM_MILLI","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" 10^-3\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6410},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1713978,"byte_end":1713987,"line_start":277,"line_end":277,"column_start":12,"column_end":21},"name":"NUM_MICRO","qualname":"::physical_constant::NUM_MICRO","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" 10^-6\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6411},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1714023,"byte_end":1714031,"line_start":279,"line_end":279,"column_start":12,"column_end":20},"name":"NUM_NANO","qualname":"::physical_constant::NUM_NANO","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" 10^-9\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6412},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1714068,"byte_end":1714076,"line_start":281,"line_end":281,"column_start":12,"column_end":20},"name":"NUM_PICO","qualname":"::physical_constant::NUM_PICO","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" 10^-12\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6413},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1714114,"byte_end":1714123,"line_start":283,"line_end":283,"column_start":12,"column_end":21},"name":"NUM_FEMTO","qualname":"::physical_constant::NUM_FEMTO","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" 10^-15\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6414},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1714161,"byte_end":1714169,"line_start":285,"line_end":285,"column_start":12,"column_end":20},"name":"NUM_ATTO","qualname":"::physical_constant::NUM_ATTO","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" 10^-18\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6415},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1714207,"byte_end":1714216,"line_start":287,"line_end":287,"column_start":12,"column_end":21},"name":"NUM_ZEPTO","qualname":"::physical_constant::NUM_ZEPTO","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" 10^-21\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6416},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/physical_constant.rs","byte_start":1714254,"byte_end":1714263,"line_start":289,"line_end":289,"column_start":12,"column_end":21},"name":"NUM_YOCTO","qualname":"::physical_constant::NUM_YOCTO","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" 10^-24\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6417},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/polynomials.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"polynomials","qualname":"::polynomials","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/polynomials.rs","parent":null,"children":[{"krate":0,"index":6418},{"krate":0,"index":6427},{"krate":0,"index":6434},{"krate":0,"index":6440}],"decl_id":null,"docs":"#Polynomials","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6418},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/polynomials.rs","byte_start":1715699,"byte_end":1715709,"line_start":28,"line_end":28,"column_start":9,"column_end":19},"name":"evaluation","qualname":"::polynomials::evaluation","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/polynomials.rs","parent":null,"children":[{"krate":0,"index":6419},{"krate":0,"index":6420},{"krate":0,"index":6421},{"krate":0,"index":6422},{"krate":0,"index":6423},{"krate":0,"index":6424},{"krate":0,"index":6425},{"krate":0,"index":6426}],"decl_id":null,"docs":" The functions described here evaluate the polynomial\n `P(x) = c[0] + c[1] x + c[2] x^2 + \\dots + c[len-1] x^{len-1}` using Horner’s method for\n stability.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6423},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/polynomials.rs","byte_start":1715901,"byte_end":1715910,"line_start":35,"line_end":35,"column_start":12,"column_end":21},"name":"poly_eval","qualname":"::polynomials::evaluation::poly_eval","value":"fn (c: &[f64], x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function evaluates a polynomial with real coefficients for the real variable x.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6424},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/polynomials.rs","byte_start":1716122,"byte_end":1716139,"line_start":40,"line_end":40,"column_start":12,"column_end":29},"name":"poly_complex_eval","qualname":"::polynomials::evaluation::poly_complex_eval","value":"fn (c: &[f64], z: &ComplexF64) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function evaluates a polynomial with real coefficients for the complex variable z.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6425},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/polynomials.rs","byte_start":1716400,"byte_end":1716425,"line_start":45,"line_end":45,"column_start":12,"column_end":37},"name":"complex_poly_complex_eval","qualname":"::polynomials::evaluation::complex_poly_complex_eval","value":"fn (c: &[ComplexF64], z: &ComplexF64) -> ComplexF64","parent":null,"children":[],"decl_id":null,"docs":" This function evaluates a polynomial with complex coefficients for the complex variable z.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6426},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/polynomials.rs","byte_start":1716957,"byte_end":1716973,"line_start":56,"line_end":56,"column_start":12,"column_end":28},"name":"poly_eval_derivs","qualname":"::polynomials::evaluation::poly_eval_derivs","value":"fn (c: &[f64], x: f64, res: &mut [f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function evaluates a polynomial and its derivatives storing the results in the array res of size lenres. The output array contains\n the values of d^k P/d x^k for the specified value of x starting with k = 0.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6427},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/polynomials.rs","byte_start":1718469,"byte_end":1718502,"line_start":79,"line_end":79,"column_start":9,"column_end":42},"name":"divided_difference_representation","qualname":"::polynomials::divided_difference_representation","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/polynomials.rs","parent":null,"children":[{"krate":0,"index":6428},{"krate":0,"index":6429},{"krate":0,"index":6430},{"krate":0,"index":6431},{"krate":0,"index":6432},{"krate":0,"index":6433}],"decl_id":null,"docs":" The functions described here manipulate polynomials stored in Newton’s divided-difference representation. The use of divided-differences\n is described in Abramowitz & Stegun sections 25.1.4 and 25.2.26, and Burden and Faires, chapter 3, and discussed briefly below.\n \n Given a function f(x), an nth degree interpolating polynomial P_{n}(x) can be constructed which agrees with f at n+1 distinct points x_0,\n x_1,...,x_{n}. This polynomial can be written in a form known as Newton’s divided-difference representation:\n \n P_n(x) = f(x_0) + \\sum_(k=1)^n [x_0,x_1,...,x_k] (x-x_0)(x-x_1)...(x-x_(k-1))\n \n where the divided differences [x_0,x_1,...,x_k] are defined in section 25.1.4 of Abramowitz and Stegun. Additionally, it is possible to\n construct an interpolating polynomial of degree 2n+1 which also matches the first derivatives of f at the points x_0,x_1,...,x_n. This is\n called the Hermite interpolating polynomial and is defined as\n \n H_(2n+1)(x) = f(z_0) + \\sum_(k=1)^(2n+1) [z_0,z_1,...,z_k] (x-z_0)(x-z_1)...(x-z_(k-1))\n \n where the elements of z = \\{x_0,x_0,x_1,x_1,...,x_n,x_n\\} are defined by z_{2k} = z_{2k+1} = x_k. The divided-differences [z_0,z_1,...,z_k]\n are discussed in Burden and Faires, section 3.4.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6430},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/polynomials.rs","byte_start":1718876,"byte_end":1718888,"line_start":86,"line_end":86,"column_start":12,"column_end":24},"name":"poly_dd_init","qualname":"::polynomials::divided_difference_representation::poly_dd_init","value":"fn (dd: &mut [f64], xa: &[f64], ya: &[f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes a divided-difference representation of the interpolating polynomial for the points (x, y) stored in the arrays\n xa and ya of length size. On output the divided-differences of (xa,ya) are stored in the array dd, also of length size. Using the\n notation above, dd[k] = [x_0,x_1,...,x_k].\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6431},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/polynomials.rs","byte_start":1719240,"byte_end":1719252,"line_start":93,"line_end":93,"column_start":12,"column_end":24},"name":"poly_dd_eval","qualname":"::polynomials::divided_difference_representation::poly_dd_eval","value":"fn (dd: &[f64], xa: &[f64], x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function evaluates the polynomial stored in divided-difference form in the arrays dd and xa of length size at the point x.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6432},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/polynomials.rs","byte_start":1719798,"byte_end":1719812,"line_start":100,"line_end":100,"column_start":12,"column_end":26},"name":"poly_dd_taylor","qualname":"::polynomials::divided_difference_representation::poly_dd_taylor","value":"fn (c: &mut [f64], xp: f64, dd: &[f64], xa: &[f64], w: &mut [f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function converts the divided-difference representation of a polynomial to a Taylor expansion. The divided-difference representation\n is supplied in the arrays dd and xa of length size. On output the Taylor coefficients of the polynomial expanded about the point xp are\n stored in the array c also of length size. A workspace of length size must be provided in the array w.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6433},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/polynomials.rs","byte_start":1721060,"byte_end":1721080,"line_start":116,"line_end":116,"column_start":12,"column_end":32},"name":"poly_dd_hermite_init","qualname":"::polynomials::divided_difference_representation::poly_dd_hermite_init","value":"fn (dd: &mut [f64], za: &mut [f64], xa: &[f64], ya: &[f64], dya: &[f64]) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function computes a divided-difference representation of the interpolating Hermite polynomial for the points (x, y) stored in the\n arrays xa and ya of length size. Hermite interpolation constructs polynomials which also match first derivatives dy/dx which are provided\n in the array dya also of length size. The first derivatives can be incorported into the usual divided-difference algorithm by forming a\n new dataset z = \\{x_0,x_0,x_1,x_1,...\\}, which is stored in the array za of length 2*size on output. On output the divided-differences\n of the Hermite representation are stored in the array dd, also of length 2*size. Using the notation above, dd[k] = [z_0,z_1,...,z_k].\n The resulting Hermite polynomial can be evaluated by calling gsl_poly_dd_eval and using za for the input argument xa.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6434},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/polynomials.rs","byte_start":1721620,"byte_end":1721639,"line_start":134,"line_end":134,"column_start":9,"column_end":28},"name":"quadratic_equations","qualname":"::polynomials::quadratic_equations","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/polynomials.rs","parent":null,"children":[{"krate":0,"index":6435},{"krate":0,"index":6436},{"krate":0,"index":6437},{"krate":0,"index":6438},{"krate":0,"index":6439}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6438},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/polynomials.rs","byte_start":1722795,"byte_end":1722815,"line_start":152,"line_end":152,"column_start":12,"column_end":32},"name":"poly_solve_quadratic","qualname":"::polynomials::quadratic_equations::poly_solve_quadratic","value":"fn (a: f64, b: f64, c: f64, x0: &mut f64, x1: &mut f64) -> i32","parent":null,"children":[],"decl_id":null,"docs":" This function finds the real roots of the quadratic equation,\n \n a x^2 + b x + c = 0\n \n The number of real roots (either zero, one or two) is returned, and their locations are stored in x0 and x1. If no real roots are found\n then x0 and x1 are not modified. If one real root is found (i.e. if a=0) then it is stored in x0. When two real roots are found they\n are stored in x0 and x1 in ascending order. The case of coincident roots is not considered special. For example (x-1)^2=0 will have\n two roots, which happen to have exactly equal values.\n \n The number of roots found depends on the sign of the discriminant b^2 - 4 a c. This will be subject to rounding and cancellation errors\n when computed in double precision, and will also be subject to errors if the coefficients of the polynomial are inexact. These errors\n may cause a discrete change in the number of roots. However, for polynomials with small integer coefficients the discriminant can always\n be computed exactly.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6439},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/polynomials.rs","byte_start":1723411,"byte_end":1723439,"line_start":163,"line_end":163,"column_start":12,"column_end":40},"name":"poly_complex_solve_quadratic","qualname":"::polynomials::quadratic_equations::poly_complex_solve_quadratic","value":"fn (a: f64, b: f64, c: f64, z0: &mut ComplexF64, z1: &mut ComplexF64) -> i32","parent":null,"children":[],"decl_id":null,"docs":" This function finds the complex roots of the quadratic equation,\n \n a z^2 + b z + c = 0\n \n The number of complex roots is returned (either one or two) and the locations of the roots are stored in z0 and z1. The roots are returned\n in ascending order, sorted first by their real components and then by their imaginary components. If only one real root is found (i.e. if\n a=0) then it is stored in z0.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6440},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/polynomials.rs","byte_start":1723628,"byte_end":1723643,"line_start":168,"line_end":168,"column_start":9,"column_end":24},"name":"cubic_equations","qualname":"::polynomials::cubic_equations","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/polynomials.rs","parent":null,"children":[{"krate":0,"index":6441},{"krate":0,"index":6442},{"krate":0,"index":6443},{"krate":0,"index":6444},{"krate":0,"index":6445}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6444},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/polynomials.rs","byte_start":1724505,"byte_end":1724521,"line_start":182,"line_end":182,"column_start":12,"column_end":28},"name":"poly_solve_cubic","qualname":"::polynomials::cubic_equations::poly_solve_cubic","value":"fn (a: f64, b: f64, c: f64, x0: &mut f64, x1: &mut f64, x2: &mut f64) -> i32","parent":null,"children":[],"decl_id":null,"docs":" This function finds the real roots of the cubic equation,\n \n x^3 + a x^2 + b x + c = 0\n \n with a leading coefficient of unity. The number of real roots (either one or three) is returned, and their locations are stored in x0,\n x1 and x2. If one real root is found then only x0 is modified. When three real roots are found they are stored in x0, x1 and x2 in\n ascending order. The case of coincident roots is not considered special. For example, the equation (x-1)^3=0 will have three roots\n with exactly equal values. As in the quadratic case, finite precision may cause equal or closely-spaced real roots to move off the\n real axis into the complex plane, leading to a discrete change in the number of real roots.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6445},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/polynomials.rs","byte_start":1725054,"byte_end":1725078,"line_start":192,"line_end":192,"column_start":12,"column_end":36},"name":"poly_complex_solve_cubic","qualname":"::polynomials::cubic_equations::poly_complex_solve_cubic","value":"fn (a: f64, b: f64, c: f64, z0: &mut ComplexF64, z1: &mut ComplexF64, z2: &mut ComplexF64) -> i32","parent":null,"children":[],"decl_id":null,"docs":" This function finds the complex roots of the cubic equation,\n \n z^3 + a z^2 + b z + c = 0\n \n The number of complex roots is returned (always three) and the locations of the roots are stored in z0, z1 and z2. The roots are returned\n in ascending order, sorted first by their real components and then by their imaginary components.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6446},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/pow.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"pow","qualname":"::pow","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/pow.rs","parent":null,"children":[{"krate":0,"index":6447},{"krate":0,"index":6458}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Trait","id":{"krate":0,"index":6447},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/pow.rs","byte_start":1725394,"byte_end":1725397,"line_start":5,"line_end":5,"column_start":11,"column_end":14},"name":"Pow","qualname":"::pow::Pow","value":"Pow","parent":null,"children":[{"krate":0,"index":6448},{"krate":0,"index":6449},{"krate":0,"index":6450},{"krate":0,"index":6451},{"krate":0,"index":6452},{"krate":0,"index":6453},{"krate":0,"index":6454},{"krate":0,"index":6455},{"krate":0,"index":6456},{"krate":0,"index":6457}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6448},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/pow.rs","byte_start":1725704,"byte_end":1725711,"line_start":8,"line_end":8,"column_start":8,"column_end":15},"name":"pow_int","qualname":"::pow::Pow::pow_int","value":"fn (&self, n: i32) -> Self","parent":{"krate":0,"index":6447},"children":[],"decl_id":null,"docs":" This routine computes the power x^n for integer n. The power is computed efficiently—for example, x^8 is computed as ((x^2)^2)^2, requiring only 3 multiplications.\n A version of this function which also computes the numerical error in the result is available as gsl_sf_pow_int_e.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6449},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/pow.rs","byte_start":1726040,"byte_end":1726048,"line_start":11,"line_end":11,"column_start":8,"column_end":16},"name":"pow_uint","qualname":"::pow::Pow::pow_uint","value":"fn (&self, n: u32) -> Self","parent":{"krate":0,"index":6447},"children":[],"decl_id":null,"docs":" This routine computes the power x^n for integer n. The power is computed efficiently—for example, x^8 is computed as ((x^2)^2)^2, requiring only 3 multiplications.\n A version of this function which also computes the numerical error in the result is available as gsl_sf_pow_int_e.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6450},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/pow.rs","byte_start":1726174,"byte_end":1726178,"line_start":13,"line_end":13,"column_start":8,"column_end":12},"name":"pow2","qualname":"::pow::Pow::pow2","value":"fn (&self) -> Self","parent":{"krate":0,"index":6447},"children":[],"decl_id":null,"docs":" This function can be used to compute small integer powers x^2, x^3, etc. efficiently.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6451},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/pow.rs","byte_start":1726296,"byte_end":1726300,"line_start":15,"line_end":15,"column_start":8,"column_end":12},"name":"pow3","qualname":"::pow::Pow::pow3","value":"fn (&self) -> Self","parent":{"krate":0,"index":6447},"children":[],"decl_id":null,"docs":" This function can be used to compute small integer powers x^2, x^3, etc. efficiently.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6452},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/pow.rs","byte_start":1726418,"byte_end":1726422,"line_start":17,"line_end":17,"column_start":8,"column_end":12},"name":"pow4","qualname":"::pow::Pow::pow4","value":"fn (&self) -> Self","parent":{"krate":0,"index":6447},"children":[],"decl_id":null,"docs":" This function can be used to compute small integer powers x^2, x^3, etc. efficiently.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6453},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/pow.rs","byte_start":1726540,"byte_end":1726544,"line_start":19,"line_end":19,"column_start":8,"column_end":12},"name":"pow5","qualname":"::pow::Pow::pow5","value":"fn (&self) -> Self","parent":{"krate":0,"index":6447},"children":[],"decl_id":null,"docs":" This function can be used to compute small integer powers x^2, x^3, etc. efficiently.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6454},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/pow.rs","byte_start":1726662,"byte_end":1726666,"line_start":21,"line_end":21,"column_start":8,"column_end":12},"name":"pow6","qualname":"::pow::Pow::pow6","value":"fn (&self) -> Self","parent":{"krate":0,"index":6447},"children":[],"decl_id":null,"docs":" This function can be used to compute small integer powers x^2, x^3, etc. efficiently.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6455},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/pow.rs","byte_start":1726784,"byte_end":1726788,"line_start":23,"line_end":23,"column_start":8,"column_end":12},"name":"pow7","qualname":"::pow::Pow::pow7","value":"fn (&self) -> Self","parent":{"krate":0,"index":6447},"children":[],"decl_id":null,"docs":" This function can be used to compute small integer powers x^2, x^3, etc. efficiently.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6456},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/pow.rs","byte_start":1726906,"byte_end":1726910,"line_start":25,"line_end":25,"column_start":8,"column_end":12},"name":"pow8","qualname":"::pow::Pow::pow8","value":"fn (&self) -> Self","parent":{"krate":0,"index":6447},"children":[],"decl_id":null,"docs":" This function can be used to compute small integer powers x^2, x^3, etc. efficiently.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6457},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/pow.rs","byte_start":1727028,"byte_end":1727032,"line_start":27,"line_end":27,"column_start":8,"column_end":12},"name":"pow9","qualname":"::pow::Pow::pow9","value":"fn (&self) -> Self","parent":{"krate":0,"index":6447},"children":[],"decl_id":null,"docs":" This function can be used to compute small integer powers x^2, x^3, etc. efficiently.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6469},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/power.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"power","qualname":"::power","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/power.rs","parent":null,"children":[{"krate":0,"index":6470},{"krate":0,"index":6471},{"krate":0,"index":6472},{"krate":0,"index":6473},{"krate":0,"index":6474}],"decl_id":null,"docs":" The following functions are equivalent to the function gsl_pow_int (see [1Small integer powers1](Pow.html)) with an error estimate.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6473},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/power.rs","byte_start":1728582,"byte_end":1728589,"line_start":20,"line_end":20,"column_start":8,"column_end":15},"name":"pow_int","qualname":"::power::pow_int","value":"fn (x: f64, n: i32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the power x^n for integer n. The power is computed using the minimum number of multiplications.\n For example, x^8 is computed as ((x^2)^2)^2, requiring only 3 multiplications.\n For reasons of efficiency, these functions do not check for overflow or underflow conditions.\n \n ```Rust\n use rgsl::power;\n /* compute 3.0**12 */\n double y = gsl_sf_pow_int(3.0, 12);\n ```\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6474},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/power.rs","byte_start":1729081,"byte_end":1729090,"line_start":33,"line_end":33,"column_start":8,"column_end":17},"name":"pow_int_e","qualname":"::power::pow_int_e","value":"fn (x: f64, n: i32) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the power x^n for integer n. The power is computed using the minimum number of multiplications.\n For example, x^8 is computed as ((x^2)^2)^2, requiring only 3 multiplications.\n For reasons of efficiency, these functions do not check for overflow or underflow conditions.\n \n ```Rust\n use rgsl::power;\n /* compute 3.0**12 */\n double y = gsl_sf_pow_int(3.0, 12);\n ```\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6475},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/psi.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"psi","qualname":"::psi","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/psi.rs","parent":null,"children":[{"krate":0,"index":6476},{"krate":0,"index":6486},{"krate":0,"index":6494}],"decl_id":null,"docs":"The polygamma functions of order n are defined by","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6476},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/psi.rs","byte_start":1729657,"byte_end":1729665,"line_start":13,"line_end":13,"column_start":9,"column_end":17},"name":"diagamma","qualname":"::psi::diagamma","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/psi.rs","parent":null,"children":[{"krate":0,"index":6477},{"krate":0,"index":6478},{"krate":0,"index":6479},{"krate":0,"index":6480},{"krate":0,"index":6481},{"krate":0,"index":6482},{"krate":0,"index":6483},{"krate":0,"index":6484},{"krate":0,"index":6485}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6480},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/psi.rs","byte_start":1729871,"byte_end":1729878,"line_start":19,"line_end":19,"column_start":12,"column_end":19},"name":"psi_int","qualname":"::psi::diagamma::psi_int","value":"fn (n: i32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the digamma function \\psi(n) for positive integer n. The digamma function is also called the Psi function.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6481},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/psi.rs","byte_start":1730093,"byte_end":1730102,"line_start":24,"line_end":24,"column_start":12,"column_end":21},"name":"psi_int_e","qualname":"::psi::diagamma::psi_int_e","value":"fn (n: i32) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the digamma function \\psi(n) for positive integer n. The digamma function is also called the Psi function.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6482},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/psi.rs","byte_start":1730471,"byte_end":1730474,"line_start":32,"line_end":32,"column_start":12,"column_end":15},"name":"psi","qualname":"::psi::diagamma::psi","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the digamma function \\psi(x) for general x, x \\ne 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6483},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/psi.rs","byte_start":1730631,"byte_end":1730636,"line_start":37,"line_end":37,"column_start":12,"column_end":17},"name":"psi_e","qualname":"::psi::diagamma::psi_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the digamma function \\psi(x) for general x, x \\ne 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6484},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/psi.rs","byte_start":1731025,"byte_end":1731033,"line_start":45,"line_end":45,"column_start":12,"column_end":20},"name":"psi_1piy","qualname":"::psi::diagamma::psi_1piy","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the real part of the digamma function on the line 1+i y, \\Re[\\psi(1 + i y)].\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6485},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/psi.rs","byte_start":1731219,"byte_end":1731229,"line_start":50,"line_end":50,"column_start":12,"column_end":22},"name":"psi_1piy_e","qualname":"::psi::diagamma::psi_1piy_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the real part of the digamma function on the line 1+i y, \\Re[\\psi(1 + i y)].\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6486},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/psi.rs","byte_start":1731515,"byte_end":1731523,"line_start":58,"line_end":58,"column_start":9,"column_end":17},"name":"trigamma","qualname":"::psi::trigamma","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/psi.rs","parent":null,"children":[{"krate":0,"index":6487},{"krate":0,"index":6488},{"krate":0,"index":6489},{"krate":0,"index":6490},{"krate":0,"index":6491},{"krate":0,"index":6492},{"krate":0,"index":6493}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6490},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/psi.rs","byte_start":1731677,"byte_end":1731686,"line_start":64,"line_end":64,"column_start":12,"column_end":21},"name":"psi_1_int","qualname":"::psi::trigamma::psi_1_int","value":"fn (n: i32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Trigamma function \\psi'(n) for positive integer n.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6491},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/psi.rs","byte_start":1731851,"byte_end":1731862,"line_start":69,"line_end":69,"column_start":12,"column_end":23},"name":"psi_1_int_e","qualname":"::psi::trigamma::psi_1_int_e","value":"fn (n: i32) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Trigamma function \\psi'(n) for positive integer n.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6492},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/psi.rs","byte_start":1732226,"byte_end":1732231,"line_start":77,"line_end":77,"column_start":12,"column_end":17},"name":"psi_1","qualname":"::psi::trigamma::psi_1","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Trigamma function \\psi'(x) for general x.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6493},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/psi.rs","byte_start":1732383,"byte_end":1732390,"line_start":82,"line_end":82,"column_start":12,"column_end":19},"name":"psi_1_e","qualname":"::psi::trigamma::psi_1_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Trigamma function \\psi'(x) for general x.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6494},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/psi.rs","byte_start":1732673,"byte_end":1732682,"line_start":90,"line_end":90,"column_start":9,"column_end":18},"name":"polygamma","qualname":"::psi::polygamma","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/psi.rs","parent":null,"children":[{"krate":0,"index":6495},{"krate":0,"index":6496},{"krate":0,"index":6497},{"krate":0,"index":6498},{"krate":0,"index":6499}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6498},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/psi.rs","byte_start":1732837,"byte_end":1732842,"line_start":96,"line_end":96,"column_start":12,"column_end":17},"name":"psi_n","qualname":"::psi::polygamma::psi_n","value":"fn (n: i32, x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the polygamma function \\psi^{(n)}(x) for n >= 0, x > 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6499},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/psi.rs","byte_start":1733015,"byte_end":1733022,"line_start":101,"line_end":101,"column_start":12,"column_end":19},"name":"psi_n_e","qualname":"::psi::polygamma::psi_n_e","value":"fn (n: i32, x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the polygamma function \\psi^{(n)}(x) for n >= 0, x > 0.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6500},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/roots.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"roots","qualname":"::roots","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/roots.rs","parent":null,"children":[{"krate":0,"index":6501},{"krate":0,"index":6502},{"krate":0,"index":6503},{"krate":0,"index":6504}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6502},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/roots.rs","byte_start":1733418,"byte_end":1733431,"line_start":7,"line_end":7,"column_start":8,"column_end":21},"name":"test_interval","qualname":"::roots::test_interval","value":"fn (x_lower: f64, x_upper: f64, epsabs: f64, epsrel: f64) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6503},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/roots.rs","byte_start":1733613,"byte_end":1733626,"line_start":13,"line_end":13,"column_start":8,"column_end":21},"name":"test_residual","qualname":"::roots::test_residual","value":"fn (f: f64, epsabs: f64) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6504},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/roots.rs","byte_start":1733752,"byte_end":1733762,"line_start":19,"line_end":19,"column_start":8,"column_end":18},"name":"test_delta","qualname":"::roots::test_delta","value":"fn (x1: f64, x0: f64, epsabs: f64, epsrel: f64) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6505},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/sort.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"sort","qualname":"::sort","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/sort.rs","parent":null,"children":[{"krate":0,"index":6506},{"krate":0,"index":6515},{"krate":0,"index":6527}],"decl_id":null,"docs":"#Sorting","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6506},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/sort.rs","byte_start":1735528,"byte_end":1735535,"line_start":29,"line_end":29,"column_start":9,"column_end":16},"name":"objects","qualname":"::sort::objects","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/sort.rs","parent":null,"children":[{"krate":0,"index":6507},{"krate":0,"index":6509},{"krate":0,"index":6511},{"krate":0,"index":6513}],"decl_id":null,"docs":" The following function provides a simple alternative to the standard library function qsort. It is intended for systems lacking qsort, not\n as a replacement for it. The function qsort should be used whenever possible, as it will be faster and can provide stable ordering of equal\n elements. Documentation for qsort is available in the GNU C Library Reference Manual.\n \n The functions described in this section are defined in the header file gsl_heapsort.h.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6507},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/sort.rs","byte_start":1736973,"byte_end":1736981,"line_start":62,"line_end":62,"column_start":12,"column_end":20},"name":"heapsort","qualname":"::sort::objects::heapsort","value":"fn <T> (array: &mut [T], compare: ::comparison_fn<T>) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function sorts the count elements of the array array, each of size size, into ascending order using the comparison function compare.\n The type of the comparison function is defined by,\n \n ```Rust\n i32 (*comparison_fn<T>) (a: &[T], b: &[T])\n ```\n \n A comparison function should return a negative integer if the first argument is less than the second argument, 0 if the two arguments\n are equal and a positive integer if the first argumentis greater than the second argument.\n \n For example, the following function can be used to sort doubles into ascending numerical order.\n \n ```Rust\n fn compare_doubles(a: &[f64], b: &[f64]) -> i32 {\n    if (a[0] > b[0])\n       return 1;\n    else if (a[0] < b[0])\n       return -1;\n    else\n       return 0;\n }\n ```\n \n The appropriate function call to perform the sort is,\n \n ```Rust\n heapsort(array, compare_doubles);\n ```\n \n Note that unlike qsort the heapsort algorithm cannot be made into a stable sort by pointer arithmetic. The trick of comparing pointers\n for equal elements in the comparison function does not work for the heapsort algorithm. The heapsort algorithm performs an internal\n rearrangement of the data which destroys its initial ordering.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6511},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/sort.rs","byte_start":1738525,"byte_end":1738539,"line_start":103,"line_end":103,"column_start":12,"column_end":26},"name":"heapsort_index","qualname":"::sort::objects::heapsort_index","value":"fn <T> (p: &mut [usize], array: &[T], compare: ::comparison_fn<T>) -> ::Value","parent":null,"children":[],"decl_id":null,"docs":" This function indirectly sorts the count elements of the array array, each of size size, into ascending order using the comparison\n function compare. The resulting permutation is stored in p, an array of length n. The elements of p give the index of the array element\n which would have been stored in that position if the array had been sorted in place. The first element of p gives the index of the\n least element in array, and the last element of p gives the index of the greatest element in array. The array itself is not changed.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6515},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/sort.rs","byte_start":1740740,"byte_end":1740747,"line_start":154,"line_end":154,"column_start":9,"column_end":16},"name":"vectors","qualname":"::sort::vectors","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/sort.rs","parent":null,"children":[{"krate":0,"index":6516},{"krate":0,"index":6517},{"krate":0,"index":6520},{"krate":0,"index":6521},{"krate":0,"index":6522},{"krate":0,"index":6523},{"krate":0,"index":6524},{"krate":0,"index":6525},{"krate":0,"index":6526}],"decl_id":null,"docs":" The following functions will sort the elements of an array or vector, either directly or indirectly. They are defined for all real and\n integer types using the normal suffix rules. For example, the float versions of the array functions are gsl_sort_float and gsl_sort_float_index.\n The corresponding vector functions are gsl_sort_vector_float and gsl_sort_vector_float_index. The prototypes are available in the header files\n gsl_sort_float.h gsl_sort_vector_float.h. The complete set of prototypes can be included using the header files gsl_sort.h and gsl_sort_vector.h.\n \n There are no functions for sorting complex arrays or vectors, since the ordering of complex numbers is not uniquely defined. To sort a complex\n vector by magnitude compute a real vector containing the magnitudes of the complex elements, and sort this vector indirectly. The resulting index\n gives the appropriate ordering of the original complex vector.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6521},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/sort.rs","byte_start":1740943,"byte_end":1740947,"line_start":160,"line_end":160,"column_start":12,"column_end":16},"name":"sort","qualname":"::sort::vectors::sort","value":"fn (data: &mut [f64], stride: usize, n: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function sorts the n elements of the array data with stride stride into ascending numerical order.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6522},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/sort.rs","byte_start":1741288,"byte_end":1741293,"line_start":166,"line_end":166,"column_start":12,"column_end":17},"name":"sort2","qualname":"::sort::vectors::sort2","value":"fn (data1: &mut [f64], stride1: usize, data2: &mut [f64], stride2: usize, n: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function sorts the n elements of the array data1 with stride stride1 into ascending numerical order, while making the same rearrangement\n of the array data2 with stride stride2, also of size n.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6523},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/sort.rs","byte_start":1741578,"byte_end":1741589,"line_start":171,"line_end":171,"column_start":12,"column_end":23},"name":"sort_vector","qualname":"::sort::vectors::sort_vector","value":"fn (v: &mut VectorF64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function sorts the elements of the vector v into ascending numerical order.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6524},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/sort.rs","byte_start":1741841,"byte_end":1741853,"line_start":176,"line_end":176,"column_start":12,"column_end":24},"name":"sort_vector2","qualname":"::sort::vectors::sort_vector2","value":"fn (v1: &mut VectorF64, v2: &mut VectorF64) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function sorts the elements of the vector v1 into ascending numerical order, while making the same rearrangement of the vector v2.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6525},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/sort.rs","byte_start":1742451,"byte_end":1742461,"line_start":183,"line_end":183,"column_start":12,"column_end":22},"name":"sort_index","qualname":"::sort::vectors::sort_index","value":"fn (p: &mut [usize], data: &[f64], stride: usize, n: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function indirectly sorts the n elements of the array data with stride stride into ascending order, storing the resulting\n permutation in p. The array p must be allocated with a sufficient length to store the n elements of the permutation. The elements of p\n give the index of the array element which would have been stored in that position if the array had been sorted in place. The array data is not changed.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6526},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/sort.rs","byte_start":1743073,"byte_end":1743090,"line_start":190,"line_end":190,"column_start":12,"column_end":29},"name":"sort_vector_index","qualname":"::sort::vectors::sort_vector_index","value":"fn (p: &mut Permutation, v: &VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function indirectly sorts the elements of the vector v into ascending order, storing the resulting permutation in p. The elements of p give the\n index of the vector element which would have been stored in that position if the vector had been sorted in place. The first element of p gives the index\n of the least element in v, and the last element of p gives the index of the greatest element in v. The vector v is not changed.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6527},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/sort.rs","byte_start":1743925,"byte_end":1743931,"line_start":201,"line_end":201,"column_start":9,"column_end":15},"name":"select","qualname":"::sort::select","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/sort.rs","parent":null,"children":[{"krate":0,"index":6528},{"krate":0,"index":6529},{"krate":0,"index":6530},{"krate":0,"index":6531},{"krate":0,"index":6532},{"krate":0,"index":6533},{"krate":0,"index":6534},{"krate":0,"index":6535},{"krate":0,"index":6536},{"krate":0,"index":6537},{"krate":0,"index":6538}],"decl_id":null,"docs":" The functions described in this section select the k smallest or largest elements of a data set of size N. The routines use an O(kN) direct insertion\n algorithm which is suited to subsets that are small compared with the total size of the dataset. For example, the routines are useful for selecting the\n 10 largest values from one million data points, but not for selecting the largest 100,000 values. If the subset is a significant part of the total dataset\n it may be faster to sort all the elements of the dataset directly with an O(N \\log N) algorithm and obtain the smallest or largest values that way.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6531},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/sort.rs","byte_start":1744264,"byte_end":1744277,"line_start":208,"line_end":208,"column_start":12,"column_end":25},"name":"sort_smallest","qualname":"::sort::select::sort_smallest","value":"fn (dest: &mut [f64], k: usize, src: &[f64], stride: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the k smallest elements of the array src, of size n and stride stride, in ascending numerical order into the array dest. The size\n k of the subset must be less than or equal to n. The data src is not modified by this operation.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6532},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/sort.rs","byte_start":1744753,"byte_end":1744765,"line_start":216,"line_end":216,"column_start":12,"column_end":24},"name":"sort_largest","qualname":"::sort::select::sort_largest","value":"fn (dest: &mut [f64], k: usize, src: &[f64], stride: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the k largest elements of the array src, of size n and stride stride, in descending numerical order into the array dest. k must\n be less than or equal to n. The data src is not modified by this operation.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6533},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/sort.rs","byte_start":1745160,"byte_end":1745180,"line_start":223,"line_end":223,"column_start":12,"column_end":32},"name":"sort_vector_smallest","qualname":"::sort::select::sort_vector_smallest","value":"fn (dest: &mut [f64], k: usize, v: &VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the k smallest or largest elements of the vector v into the array dest. k must be less than or equal to the length of the vector v.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6534},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/sort.rs","byte_start":1745560,"byte_end":1745579,"line_start":230,"line_end":230,"column_start":12,"column_end":31},"name":"sort_vector_largest","qualname":"::sort::select::sort_vector_largest","value":"fn (dest: &mut [f64], k: usize, v: &VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function copies the k smallest or largest elements of the vector v into the array dest. k must be less than or equal to the length of the vector v.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6535},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/sort.rs","byte_start":1746106,"byte_end":1746125,"line_start":238,"line_end":238,"column_start":12,"column_end":31},"name":"sort_smallest_index","qualname":"::sort::select::sort_smallest_index","value":"fn (p: &mut [usize], k: usize, src: &[f64], stride: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function stores the indices of the k smallest elements of the array src, of size n and stride stride, in the array p. The indices are chosen so that\n the corresponding data is in ascending numerical order. k must be less than or equal to n. The data src is not modified by this operation.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6536},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/sort.rs","byte_start":1746671,"byte_end":1746689,"line_start":246,"line_end":246,"column_start":12,"column_end":30},"name":"sort_largest_index","qualname":"::sort::select::sort_largest_index","value":"fn (p: &mut [usize], k: usize, src: &[f64], stride: usize) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function stores the indices of the k largest elements of the array src, of size n and stride stride, in the array p. The indices are chosen so that\n the corresponding data is in descending numerical order. k must be less than or equal to n. The data src is not modified by this operation.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6537},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/sort.rs","byte_start":1747104,"byte_end":1747130,"line_start":254,"line_end":254,"column_start":12,"column_end":38},"name":"sort_vector_smallest_index","qualname":"::sort::select::sort_vector_smallest_index","value":"fn (p: &mut [usize], k: usize, v: &VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function stores the indices of the k smallest or largest elements of the vector v in the array p. k must be less than or equal to the length of\n the vector v.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6538},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/sort.rs","byte_start":1747530,"byte_end":1747555,"line_start":262,"line_end":262,"column_start":12,"column_end":37},"name":"sort_vector_largest_index","qualname":"::sort::select::sort_vector_largest_index","value":"fn (p: &mut [usize], k: usize, v: &VectorF64) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" This function stores the indices of the k smallest or largest elements of the vector v in the array p. k must be less than or equal to the length of\n the vector v.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6539},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"statistics","qualname":"::statistics","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","parent":null,"children":[{"krate":0,"index":6540},{"krate":0,"index":6541},{"krate":0,"index":6542},{"krate":0,"index":6543},{"krate":0,"index":6544},{"krate":0,"index":6545},{"krate":0,"index":6546},{"krate":0,"index":6547},{"krate":0,"index":6548},{"krate":0,"index":6549},{"krate":0,"index":6550},{"krate":0,"index":6551},{"krate":0,"index":6552},{"krate":0,"index":6553},{"krate":0,"index":6554},{"krate":0,"index":6555},{"krate":0,"index":6556},{"krate":0,"index":6557},{"krate":0,"index":6558},{"krate":0,"index":6559},{"krate":0,"index":6560},{"krate":0,"index":6561},{"krate":0,"index":6562},{"krate":0,"index":6563},{"krate":0,"index":6564},{"krate":0,"index":6565},{"krate":0,"index":6566},{"krate":0,"index":6567},{"krate":0,"index":6568},{"krate":0,"index":6569},{"krate":0,"index":6570},{"krate":0,"index":6571},{"krate":0,"index":6572},{"krate":0,"index":6573},{"krate":0,"index":6574},{"krate":0,"index":6575},{"krate":0,"index":6576},{"krate":0,"index":6577},{"krate":0,"index":6578},{"krate":0,"index":6579},{"krate":0,"index":6580},{"krate":0,"index":6581},{"krate":0,"index":6582},{"krate":0,"index":6583},{"krate":0,"index":6584}],"decl_id":null,"docs":"#Statistics","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6541},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1750727,"byte_end":1750731,"line_start":55,"line_end":55,"column_start":8,"column_end":12},"name":"mean","qualname":"::statistics::mean","value":"fn (data: &[f64], stride: usize, n: usize) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the arithmetic mean of data, a dataset of length n with stride stride. The arithmetic mean, or sample mean, is\n denoted by \\Hat\\mu and defined as,\n \n \\Hat\\mu = (1/N) \\sum x_i\n \n where x_i are the elements of the dataset data. For samples drawn from a gaussian distribution the variance of \\Hat\\mu is \\sigma^2 / N.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6542},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1751580,"byte_end":1751588,"line_start":70,"line_end":70,"column_start":8,"column_end":16},"name":"variance","qualname":"::statistics::variance","value":"fn (data: &[f64], stride: usize, n: usize) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the estimated, or sample, variance of data, a dataset of length n with stride stride. The estimated variance is\n denoted by \\Hat\\sigma^2 and is defined by,\n \n \\Hat\\sigma^2 = (1/(N-1)) \\sum (x_i - \\Hat\\mu)^2\n \n where x_i are the elements of the dataset data. Note that the normalization factor of 1/(N-1) results from the derivation of\n \\Hat\\sigma^2 as an unbiased estimator of the population variance \\sigma^2. For samples drawn from a Gaussian distribution the\n variance of \\Hat\\sigma^2 itself is 2 \\sigma^4 / N.\n \n This function computes the mean via a call to gsl_stats_mean. If you have already computed the mean then you can pass it directly to\n gsl_stats_variance_m.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6543},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1751946,"byte_end":1751956,"line_start":78,"line_end":78,"column_start":8,"column_end":18},"name":"variance_m","qualname":"::statistics::variance_m","value":"fn (data: &[f64], stride: usize, n: usize, mean: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the sample variance of data relative to the given value of mean. The function is computed with \\Hat\\mu replaced\n by the value of mean that you supply,\n \n \\Hat\\sigma^2 = (1/(N-1)) \\sum (x_i - mean)^2\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6544},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1752262,"byte_end":1752264,"line_start":84,"line_end":84,"column_start":8,"column_end":10},"name":"sd","qualname":"::statistics::sd","value":"fn (data: &[f64], stride: usize, n: usize) -> f64","parent":null,"children":[],"decl_id":null,"docs":" The standard deviation is defined as the square root of the variance. This function returns the square root of the corresponding\n variance functions above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6545},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1752545,"byte_end":1752549,"line_start":90,"line_end":90,"column_start":8,"column_end":12},"name":"sd_m","qualname":"::statistics::sd_m","value":"fn (data: &[f64], stride: usize, n: usize, mean: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" The standard deviation is defined as the square root of the variance. This function returns the square root of the corresponding\n variance functions above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6546},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1752927,"byte_end":1752930,"line_start":98,"line_end":98,"column_start":8,"column_end":11},"name":"tss","qualname":"::statistics::tss","value":"fn (data: &[f64], stride: usize, n: usize) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the total sum of squares (TSS) of data about the mean. For gsl_stats_tss_m the user-supplied value of mean is\n used, and for gsl_stats_tss it is computed using gsl_stats_mean.\n \n TSS =  \\sum (x_i - mean)^2\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6547},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1753290,"byte_end":1753295,"line_start":106,"line_end":106,"column_start":8,"column_end":13},"name":"tss_m","qualname":"::statistics::tss_m","value":"fn (data: &[f64], stride: usize, n: usize, mean: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the total sum of squares (TSS) of data about the mean. For gsl_stats_tss_m the user-supplied value of mean is\n used, and for gsl_stats_tss it is computed using gsl_stats_mean.\n \n TSS =  \\sum (x_i - mean)^2\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6548},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1753780,"byte_end":1753804,"line_start":115,"line_end":115,"column_start":8,"column_end":32},"name":"variance_with_fixed_mean","qualname":"::statistics::variance_with_fixed_mean","value":"fn (data: &[f64], stride: usize, n: usize, mean: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes an unbiased estimate of the variance of data when the population mean mean of the underlying distribution is\n known a priori. In this case the estimator for the variance uses the factor 1/N and the sample mean \\Hat\\mu is replaced by the known\n population mean \\mu,\n \n \\Hat\\sigma^2 = (1/N) \\sum (x_i - \\mu)^2\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6549},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1754129,"byte_end":1754147,"line_start":121,"line_end":121,"column_start":8,"column_end":26},"name":"sd_with_fixed_mean","qualname":"::statistics::sd_with_fixed_mean","value":"fn (data: &[f64], stride: usize, n: usize, mean: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function calculates the standard deviation of data for a fixed population mean mean. The result is the square root of the\n corresponding variance function.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6550},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1754764,"byte_end":1754770,"line_start":132,"line_end":132,"column_start":8,"column_end":14},"name":"absdev","qualname":"::statistics::absdev","value":"fn (data: &[f64], stride: usize, n: usize) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the absolute deviation from the mean of data, a dataset of length n with stride stride. The absolute deviation\n from the mean is defined as,\n \n absdev  = (1/N) \\sum |x_i - \\Hat\\mu|\n \n where x_i are the elements of the dataset data. The absolute deviation from the mean provides a more robust measure of the width of a\n distribution than the variance. This function computes the mean of data via a call to gsl_stats_mean.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6551},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1755262,"byte_end":1755270,"line_start":142,"line_end":142,"column_start":8,"column_end":16},"name":"absdev_m","qualname":"::statistics::absdev_m","value":"fn (data: &[f64], stride: usize, n: usize, mean: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the absolute deviation of the dataset data relative to the given value of mean,\n \n absdev  = (1/N) \\sum |x_i - mean|\n \n This function is useful if you have already computed the mean of data (and want to avoid recomputing it), or wish to calculate the\n absolute deviation relative to another value (such as zero, or the median).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6552},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1755840,"byte_end":1755844,"line_start":153,"line_end":153,"column_start":8,"column_end":12},"name":"skew","qualname":"::statistics::skew","value":"fn (data: &[f64], stride: usize, n: usize) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the skewness of data, a dataset of length n with stride stride. The skewness is defined as,\n \n skew = (1/N) \\sum ((x_i - \\Hat\\mu)/\\Hat\\sigma)^3\n \n where x_i are the elements of the dataset data. The skewness measures the asymmetry of the tails of a distribution.\n \n The function computes the mean and estimated standard deviation of data via calls to gsl_stats_mean and gsl_stats_sd.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6553},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1756279,"byte_end":1756288,"line_start":162,"line_end":162,"column_start":8,"column_end":17},"name":"skew_m_sd","qualname":"::statistics::skew_m_sd","value":"fn (data: &[f64], stride: usize, n: usize, mean: f64, sd: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the skewness of the dataset data using the given values of the mean mean and standard deviation sd,\n \n skew = (1/N) \\sum ((x_i - mean)/sd)^3\n \n These functions are useful if you have already computed the mean and standard deviation of data and want to avoid recomputing them.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6554},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1756787,"byte_end":1756795,"line_start":171,"line_end":171,"column_start":8,"column_end":16},"name":"kurtosis","qualname":"::statistics::kurtosis","value":"fn (data: &[f64], stride: usize, n: usize) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the kurtosis of data, a dataset of length n with stride stride. The kurtosis is defined as,\n \n kurtosis = ((1/N) \\sum ((x_i - \\Hat\\mu)/\\Hat\\sigma)^4)  - 3\n \n The kurtosis measures how sharply peaked a distribution is, relative to its width. The kurtosis is normalized to zero for a Gaussian distribution.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6555},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1757241,"byte_end":1757254,"line_start":180,"line_end":180,"column_start":8,"column_end":21},"name":"kurtosis_m_sd","qualname":"::statistics::kurtosis_m_sd","value":"fn (data: &[f64], stride: usize, n: usize, mean: f64, sd: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the kurtosis of the dataset data using the given values of the mean mean and standard deviation sd,\n \n kurtosis = ((1/N) \\sum ((x_i - mean)/sd)^4) - 3\n \n This function is useful if you have already computed the mean and standard deviation of data and want to avoid recomputing them.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6556},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1757640,"byte_end":1757660,"line_start":189,"line_end":189,"column_start":8,"column_end":28},"name":"lag1_autocorrelation","qualname":"::statistics::lag1_autocorrelation","value":"fn (data: &[f64], stride: usize, n: usize) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the lag-1 autocorrelation of the dataset data.\n \n a_1 = {\\sum_{i = 1}^{n} (x_{i} - \\Hat\\mu) (x_{i-1} - \\Hat\\mu)\n        \\over\n        \\sum_{i = 1}^{n} (x_{i} - \\Hat\\mu) (x_{i} - \\Hat\\mu)}\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6557},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1757909,"byte_end":1757931,"line_start":194,"line_end":194,"column_start":8,"column_end":30},"name":"lag1_autocorrelation_m","qualname":"::statistics::lag1_autocorrelation_m","value":"fn (data: &[f64], stride: usize, n: usize, mean: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the lag-1 autocorrelation of the dataset data using the given value of the mean mean.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6558},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1758277,"byte_end":1758287,"line_start":201,"line_end":201,"column_start":8,"column_end":18},"name":"covariance","qualname":"::statistics::covariance","value":"fn (data1: &[f64], stride1: usize, data2: &[f64], stride2: usize, n: usize) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the covariance of the datasets data1 and data2 which must both be of the same length n.\n \n covar = (1/(n - 1)) \\sum_{i = 1}^{n} (x_i - \\Hat x) (y_i - \\Hat y)\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6559},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1758714,"byte_end":1758726,"line_start":207,"line_end":207,"column_start":8,"column_end":20},"name":"covariance_m","qualname":"::statistics::covariance_m","value":"fn (data1: &[f64], stride1: usize, data2: &[f64], stride2: usize, n: usize, mean1: f64, mean2: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the covariance of the datasets data1 and data2 using the given values of the means, mean1 and mean2. This is\n useful if you have already computed the means of data1 and data2 and want to avoid recomputing them.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6560},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1759322,"byte_end":1759333,"line_start":219,"line_end":219,"column_start":8,"column_end":19},"name":"correlation","qualname":"::statistics::correlation","value":"fn (data1: &[f64], stride1: usize, data2: &[f64], stride2: usize, n: usize) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function efficiently computes the Pearson correlation coefficient between the datasets data1 and data2 which must both be of the\n same length n.\n \n r = cov(x, y) / (\\Hat\\sigma_x \\Hat\\sigma_y)\n   = {1/(n-1) \\sum (x_i - \\Hat x) (y_i - \\Hat y)\n      \\over\n      \\sqrt{1/(n-1) \\sum (x_i - \\Hat x)^2} \\sqrt{1/(n-1) \\sum (y_i - \\Hat y)^2}\n     }\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6561},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1759979,"byte_end":1759987,"line_start":227,"line_end":227,"column_start":8,"column_end":16},"name":"spearman","qualname":"::statistics::spearman","value":"fn (data1: &[f64], stride1: usize, data2: &[f64], stride2: usize, n: usize, work: &mut [f64]) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the Spearman rank correlation coefficient between the datasets data1 and data2 which must both be of the same\n length n. Additional workspace of size 2*n is required in work. The Spearman rank correlation between vectors x and y is equivalent to\n the Pearson correlation between the ranked vectors x_R and y_R, where ranks are defined to be the average of the positions of an\n element in the ascending order of the values.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6562},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1760450,"byte_end":1760455,"line_start":235,"line_end":235,"column_start":8,"column_end":13},"name":"wmean","qualname":"::statistics::wmean","value":"fn (w: &[f64], wstride: usize, data: &[f64], stride: usize, n: usize) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the weighted mean of the dataset data with stride stride and length n, using the set of weights w with stride\n wstride and length n. The weighted mean is defined as,\n \n \\Hat\\mu = (\\sum w_i x_i) / (\\sum w_i)\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6563},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1761112,"byte_end":1761121,"line_start":246,"line_end":246,"column_start":8,"column_end":17},"name":"wvariance","qualname":"::statistics::wvariance","value":"fn (w: &[f64], wstride: usize, data: &[f64], stride: usize, n: usize) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the estimated variance of the dataset data with stride stride and length n, using the set of weights w with\n stride wstride and length n. The estimated variance of a weighted dataset is calculated as,\n \n \\Hat\\sigma^2 = ((\\sum w_i)/((\\sum w_i)^2 - \\sum (w_i^2))) \n                 \\sum w_i (x_i - \\Hat\\mu)^2\n \n Note that this expression reduces to an unweighted variance with the familiar 1/(N-1) factor when there are N equal non-zero weights.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6564},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1761409,"byte_end":1761420,"line_start":251,"line_end":251,"column_start":8,"column_end":19},"name":"wvariance_m","qualname":"::statistics::wvariance_m","value":"fn (w: &[f64], wstride: usize, data: &[f64], stride: usize, n: usize, wmean: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the estimated variance of the weighted dataset data using the given weighted mean wmean.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6565},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1761796,"byte_end":1761799,"line_start":257,"line_end":257,"column_start":8,"column_end":11},"name":"wsd","qualname":"::statistics::wsd","value":"fn (w: &[f64], wstride: usize, data: &[f64], stride: usize, n: usize) -> f64","parent":null,"children":[],"decl_id":null,"docs":" The standard deviation is defined as the square root of the variance. This function returns the square root of the corresponding\n variance function gsl_stats_wvariance above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6566},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1762076,"byte_end":1762081,"line_start":262,"line_end":262,"column_start":8,"column_end":13},"name":"wsd_m","qualname":"::statistics::wsd_m","value":"fn (w: &[f64], wstride: usize, data: &[f64], stride: usize, n: usize, wmean: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the square root of the corresponding variance function gsl_stats_wvariance_m above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6567},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1762623,"byte_end":1762648,"line_start":271,"line_end":271,"column_start":8,"column_end":33},"name":"wvariance_with_fixed_mean","qualname":"::statistics::wvariance_with_fixed_mean","value":"fn (w: &[f64], wstride: usize, data: &[f64], stride: usize, n: usize, mean: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes an unbiased estimate of the variance of the weighted dataset data when the population mean mean of the\n underlying distribution is known a priori. In this case the estimator for the variance replaces the sample mean \\Hat\\mu by the known\n population mean \\mu,\n \n \\Hat\\sigma^2 = (\\sum w_i (x_i - \\mu)^2) / (\\sum w_i)\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6568},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1763016,"byte_end":1763035,"line_start":277,"line_end":277,"column_start":8,"column_end":27},"name":"wsd_with_fixed_mean","qualname":"::statistics::wsd_with_fixed_mean","value":"fn (w: &[f64], wstride: usize, data: &[f64], stride: usize, n: usize, mean: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" The standard deviation is defined as the square root of the variance. This function returns the square root of the corresponding\n variance function above.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6569},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1763503,"byte_end":1763507,"line_start":285,"line_end":285,"column_start":8,"column_end":12},"name":"wtss","qualname":"::statistics::wtss","value":"fn (w: &[f64], wstride: usize, data: &[f64], stride: usize, n: usize) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the weighted total sum of squares (TSS) of data about the weighted mean. For gsl_stats_wtss_m the user-supplied\n value of wmean is used, and for gsl_stats_wtss it is computed using gsl_stats_wmean.\n \n TSS =  \\sum w_i (x_i - wmean)^2\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6570},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1763943,"byte_end":1763949,"line_start":293,"line_end":293,"column_start":8,"column_end":14},"name":"wtss_m","qualname":"::statistics::wtss_m","value":"fn (w: &[f64], wstride: usize, data: &[f64], stride: usize, n: usize, wmean: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the weighted total sum of squares (TSS) of data about the weighted mean. For gsl_stats_wtss_m the user-supplied\n value of wmean is used, and for gsl_stats_wtss it is computed using gsl_stats_wmean.\n \n TSS =  \\sum w_i (x_i - wmean)^2\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6571},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1764343,"byte_end":1764350,"line_start":301,"line_end":301,"column_start":8,"column_end":15},"name":"wabsdev","qualname":"::statistics::wabsdev","value":"fn (w: &[f64], wstride: usize, data: &[f64], stride: usize, n: usize) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the weighted absolute deviation from the weighted mean of data. The absolute deviation from the mean is defined\n as,\n \n absdev = (\\sum w_i |x_i - \\Hat\\mu|) / (\\sum w_i)\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6572},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1764637,"byte_end":1764646,"line_start":306,"line_end":306,"column_start":8,"column_end":17},"name":"wabsdev_m","qualname":"::statistics::wabsdev_m","value":"fn (w: &[f64], wstride: usize, data: &[f64], stride: usize, n: usize, wmean: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the absolute deviation of the weighted dataset data about the given weighted mean wmean.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6573},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1764979,"byte_end":1764984,"line_start":313,"line_end":313,"column_start":8,"column_end":13},"name":"wskew","qualname":"::statistics::wskew","value":"fn (w: &[f64], wstride: usize, data: &[f64], stride: usize, n: usize) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the weighted skewness of the dataset data.\n \n skew = (\\sum w_i ((x_i - \\Hat x)/\\Hat \\sigma)^3) / (\\sum w_i)\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6574},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1765318,"byte_end":1765328,"line_start":319,"line_end":319,"column_start":8,"column_end":18},"name":"wskew_m_sd","qualname":"::statistics::wskew_m_sd","value":"fn (w: &[f64], wstride: usize, data: &[f64], stride: usize, n: usize, wmean: f64, wsd: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the weighted skewness of the dataset data using the given values of the weighted mean and weighted standard\n deviation, wmean and wsd.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6575},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1765687,"byte_end":1765696,"line_start":326,"line_end":326,"column_start":8,"column_end":17},"name":"wkurtosis","qualname":"::statistics::wkurtosis","value":"fn (w: &[f64], wstride: usize, data: &[f64], stride: usize, n: usize) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the weighted kurtosis of the dataset data.\n \n kurtosis = ((\\sum w_i ((x_i - \\Hat x)/\\Hat \\sigma)^4) / (\\sum w_i)) - 3\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6576},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1766034,"byte_end":1766048,"line_start":332,"line_end":332,"column_start":8,"column_end":22},"name":"wkurtosis_m_sd","qualname":"::statistics::wkurtosis_m_sd","value":"fn (w: &[f64], wstride: usize, data: &[f64], stride: usize, n: usize, wmean: f64, wsd: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function computes the weighted kurtosis of the dataset data using the given values of the weighted mean and weighted standard\n deviation, wmean and wsd.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6577},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1766625,"byte_end":1766628,"line_start":341,"line_end":341,"column_start":8,"column_end":11},"name":"max","qualname":"::statistics::max","value":"fn (data: &[f64], stride: usize, n: usize) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the maximum value in data, a dataset of length n with stride stride. The maximum value is defined as the value\n of the element x_i which satisfies x_i >= x_j for all j.\n \n If you want instead to find the element with the largest absolute magnitude you will need to apply fabs or abs to your data before\n calling this function.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6578},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1767113,"byte_end":1767116,"line_start":350,"line_end":350,"column_start":8,"column_end":11},"name":"min","qualname":"::statistics::min","value":"fn (data: &[f64], stride: usize, n: usize) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the minimum value in data, a dataset of length n with stride stride. The minimum value is defined as the value\n of the element x_i which satisfies x_i <= x_j for all j.\n \n If you want instead to find the element with the smallest absolute magnitude you will need to apply fabs or abs to your data before\n calling this function.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6579},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1767330,"byte_end":1767336,"line_start":355,"line_end":355,"column_start":8,"column_end":14},"name":"minmax","qualname":"::statistics::minmax","value":"fn (min: &mut f64, max: &mut f64, data: &[f64], stride: usize, n: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function finds both the minimum and maximum values min, max in data in a single pass.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6580},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1767782,"byte_end":1767791,"line_start":362,"line_end":362,"column_start":8,"column_end":17},"name":"max_index","qualname":"::statistics::max_index","value":"fn (data: &[f64], stride: usize, n: usize) -> usize","parent":null,"children":[],"decl_id":null,"docs":" This function returns the index of the maximum value in data, a dataset of length n with stride stride. The maximum value is defined\n as the value of the element x_i which satisfies x_i >= x_j for all j. When there are several equal maximum elements then the first\n one is chosen.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6581},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1768209,"byte_end":1768218,"line_start":369,"line_end":369,"column_start":8,"column_end":17},"name":"min_index","qualname":"::statistics::min_index","value":"fn (data: &[f64], stride: usize, n: usize) -> usize","parent":null,"children":[],"decl_id":null,"docs":" This function returns the index of the minimum value in data, a dataset of length n with stride stride. The minimum value is defined\n as the value of the element x_i which satisfies x_i >= x_j for all j. When there are several equal minimum elements then the first\n one is chosen.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6582},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1768464,"byte_end":1768476,"line_start":374,"line_end":374,"column_start":8,"column_end":20},"name":"minmax_index","qualname":"::statistics::minmax_index","value":"fn (min_index: &mut usize, max_index: &mut usize, data: &[f64], stride: usize, n: usize) -> ()","parent":null,"children":[],"decl_id":null,"docs":" This function returns the indexes min_index, max_index of the minimum and maximum values in data in a single pass.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6583},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1769338,"byte_end":1769361,"line_start":385,"line_end":385,"column_start":8,"column_end":31},"name":"median_from_sorted_data","qualname":"::statistics::median_from_sorted_data","value":"fn (data: &[f64], stride: usize, n: usize) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns the median value of sorted_data, a dataset of length n with stride stride. The elements of the array must be in\n ascending numerical order. There are no checks to see whether the data are sorted, so the function gsl_sort should always be used\n first.\n \n When the dataset has an odd number of elements the median is the value of element (n-1)/2. When the dataset has an even number of\n elements the median is the mean of the two nearest middle values, elements (n-1)/2 and n/2. Since the algorithm for computing the\n median involves interpolation this function always returns a floating-point number, even for integer data types.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6584},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/statistics.rs","byte_start":1770506,"byte_end":1770531,"line_start":404,"line_end":404,"column_start":8,"column_end":33},"name":"quantile_from_sorted_data","qualname":"::statistics::quantile_from_sorted_data","value":"fn (data: &[f64], stride: usize, n: usize, f: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This function returns a quantile value of sorted_data, a double-precision array of length n with stride stride. The elements of the\n array must be in ascending numerical order. The quantile is determined by the f, a fraction between 0 and 1. For example, to compute\n the value of the 75th percentile f should have the value 0.75.\n \n There are no checks to see whether the data are sorted, so the function gsl_sort should always be used first.\n \n The quantile is found by interpolation, using the formula\n \n quantile = (1 - \\delta) x_i + \\delta x_{i+1}\n \n where i is floor((n - 1)f) and \\delta is (n-1)f - i.\n \n Thus the minimum value of the array (data[0*stride]) is given by f equal to zero, the maximum value (data[(n-1)*stride]) is given by\n f equal to one and the median value is given by f equal to 0.5. Since the algorithm for computing quantiles involves interpolation\n this function always returns a floating-point number, even for integer data types.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6585},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/synchrotron.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"synchrotron","qualname":"::synchrotron","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/synchrotron.rs","parent":null,"children":[{"krate":0,"index":6586},{"krate":0,"index":6587},{"krate":0,"index":6588},{"krate":0,"index":6589},{"krate":0,"index":6590},{"krate":0,"index":6591},{"krate":0,"index":6592}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6589},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/synchrotron.rs","byte_start":1770918,"byte_end":1770931,"line_start":10,"line_end":10,"column_start":8,"column_end":21},"name":"synchrotron_1","qualname":"::synchrotron::synchrotron_1","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the first synchrotron function x \\int_x^\\infty dt K_{5/3}(t) for x >= 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6590},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/synchrotron.rs","byte_start":1771102,"byte_end":1771117,"line_start":15,"line_end":15,"column_start":8,"column_end":23},"name":"synchrotron_1_e","qualname":"::synchrotron::synchrotron_1_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the first synchrotron function x \\int_x^\\infty dt K_{5/3}(t) for x >= 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6591},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/synchrotron.rs","byte_start":1771472,"byte_end":1771485,"line_start":23,"line_end":23,"column_start":8,"column_end":21},"name":"synchrotron_2","qualname":"::synchrotron::synchrotron_2","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the second synchrotron function x K_{2/3}(x) for x >= 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6592},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/synchrotron.rs","byte_start":1771640,"byte_end":1771655,"line_start":28,"line_end":28,"column_start":8,"column_end":23},"name":"synchrotron_2_e","qualname":"::synchrotron::synchrotron_2_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the second synchrotron function x K_{2/3}(x) for x >= 0.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6593},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/transport.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"transport","qualname":"::transport","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/transport.rs","parent":null,"children":[{"krate":0,"index":6594},{"krate":0,"index":6595},{"krate":0,"index":6596},{"krate":0,"index":6597},{"krate":0,"index":6598},{"krate":0,"index":6599},{"krate":0,"index":6600},{"krate":0,"index":6601},{"krate":0,"index":6602},{"krate":0,"index":6603},{"krate":0,"index":6604}],"decl_id":null,"docs":" The transport functions J(n,x) are defined by the integral representations J(n,x) := \\int_0^x dt t^n e^t /(e^t - 1)^2.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6597},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/transport.rs","byte_start":1772243,"byte_end":1772254,"line_start":12,"line_end":12,"column_start":8,"column_end":19},"name":"transport_2","qualname":"::transport::transport_2","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the transport function J(2,x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6598},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/transport.rs","byte_start":1772381,"byte_end":1772394,"line_start":17,"line_end":17,"column_start":8,"column_end":21},"name":"transport_2_e","qualname":"::transport::transport_2_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the transport function J(2,x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6599},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/transport.rs","byte_start":1772721,"byte_end":1772732,"line_start":25,"line_end":25,"column_start":8,"column_end":19},"name":"transport_3","qualname":"::transport::transport_3","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the transport function J(3,x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6600},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/transport.rs","byte_start":1772859,"byte_end":1772872,"line_start":30,"line_end":30,"column_start":8,"column_end":21},"name":"transport_3_e","qualname":"::transport::transport_3_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the transport function J(3,x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6601},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/transport.rs","byte_start":1773199,"byte_end":1773210,"line_start":38,"line_end":38,"column_start":8,"column_end":19},"name":"transport_4","qualname":"::transport::transport_4","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the transport function J(4,x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6602},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/transport.rs","byte_start":1773337,"byte_end":1773350,"line_start":43,"line_end":43,"column_start":8,"column_end":21},"name":"transport_4_e","qualname":"::transport::transport_4_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the transport function J(4,x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6603},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/transport.rs","byte_start":1773677,"byte_end":1773688,"line_start":51,"line_end":51,"column_start":8,"column_end":19},"name":"transport_5","qualname":"::transport::transport_5","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the transport function J(5,x).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6604},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/transport.rs","byte_start":1773815,"byte_end":1773828,"line_start":56,"line_end":56,"column_start":8,"column_end":21},"name":"transport_5_e","qualname":"::transport::transport_5_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the transport function J(5,x).\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6605},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/trigonometric.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"trigonometric","qualname":"::trigonometric","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/trigonometric.rs","parent":null,"children":[{"krate":0,"index":6606},{"krate":0,"index":6607},{"krate":0,"index":6608},{"krate":0,"index":6632}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Trait","id":{"krate":0,"index":6608},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/trigonometric.rs","byte_start":1774228,"byte_end":1774241,"line_start":8,"line_end":8,"column_start":11,"column_end":24},"name":"Trigonometric","qualname":"::trigonometric::Trigonometric","value":"Trigonometric","parent":null,"children":[{"krate":0,"index":6609},{"krate":0,"index":6610},{"krate":0,"index":6611},{"krate":0,"index":6612},{"krate":0,"index":6613},{"krate":0,"index":6614},{"krate":0,"index":6615},{"krate":0,"index":6616},{"krate":0,"index":6617},{"krate":0,"index":6618},{"krate":0,"index":6619},{"krate":0,"index":6620},{"krate":0,"index":6621},{"krate":0,"index":6622},{"krate":0,"index":6623},{"krate":0,"index":6624},{"krate":0,"index":6625},{"krate":0,"index":6626},{"krate":0,"index":6627},{"krate":0,"index":6628},{"krate":0,"index":6629},{"krate":0,"index":6630},{"krate":0,"index":6631}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6609},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/trigonometric.rs","byte_start":1774308,"byte_end":1774311,"line_start":10,"line_end":10,"column_start":8,"column_end":11},"name":"sin","qualname":"::trigonometric::Trigonometric::sin","value":"fn (&self) -> Self","parent":{"krate":0,"index":6608},"children":[],"decl_id":null,"docs":" This routine computes the sine function \\sin(x).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6610},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/trigonometric.rs","byte_start":1774392,"byte_end":1774397,"line_start":12,"line_end":12,"column_start":8,"column_end":13},"name":"sin_e","qualname":"::trigonometric::Trigonometric::sin_e","value":"fn (&self) -> (enums::Value, ::types::Result)","parent":{"krate":0,"index":6608},"children":[],"decl_id":null,"docs":" This routine computes the sine function \\sin(x).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6611},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/trigonometric.rs","byte_start":1774507,"byte_end":1774510,"line_start":14,"line_end":14,"column_start":8,"column_end":11},"name":"cos","qualname":"::trigonometric::Trigonometric::cos","value":"fn (&self) -> Self","parent":{"krate":0,"index":6608},"children":[],"decl_id":null,"docs":" This routine computes the cosine function \\sin(x).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6612},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/trigonometric.rs","byte_start":1774593,"byte_end":1774598,"line_start":16,"line_end":16,"column_start":8,"column_end":13},"name":"cos_e","qualname":"::trigonometric::Trigonometric::cos_e","value":"fn (&self) -> (enums::Value, ::types::Result)","parent":{"krate":0,"index":6608},"children":[],"decl_id":null,"docs":" This routine computes the cosine function \\sin(x).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6613},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/trigonometric.rs","byte_start":1774753,"byte_end":1774761,"line_start":18,"line_end":18,"column_start":8,"column_end":16},"name":"sf_hypot","qualname":"::trigonometric::Trigonometric::sf_hypot","value":"fn (&self) -> Self","parent":{"krate":0,"index":6608},"children":[],"decl_id":null,"docs":" This routine computes the hypotenuse function \\sqrt{x^2 + y^2} avoiding overflow and underflow.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6614},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/trigonometric.rs","byte_start":1774889,"byte_end":1774899,"line_start":20,"line_end":20,"column_start":8,"column_end":18},"name":"sf_hypot_e","qualname":"::trigonometric::Trigonometric::sf_hypot_e","value":"fn (&self) -> (enums::Value, ::types::Result)","parent":{"krate":0,"index":6608},"children":[],"decl_id":null,"docs":" This routine computes the hypotenuse function \\sqrt{x^2 + y^2} avoiding overflow and underflow.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6615},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/trigonometric.rs","byte_start":1775033,"byte_end":1775037,"line_start":22,"line_end":22,"column_start":8,"column_end":12},"name":"sinc","qualname":"::trigonometric::Trigonometric::sinc","value":"fn (&self) -> Self","parent":{"krate":0,"index":6608},"children":[],"decl_id":null,"docs":" This routine computes \\sinc(x) = \\sin(\\pi x) / (\\pi x) for any value of x.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6616},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/trigonometric.rs","byte_start":1775144,"byte_end":1775150,"line_start":24,"line_end":24,"column_start":8,"column_end":14},"name":"sinc_e","qualname":"::trigonometric::Trigonometric::sinc_e","value":"fn (&self) -> (enums::Value, ::types::Result)","parent":{"krate":0,"index":6608},"children":[],"decl_id":null,"docs":" This routine computes \\sinc(x) = \\sin(\\pi x) / (\\pi x) for any value of x.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6617},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/trigonometric.rs","byte_start":1775318,"byte_end":1775331,"line_start":26,"line_end":26,"column_start":8,"column_end":21},"name":"complex_sin_e","qualname":"::trigonometric::Trigonometric::complex_sin_e","value":"fn (&self, zi: f64) -> (enums::Value, ::types::Result, ::types::Result)","parent":{"krate":0,"index":6608},"children":[],"decl_id":null,"docs":" This function computes the complex sine, \\sin(z_r + i z_i) storing the real and imaginary parts in szr, szi.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6618},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/trigonometric.rs","byte_start":1775527,"byte_end":1775540,"line_start":28,"line_end":28,"column_start":8,"column_end":21},"name":"complex_cos_e","qualname":"::trigonometric::Trigonometric::complex_cos_e","value":"fn (&self, zi: f64) -> (enums::Value, ::types::Result, ::types::Result)","parent":{"krate":0,"index":6608},"children":[],"decl_id":null,"docs":" This function computes the complex cosine, \\cos(z_r + i z_i) storing the real and imaginary parts in czr, czi.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6619},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/trigonometric.rs","byte_start":1775759,"byte_end":1775775,"line_start":30,"line_end":30,"column_start":8,"column_end":24},"name":"complex_logsin_e","qualname":"::trigonometric::Trigonometric::complex_logsin_e","value":"fn (&self, zi: f64) -> (enums::Value, ::types::Result, ::types::Result)","parent":{"krate":0,"index":6608},"children":[],"decl_id":null,"docs":" This function computes the logarithm of the complex sine, \\log(\\sin(z_r + i z_i)) storing the real and imaginary parts in lszr, lszi.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6620},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/trigonometric.rs","byte_start":1775908,"byte_end":1775914,"line_start":32,"line_end":32,"column_start":8,"column_end":14},"name":"lnsinh","qualname":"::trigonometric::Trigonometric::lnsinh","value":"fn (&self) -> Self","parent":{"krate":0,"index":6608},"children":[],"decl_id":null,"docs":" This routine computes \\log(\\sinh(x)) for x > 0.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6621},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/trigonometric.rs","byte_start":1775994,"byte_end":1776002,"line_start":34,"line_end":34,"column_start":8,"column_end":16},"name":"lnsinh_e","qualname":"::trigonometric::Trigonometric::lnsinh_e","value":"fn (&self) -> (enums::Value, ::types::Result)","parent":{"krate":0,"index":6608},"children":[],"decl_id":null,"docs":" This routine computes \\log(\\sinh(x)) for x > 0.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6622},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/trigonometric.rs","byte_start":1776109,"byte_end":1776115,"line_start":36,"line_end":36,"column_start":8,"column_end":14},"name":"lncosh","qualname":"::trigonometric::Trigonometric::lncosh","value":"fn (&self) -> Self","parent":{"krate":0,"index":6608},"children":[],"decl_id":null,"docs":" This routine computes \\log(\\cosh(x)) for x > 0.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6623},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/trigonometric.rs","byte_start":1776195,"byte_end":1776203,"line_start":38,"line_end":38,"column_start":8,"column_end":16},"name":"lncosh_e","qualname":"::trigonometric::Trigonometric::lncosh_e","value":"fn (&self) -> (enums::Value, ::types::Result)","parent":{"krate":0,"index":6608},"children":[],"decl_id":null,"docs":" This routine computes \\log(\\cosh(x)) for x > 0.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6624},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/trigonometric.rs","byte_start":1776389,"byte_end":1776402,"line_start":40,"line_end":40,"column_start":8,"column_end":21},"name":"polar_to_rect","qualname":"::trigonometric::Trigonometric::polar_to_rect","value":"fn (&self, theta: f64) -> (enums::Value, ::types::Result, ::types::Result)","parent":{"krate":0,"index":6608},"children":[],"decl_id":null,"docs":" This function converts the polar coordinates (r,theta) to rectilinear coordinates (x,y), x = r\\cos(\\theta), y = r\\sin(\\theta).\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6625},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/trigonometric.rs","byte_start":1776685,"byte_end":1776698,"line_start":43,"line_end":43,"column_start":8,"column_end":21},"name":"rect_to_polar","qualname":"::trigonometric::Trigonometric::rect_to_polar","value":"fn (&self, y: f64) -> (enums::Value, ::types::Result, ::types::Result)","parent":{"krate":0,"index":6608},"children":[],"decl_id":null,"docs":" This function converts the rectilinear coordinates (x,y) to polar coordinates (r,theta), such that x = r\\cos(\\theta), y = r\\sin(\\theta).\n The argument theta lies in the range [-\\pi, \\pi].\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6626},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/trigonometric.rs","byte_start":1777003,"byte_end":1777022,"line_start":47,"line_end":47,"column_start":8,"column_end":27},"name":"angle_restrict_symm","qualname":"::trigonometric::Trigonometric::angle_restrict_symm","value":"fn (&self) -> Self","parent":{"krate":0,"index":6608},"children":[],"decl_id":null,"docs":" This routine forces the angle theta to lie in the range (-\\pi,\\pi].\n \n Note that the mathematical value of \\pi is slightly greater than M_PI, so the machine numbers M_PI and -M_PI are included in the range.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6627},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/trigonometric.rs","byte_start":1777275,"byte_end":1777296,"line_start":51,"line_end":51,"column_start":8,"column_end":29},"name":"angle_restrict_symm_e","qualname":"::trigonometric::Trigonometric::angle_restrict_symm_e","value":"fn (&mut self) -> enums::Value","parent":{"krate":0,"index":6608},"children":[],"decl_id":null,"docs":" This routine forces the angle theta to lie in the range (-\\pi,\\pi].\n \n Note that the mathematical value of \\pi is slightly greater than M_PI, so the machine numbers M_PI and -M_PI are included in the range.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6628},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/trigonometric.rs","byte_start":1777553,"byte_end":1777571,"line_start":55,"line_end":55,"column_start":8,"column_end":26},"name":"angle_restrict_pos","qualname":"::trigonometric::Trigonometric::angle_restrict_pos","value":"fn (&self) -> Self","parent":{"krate":0,"index":6608},"children":[],"decl_id":null,"docs":" This routine forces the angle theta to lie in the range [0, 2\\pi).\n \n Note that the mathematical value of 2\\pi is slightly greater than 2*M_PI, so the machine number 2*M_PI is included in the range.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6629},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/trigonometric.rs","byte_start":1777816,"byte_end":1777836,"line_start":59,"line_end":59,"column_start":8,"column_end":28},"name":"angle_restrict_pos_e","qualname":"::trigonometric::Trigonometric::angle_restrict_pos_e","value":"fn (&mut self) -> enums::Value","parent":{"krate":0,"index":6608},"children":[],"decl_id":null,"docs":" This routine forces the angle theta to lie in the range [0, 2\\pi).\n \n Note that the mathematical value of 2\\pi is slightly greater than 2*M_PI, so the machine number 2*M_PI is included in the range.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6630},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/trigonometric.rs","byte_start":1778118,"byte_end":1778127,"line_start":63,"line_end":63,"column_start":8,"column_end":17},"name":"sin_err_e","qualname":"::trigonometric::Trigonometric::sin_err_e","value":"fn (&self, dx: f64) -> (enums::Value, ::types::Result)","parent":{"krate":0,"index":6608},"children":[],"decl_id":null,"docs":" This routine computes the sine of an angle x with an associated absolute error dx, \\sin(x \\pm dx).\n \n Note that this function is provided in the error-handling form only since its purpose is to compute the propagated error.\n","sig":null,"attributes":[]},{"kind":"Method","id":{"krate":0,"index":6631},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/trigonometric.rs","byte_start":1778435,"byte_end":1778444,"line_start":67,"line_end":67,"column_start":8,"column_end":17},"name":"cos_err_e","qualname":"::trigonometric::Trigonometric::cos_err_e","value":"fn (&self, dx: f64) -> (enums::Value, ::types::Result)","parent":{"krate":0,"index":6608},"children":[],"decl_id":null,"docs":" This routine computes the cosine of an angle x with an associated absolute error dx, \\cos(x \\pm dx).\n \n Note that this function is provided in the error-handling form only since its purpose is to compute the propagated error.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6656},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/util.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"util","qualname":"::util","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/util.rs","parent":null,"children":[{"krate":0,"index":6657}],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6657},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/util.rs","byte_start":1784391,"byte_end":1784412,"line_start":5,"line_end":5,"column_start":8,"column_end":29},"name":"subinterval_too_small","qualname":"::util::subinterval_too_small","value":"fn (a1: f64, a2: f64, b2: f64) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6658},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/wavelet_transforms.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"wavelet_transforms","qualname":"::wavelet_transforms","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/wavelet_transforms.rs","parent":null,"children":[{"krate":0,"index":6659},{"krate":0,"index":6665}],"decl_id":null,"docs":"##Transform Functions","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6659},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/wavelet_transforms.rs","byte_start":1786305,"byte_end":1786318,"line_start":28,"line_end":28,"column_start":9,"column_end":22},"name":"one_dimension","qualname":"::wavelet_transforms::one_dimension","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/wavelet_transforms.rs","parent":null,"children":[{"krate":0,"index":6660},{"krate":0,"index":6661},{"krate":0,"index":6662},{"krate":0,"index":6663},{"krate":0,"index":6664}],"decl_id":null,"docs":" These functions compute in-place forward and inverse discrete wavelet transforms of length n with stride stride on the array data. The\n length of the transform n is restricted to powers of two. For the transform version of the function the argument dir can be either\n forward (+1) or backward (-1). A workspace work of length n must be provided.\n \n For the forward transform, the elements of the original array are replaced by the discrete wavelet transform f_i -> w_{j,k} in a\n packed triangular storage layout, where j is the index of the level j = 0 ... J-1 and k is the index of the coefficient within each\n level, k = 0 ... (2^j)-1. The total number of levels is J = \\log_2(n). The output data has the following form,\n \n (s_{-1,0}, d_{0,0}, d_{1,0}, d_{1,1}, d_{2,0}, ..., \n   d_{j,k}, ..., d_{J-1,2^{J-1}-1}) \n where the first element is the smoothing coefficient s_{-1,0}, followed by the detail coefficients d_{j,k} for each level j. The\n backward transform inverts these coefficients to obtain the original data.\n \n These functions return a status of ::Value::Success upon successful completion. ::Inval is returned if n is not an integer power of\n 2 or if insufficient workspace is provided.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6662},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/wavelet_transforms.rs","byte_start":1786361,"byte_end":1786370,"line_start":32,"line_end":32,"column_start":12,"column_end":21},"name":"transform","qualname":"::wavelet_transforms::one_dimension::transform","value":"fn (w: &::Wavelet, data: &mut [f64], stride: usize, n: usize, dir: ::WaveletDirection, work: &mut ::WaveletWorkspace) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6663},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/wavelet_transforms.rs","byte_start":1786911,"byte_end":1786928,"line_start":44,"line_end":44,"column_start":12,"column_end":29},"name":"transform_forward","qualname":"::wavelet_transforms::one_dimension::transform_forward","value":"fn (w: &::Wavelet, data: &mut [f64], stride: usize, n: usize, work: &mut ::WaveletWorkspace) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6664},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/wavelet_transforms.rs","byte_start":1787425,"byte_end":1787442,"line_start":54,"line_end":54,"column_start":12,"column_end":29},"name":"transform_inverse","qualname":"::wavelet_transforms::one_dimension::transform_inverse","value":"fn (w: &::Wavelet, data: &mut [f64], stride: usize, n: usize, work: &mut ::WaveletWorkspace) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6665},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/wavelet_transforms.rs","byte_start":1789107,"byte_end":1789120,"line_start":77,"line_end":77,"column_start":9,"column_end":22},"name":"two_dimension","qualname":"::wavelet_transforms::two_dimension","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/wavelet_transforms.rs","parent":null,"children":[{"krate":0,"index":6666},{"krate":0,"index":6667},{"krate":0,"index":6668},{"krate":0,"index":6669},{"krate":0,"index":6670},{"krate":0,"index":6671},{"krate":0,"index":6672},{"krate":0,"index":6673},{"krate":0,"index":6674},{"krate":0,"index":6675},{"krate":0,"index":6676},{"krate":0,"index":6677},{"krate":0,"index":6678},{"krate":0,"index":6679}],"decl_id":null,"docs":" The library provides functions to perform two-dimensional discrete wavelet transforms on square matrices. The matrix dimensions must\n be an integer power of two. There are two possible orderings of the rows and columns in the two-dimensional wavelet transform,\n referred to as the “standard” and “non-standard” forms.\n \n The “standard” transform performs a complete discrete wavelet transform on the rows of the matrix, followed by a separate complete\n discrete wavelet transform on the columns of the resulting row-transformed matrix. This procedure uses the same ordering as a\n two-dimensional Fourier transform.\n \n The “non-standard” transform is performed in interleaved passes on the rows and columns of the matrix for each level of the transform.\n The first level of the transform is applied to the matrix rows, and then to the matrix columns. This procedure is then repeated across\n the rows and columns of the data for the subsequent levels of the transform, until the full discrete wavelet transform is complete.\n The non-standard form of the discrete wavelet transform is typically used in image analysis.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6668},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/wavelet_transforms.rs","byte_start":1789998,"byte_end":1790007,"line_start":89,"line_end":89,"column_start":12,"column_end":21},"name":"transform","qualname":"::wavelet_transforms::two_dimension::transform","value":"fn (w: &::Wavelet, data: &mut [f64], tda: usize, size1: usize, size2: usize, dir: ::WaveletDirection, work: &mut ::WaveletWorkspace) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" These functions compute two-dimensional in-place forward and inverse discrete wavelet transforms in standard form on the array\n data stored in row-major form with dimensions size1 and size2 and physical row length tda. The dimensions must be equal\n (square matrix) and are restricted to powers of two. For the transform version of the function the argument dir can be either\n forward (+1) or backward (-1). A workspace work of the appropriate size must be provided. On exit, the appropriate elements of\n the array data are replaced by their two-dimensional wavelet transform.\n \n The functions return a status of ::Value::Success upon successful completion. ::Inval is returned if size1 and size2 are not\n equal and integer powers of 2, or if insufficient workspace is provided.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6669},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/wavelet_transforms.rs","byte_start":1791459,"byte_end":1791476,"line_start":110,"line_end":110,"column_start":12,"column_end":29},"name":"transform_forward","qualname":"::wavelet_transforms::two_dimension::transform_forward","value":"fn (w: &::Wavelet, data: &mut [f64], tda: usize, size1: usize, size2: usize, work: &mut ::WaveletWorkspace) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" These functions compute two-dimensional in-place forward and inverse discrete wavelet transforms in standard form on the array\n data stored in row-major form with dimensions size1 and size2 and physical row length tda. The dimensions must be equal\n (square matrix) and are restricted to powers of two. For the transform version of the function the argument dir can be either\n forward (+1) or backward (-1). A workspace work of the appropriate size must be provided. On exit, the appropriate elements of\n the array data are replaced by their two-dimensional wavelet transform.\n \n The functions return a status of ::Value::Success upon successful completion. ::Inval is returned if size1 and size2 are not\n equal and integer powers of 2, or if insufficient workspace is provided.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6670},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/wavelet_transforms.rs","byte_start":1792890,"byte_end":1792907,"line_start":129,"line_end":129,"column_start":12,"column_end":29},"name":"transform_inverse","qualname":"::wavelet_transforms::two_dimension::transform_inverse","value":"fn (w: &::Wavelet, data: &mut [f64], tda: usize, size1: usize, size2: usize, work: &mut ::WaveletWorkspace) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" These functions compute two-dimensional in-place forward and inverse discrete wavelet transforms in standard form on the array\n data stored in row-major form with dimensions size1 and size2 and physical row length tda. The dimensions must be equal\n (square matrix) and are restricted to powers of two. For the transform version of the function the argument dir can be either\n forward (+1) or backward (-1). A workspace work of the appropriate size must be provided. On exit, the appropriate elements of\n the array data are replaced by their two-dimensional wavelet transform.\n \n The functions return a status of ::Value::Success upon successful completion. ::Inval is returned if size1 and size2 are not\n equal and integer powers of 2, or if insufficient workspace is provided.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6671},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/wavelet_transforms.rs","byte_start":1793580,"byte_end":1793596,"line_start":141,"line_end":141,"column_start":12,"column_end":28},"name":"transform_matrix","qualname":"::wavelet_transforms::two_dimension::transform_matrix","value":"fn (w: &::Wavelet, m: &mut ::MatrixF64, dir: ::WaveletDirection, work: &mut ::WaveletWorkspace) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" These functions compute the two-dimensional in-place wavelet transform on a matrix a.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6672},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/wavelet_transforms.rs","byte_start":1794157,"byte_end":1794181,"line_start":151,"line_end":151,"column_start":12,"column_end":36},"name":"transform_matrix_forward","qualname":"::wavelet_transforms::two_dimension::transform_matrix_forward","value":"fn (w: &::Wavelet, m: &mut ::MatrixF64, work: &mut ::WaveletWorkspace) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" These functions compute the two-dimensional in-place wavelet transform on a matrix a.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6673},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/wavelet_transforms.rs","byte_start":1794681,"byte_end":1794705,"line_start":160,"line_end":160,"column_start":12,"column_end":36},"name":"transform_matrix_inverse","qualname":"::wavelet_transforms::two_dimension::transform_matrix_inverse","value":"fn (w: &::Wavelet, m: &mut ::MatrixF64, work: &mut ::WaveletWorkspace) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" These functions compute the two-dimensional in-place wavelet transform on a matrix a.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6674},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/wavelet_transforms.rs","byte_start":1795203,"byte_end":1795214,"line_start":169,"line_end":169,"column_start":12,"column_end":23},"name":"nstransform","qualname":"::wavelet_transforms::two_dimension::nstransform","value":"fn (w: &::Wavelet, data: &mut [f64], tda: usize, size1: usize, size2: usize, dir: ::WaveletDirection, work: &mut ::WaveletWorkspace) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" These functions compute the two-dimensional wavelet transform in non-standard form.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6675},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/wavelet_transforms.rs","byte_start":1795937,"byte_end":1795956,"line_start":183,"line_end":183,"column_start":12,"column_end":31},"name":"nstransform_forward","qualname":"::wavelet_transforms::two_dimension::nstransform_forward","value":"fn (w: &::Wavelet, data: &mut [f64], tda: usize, size1: usize, size2: usize, work: &mut ::WaveletWorkspace) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" These functions compute the two-dimensional wavelet transform in non-standard form.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6676},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/wavelet_transforms.rs","byte_start":1796647,"byte_end":1796666,"line_start":196,"line_end":196,"column_start":12,"column_end":31},"name":"nstransform_inverse","qualname":"::wavelet_transforms::two_dimension::nstransform_inverse","value":"fn (w: &::Wavelet, data: &mut [f64], tda: usize, size1: usize, size2: usize, work: &mut ::WaveletWorkspace) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" These functions compute the two-dimensional wavelet transform in non-standard form.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6677},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/wavelet_transforms.rs","byte_start":1797384,"byte_end":1797402,"line_start":209,"line_end":209,"column_start":12,"column_end":30},"name":"nstransform_matrix","qualname":"::wavelet_transforms::two_dimension::nstransform_matrix","value":"fn (w: &::Wavelet, m: &mut ::MatrixF64, dir: ::WaveletDirection, work: &mut ::WaveletWorkspace) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" These functions compute the non-standard form of the two-dimensional in-place wavelet transform on a matrix a.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6678},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/wavelet_transforms.rs","byte_start":1797996,"byte_end":1798022,"line_start":219,"line_end":219,"column_start":12,"column_end":38},"name":"nstransform_matrix_forward","qualname":"::wavelet_transforms::two_dimension::nstransform_matrix_forward","value":"fn (w: &::Wavelet, m: &mut ::MatrixF64, work: &mut ::WaveletWorkspace) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" These functions compute the non-standard form of the two-dimensional in-place wavelet transform on a matrix a.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6679},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/wavelet_transforms.rs","byte_start":1798553,"byte_end":1798579,"line_start":228,"line_end":228,"column_start":12,"column_end":38},"name":"nstransform_matrix_inverse","qualname":"::wavelet_transforms::two_dimension::nstransform_matrix_inverse","value":"fn (w: &::Wavelet, m: &mut ::MatrixF64, work: &mut ::WaveletWorkspace) -> enums::Value","parent":null,"children":[],"decl_id":null,"docs":" These functions compute the non-standard form of the two-dimensional in-place wavelet transform on a matrix a.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6680},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/zeta.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1},"name":"zeta","qualname":"::zeta","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/zeta.rs","parent":null,"children":[{"krate":0,"index":6681},{"krate":0,"index":6689},{"krate":0,"index":6697},{"krate":0,"index":6703}],"decl_id":null,"docs":" The Riemann zeta function is defined in Abramowitz & Stegun, Section 23.2.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6681},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/zeta.rs","byte_start":1799261,"byte_end":1799268,"line_start":8,"line_end":8,"column_start":9,"column_end":16},"name":"riemann","qualname":"::zeta::riemann","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/zeta.rs","parent":null,"children":[{"krate":0,"index":6682},{"krate":0,"index":6683},{"krate":0,"index":6684},{"krate":0,"index":6685},{"krate":0,"index":6686},{"krate":0,"index":6687},{"krate":0,"index":6688}],"decl_id":null,"docs":" The Riemann zeta function is defined by the infinite sum \\zeta(s) = \\sum_{k=1}^\\infty k^{-s}.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6685},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/zeta.rs","byte_start":1799426,"byte_end":1799434,"line_start":14,"line_end":14,"column_start":12,"column_end":20},"name":"zeta_int","qualname":"::zeta::riemann::zeta_int","value":"fn (n: i32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Riemann zeta function \\zeta(n) for integer n, n \\ne 1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6686},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/zeta.rs","byte_start":1799602,"byte_end":1799612,"line_start":19,"line_end":19,"column_start":12,"column_end":22},"name":"zeta_int_e","qualname":"::zeta::riemann::zeta_int_e","value":"fn (n: i32) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Riemann zeta function \\zeta(n) for integer n, n \\ne 1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6687},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/zeta.rs","byte_start":1799990,"byte_end":1799994,"line_start":27,"line_end":27,"column_start":12,"column_end":16},"name":"zeta","qualname":"::zeta::riemann::zeta","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Riemann zeta function \\zeta(s) for arbitrary s, s \\ne 1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6688},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/zeta.rs","byte_start":1800160,"byte_end":1800166,"line_start":32,"line_end":32,"column_start":12,"column_end":18},"name":"zeta_e","qualname":"::zeta::riemann::zeta_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Riemann zeta function \\zeta(s) for arbitrary s, s \\ne 1.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6689},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/zeta.rs","byte_start":1800638,"byte_end":1800654,"line_start":42,"line_end":42,"column_start":9,"column_end":25},"name":"riemann_mins_one","qualname":"::zeta::riemann_mins_one","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/zeta.rs","parent":null,"children":[{"krate":0,"index":6690},{"krate":0,"index":6691},{"krate":0,"index":6692},{"krate":0,"index":6693},{"krate":0,"index":6694},{"krate":0,"index":6695},{"krate":0,"index":6696}],"decl_id":null,"docs":" For large positive argument, the Riemann zeta function approaches one.\n In this region the fractional part is interesting, and therefore we need a function to evaluate it explicitly.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6693},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/zeta.rs","byte_start":1800812,"byte_end":1800822,"line_start":48,"line_end":48,"column_start":12,"column_end":22},"name":"zetam1_int","qualname":"::zeta::riemann_mins_one::zetam1_int","value":"fn (n: i32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Riemann zeta function \\zeta(n) for integer n, n \\ne 1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6694},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/zeta.rs","byte_start":1800992,"byte_end":1801004,"line_start":53,"line_end":53,"column_start":12,"column_end":24},"name":"zetam1_int_e","qualname":"::zeta::riemann_mins_one::zetam1_int_e","value":"fn (n: i32) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Riemann zeta function \\zeta(n) for integer n, n \\ne 1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6695},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/zeta.rs","byte_start":1801362,"byte_end":1801368,"line_start":61,"line_end":61,"column_start":12,"column_end":18},"name":"zetam1","qualname":"::zeta::riemann_mins_one::zetam1","value":"fn (x: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes \\zeta(s) - 1 for arbitrary s, s \\ne 1.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6696},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/zeta.rs","byte_start":1801514,"byte_end":1801522,"line_start":66,"line_end":66,"column_start":12,"column_end":20},"name":"zetam1_e","qualname":"::zeta::riemann_mins_one::zetam1_e","value":"fn (x: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes \\zeta(s) - 1 for arbitrary s, s \\ne 1.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6697},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/zeta.rs","byte_start":1801889,"byte_end":1801896,"line_start":75,"line_end":75,"column_start":9,"column_end":16},"name":"hurwitz","qualname":"::zeta::hurwitz","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/zeta.rs","parent":null,"children":[{"krate":0,"index":6698},{"krate":0,"index":6699},{"krate":0,"index":6700},{"krate":0,"index":6701},{"krate":0,"index":6702}],"decl_id":null,"docs":" The Hurwitz zeta function is defined by \\zeta(s,q) = \\sum_0^\\infty (k+q)^{-s}.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6701},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/zeta.rs","byte_start":1802050,"byte_end":1802055,"line_start":81,"line_end":81,"column_start":12,"column_end":17},"name":"hzeta","qualname":"::zeta::hurwitz::hzeta","value":"fn (s: f64, q: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Hurwitz zeta function \\zeta(s,q) for s > 1, q > 0.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6702},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/zeta.rs","byte_start":1802227,"byte_end":1802234,"line_start":86,"line_end":86,"column_start":12,"column_end":19},"name":"hzeta_e","qualname":"::zeta::hurwitz::hzeta_e","value":"fn (s: f64, q: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the Hurwitz zeta function \\zeta(s,q) for s > 1, q > 0.\n","sig":null,"attributes":[]},{"kind":"Mod","id":{"krate":0,"index":6703},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/zeta.rs","byte_start":1802595,"byte_end":1802598,"line_start":95,"line_end":95,"column_start":9,"column_end":12},"name":"eta","qualname":"::zeta::eta","value":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/zeta.rs","parent":null,"children":[{"krate":0,"index":6704},{"krate":0,"index":6705},{"krate":0,"index":6706},{"krate":0,"index":6707},{"krate":0,"index":6708},{"krate":0,"index":6709},{"krate":0,"index":6710}],"decl_id":null,"docs":" The eta function is defined by \\eta(s) = (1-2^{1-s}) \\zeta(s).\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6707},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/zeta.rs","byte_start":1802737,"byte_end":1802744,"line_start":101,"line_end":101,"column_start":12,"column_end":19},"name":"eta_int","qualname":"::zeta::eta::eta_int","value":"fn (n: i32) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the eta function \\eta(n) for integer n.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6708},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/zeta.rs","byte_start":1802892,"byte_end":1802901,"line_start":106,"line_end":106,"column_start":12,"column_end":21},"name":"eta_int_e","qualname":"::zeta::eta::eta_int_e","value":"fn (n: i32) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the eta function \\eta(n) for integer n.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6709},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/zeta.rs","byte_start":1803259,"byte_end":1803262,"line_start":114,"line_end":114,"column_start":12,"column_end":15},"name":"eta","qualname":"::zeta::eta::eta","value":"fn (s: f64) -> f64","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the eta function \\eta(s) for arbitrary s.\n","sig":null,"attributes":[]},{"kind":"Function","id":{"krate":0,"index":6710},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/zeta.rs","byte_start":1803408,"byte_end":1803413,"line_start":119,"line_end":119,"column_start":12,"column_end":17},"name":"eta_e","qualname":"::zeta::eta::eta_e","value":"fn (s: f64) -> (enums::Value, ::types::Result)","parent":null,"children":[],"decl_id":null,"docs":" This routine computes the eta function \\eta(s) for arbitrary s.\n","sig":null,"attributes":[]},{"kind":"Type","id":{"krate":0,"index":6711},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":4429,"byte_end":4442,"line_start":222,"line_end":222,"column_start":10,"column_end":23},"name":"comparison_fn","qualname":"::comparison_fn","value":"fn(a: &T, b: &T) -> i32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Type","id":{"krate":0,"index":6713},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":4482,"byte_end":4490,"line_start":223,"line_end":223,"column_start":10,"column_end":18},"name":"function","qualname":"::function","value":"fn(x: f64, p: &mut T) -> f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Type","id":{"krate":0,"index":6715},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":4535,"byte_end":4555,"line_start":224,"line_end":224,"column_start":10,"column_end":30},"name":"integration_function","qualname":"::integration_function","value":"fn(f: ::function<T>, arg: &mut T, a: f64, b: f64, result: &mut f64,\n   abserr: &mut f64, resabs: &mut f64, resasc: &mut f64)","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Type","id":{"krate":0,"index":6717},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":4693,"byte_end":4707,"line_start":225,"line_end":225,"column_start":10,"column_end":24},"name":"monte_function","qualname":"::monte_function","value":"fn(x: &mut [f64], params: &mut T) -> f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Type","id":{"krate":0,"index":6719},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":4764,"byte_end":4779,"line_start":226,"line_end":226,"column_start":10,"column_end":25},"name":"select_function","qualname":"::select_function","value":"fn(ntuple_data: &mut T, params: &mut U) -> bool","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Type","id":{"krate":0,"index":6722},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":4846,"byte_end":4860,"line_start":227,"line_end":227,"column_start":10,"column_end":24},"name":"value_function","qualname":"::value_function","value":"fn(ntuple_data: &mut T, params: &mut U) -> f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6725},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":5039,"byte_end":5052,"line_start":231,"line_end":231,"column_start":12,"column_end":25},"name":"SF_GAMMA_XMAX","qualname":"::SF_GAMMA_XMAX","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The maximum x such that gamma(x) is not considered an overflow.\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6726},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":5149,"byte_end":5161,"line_start":233,"line_end":233,"column_start":12,"column_end":24},"name":"SF_FACT_NMAX","qualname":"::SF_FACT_NMAX","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The maximum n such that gsl_sf_fact(n) does not give an overflow.\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6727},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":5264,"byte_end":5282,"line_start":235,"line_end":235,"column_start":12,"column_end":30},"name":"SF_DOUBLEFACT_NMAX","qualname":"::SF_DOUBLEFACT_NMAX","value":"f64","parent":null,"children":[],"decl_id":null,"docs":" The maximum n such that gsl_sf_doublefact(n) does not give an overflow.\n","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6728},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":5310,"byte_end":5326,"line_start":237,"line_end":237,"column_start":12,"column_end":28},"name":"SF_MATHIEU_COEFF","qualname":"::SF_MATHIEU_COEFF","value":"u32","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6729},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":5352,"byte_end":5363,"line_start":239,"line_end":239,"column_start":12,"column_end":23},"name":"DBL_EPSILON","qualname":"::DBL_EPSILON","value":"f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6730},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":5413,"byte_end":5429,"line_start":240,"line_end":240,"column_start":12,"column_end":28},"name":"SQRT_DBL_EPSILON","qualname":"::SQRT_DBL_EPSILON","value":"f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6731},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":5474,"byte_end":5491,"line_start":241,"line_end":241,"column_start":12,"column_end":29},"name":"ROOT3_DBL_EPSILON","qualname":"::ROOT3_DBL_EPSILON","value":"f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6732},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":5535,"byte_end":5552,"line_start":242,"line_end":242,"column_start":12,"column_end":29},"name":"ROOT4_DBL_EPSILON","qualname":"::ROOT4_DBL_EPSILON","value":"f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6733},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":5596,"byte_end":5613,"line_start":243,"line_end":243,"column_start":12,"column_end":29},"name":"ROOT5_DBL_EPSILON","qualname":"::ROOT5_DBL_EPSILON","value":"f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6734},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":5657,"byte_end":5674,"line_start":244,"line_end":244,"column_start":12,"column_end":29},"name":"ROOT6_DBL_EPSILON","qualname":"::ROOT6_DBL_EPSILON","value":"f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6735},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":5719,"byte_end":5726,"line_start":246,"line_end":246,"column_start":12,"column_end":19},"name":"DBL_MIN","qualname":"::DBL_MIN","value":"f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6736},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":5781,"byte_end":5793,"line_start":247,"line_end":247,"column_start":12,"column_end":24},"name":"SQRT_DBL_MIN","qualname":"::SQRT_DBL_MIN","value":"f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6737},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":5843,"byte_end":5856,"line_start":248,"line_end":248,"column_start":12,"column_end":25},"name":"ROOT3_DBL_MIN","qualname":"::ROOT3_DBL_MIN","value":"f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6738},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":5905,"byte_end":5918,"line_start":249,"line_end":249,"column_start":12,"column_end":25},"name":"ROOT4_DBL_MIN","qualname":"::ROOT4_DBL_MIN","value":"f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6739},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":5966,"byte_end":5979,"line_start":250,"line_end":250,"column_start":12,"column_end":25},"name":"ROOT5_DBL_MIN","qualname":"::ROOT5_DBL_MIN","value":"f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6740},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":6027,"byte_end":6040,"line_start":251,"line_end":251,"column_start":12,"column_end":25},"name":"ROOT6_DBL_MIN","qualname":"::ROOT6_DBL_MIN","value":"f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6741},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":6089,"byte_end":6096,"line_start":253,"line_end":253,"column_start":12,"column_end":19},"name":"DBL_MAX","qualname":"::DBL_MAX","value":"f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6742},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":6169,"byte_end":6181,"line_start":254,"line_end":254,"column_start":12,"column_end":24},"name":"SQRT_DBL_MAX","qualname":"::SQRT_DBL_MAX","value":"f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6743},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":6231,"byte_end":6244,"line_start":255,"line_end":255,"column_start":12,"column_end":25},"name":"ROOT3_DBL_MAX","qualname":"::ROOT3_DBL_MAX","value":"f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6744},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":6293,"byte_end":6306,"line_start":256,"line_end":256,"column_start":12,"column_end":25},"name":"ROOT4_DBL_MAX","qualname":"::ROOT4_DBL_MAX","value":"f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6745},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":6354,"byte_end":6367,"line_start":257,"line_end":257,"column_start":12,"column_end":25},"name":"ROOT5_DBL_MAX","qualname":"::ROOT5_DBL_MAX","value":"f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6746},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":6415,"byte_end":6428,"line_start":258,"line_end":258,"column_start":12,"column_end":25},"name":"ROOT6_DBL_MAX","qualname":"::ROOT6_DBL_MAX","value":"f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6747},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":6476,"byte_end":6487,"line_start":259,"line_end":259,"column_start":12,"column_end":23},"name":"LOG_DBL_MAX","qualname":"::LOG_DBL_MAX","value":"f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6748},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":6538,"byte_end":6541,"line_start":261,"line_end":261,"column_start":12,"column_end":15},"name":"NAN","qualname":"::NAN","value":"f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6749},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":6588,"byte_end":6594,"line_start":262,"line_end":262,"column_start":12,"column_end":18},"name":"POSINF","qualname":"::POSINF","value":"f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]},{"kind":"Static","id":{"krate":0,"index":6750},"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":6638,"byte_end":6644,"line_start":263,"line_end":263,"column_start":12,"column_end":18},"name":"NEGINF","qualname":"::NEGINF","value":"f64","parent":null,"children":[],"decl_id":null,"docs":"","sig":null,"attributes":[]}],"impls":[{"id":0,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":351791,"byte_end":351800,"line_start":16,"line_end":16,"column_start":38,"column_end":47},"value":"","parent":null,"children":[{"krate":0,"index":2652}],"docs":"","sig":null,"attributes":[]},{"id":1,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":353902,"byte_end":353907,"line_start":99,"line_end":99,"column_start":28,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":2654}],"docs":"","sig":null,"attributes":[]},{"id":2,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":355276,"byte_end":355281,"line_start":142,"line_end":142,"column_start":28,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":2656}],"docs":"","sig":null,"attributes":[]},{"id":3,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":356951,"byte_end":356960,"line_start":197,"line_end":197,"column_start":28,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":2658}],"docs":"","sig":null,"attributes":[]},{"id":4,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":357211,"byte_end":357220,"line_start":208,"line_end":208,"column_start":28,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":2660}],"docs":"","sig":null,"attributes":[]},{"id":5,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":357818,"byte_end":357830,"line_start":233,"line_end":233,"column_start":28,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":2662}],"docs":"","sig":null,"attributes":[]},{"id":6,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":358017,"byte_end":358029,"line_start":242,"line_end":242,"column_start":28,"column_end":40},"value":"","parent":null,"children":[{"krate":0,"index":2664}],"docs":"","sig":null,"attributes":[]},{"id":7,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":358791,"byte_end":358806,"line_start":269,"line_end":269,"column_start":28,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":2666}],"docs":"","sig":null,"attributes":[]},{"id":8,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":359169,"byte_end":359184,"line_start":282,"line_end":282,"column_start":28,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":2668}],"docs":"","sig":null,"attributes":[]},{"id":9,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":359763,"byte_end":359778,"line_start":303,"line_end":303,"column_start":28,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":2670}],"docs":"","sig":null,"attributes":[]},{"id":10,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":359965,"byte_end":359980,"line_start":312,"line_end":312,"column_start":28,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":2672}],"docs":"","sig":null,"attributes":[]},{"id":11,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":360798,"byte_end":360807,"line_start":336,"line_end":336,"column_start":28,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":2674}],"docs":"","sig":null,"attributes":[]},{"id":12,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":361037,"byte_end":361046,"line_start":346,"line_end":346,"column_start":28,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":2676}],"docs":"","sig":null,"attributes":[]},{"id":13,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":361603,"byte_end":361608,"line_start":368,"line_end":368,"column_start":28,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":2678}],"docs":"","sig":null,"attributes":[]},{"id":14,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":361801,"byte_end":361806,"line_start":378,"line_end":378,"column_start":28,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":2680}],"docs":"","sig":null,"attributes":[]},{"id":15,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":362159,"byte_end":362175,"line_start":395,"line_end":395,"column_start":28,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":2682}],"docs":"","sig":null,"attributes":[]},{"id":16,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":362370,"byte_end":362386,"line_start":404,"line_end":404,"column_start":28,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":2684}],"docs":"","sig":null,"attributes":[]},{"id":17,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":362790,"byte_end":362804,"line_start":422,"line_end":422,"column_start":28,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":2686}],"docs":"","sig":null,"attributes":[]},{"id":18,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":363081,"byte_end":363095,"line_start":433,"line_end":433,"column_start":28,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":2688}],"docs":"","sig":null,"attributes":[]},{"id":19,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/utilities.rs","byte_start":363762,"byte_end":363770,"line_start":22,"line_end":22,"column_start":6,"column_end":14},"value":"","parent":null,"children":[{"krate":0,"index":2707},{"krate":0,"index":2709},{"krate":0,"index":2710}],"docs":"","sig":null,"attributes":[]},{"id":20,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/utilities.rs","byte_start":364583,"byte_end":364591,"line_start":53,"line_end":53,"column_start":27,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":2712}],"docs":"","sig":null,"attributes":[]},{"id":21,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/basis_spline.rs","byte_start":435735,"byte_end":435751,"line_start":61,"line_end":61,"column_start":6,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":3111},{"krate":0,"index":3112},{"krate":0,"index":3113},{"krate":0,"index":3114},{"krate":0,"index":3115},{"krate":0,"index":3116},{"krate":0,"index":3117}],"docs":"","sig":null,"attributes":[]},{"id":22,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/basis_spline.rs","byte_start":439540,"byte_end":439556,"line_start":139,"line_end":139,"column_start":15,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":3119}],"docs":"","sig":null,"attributes":[]},{"id":23,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/basis_spline.rs","byte_start":439730,"byte_end":439746,"line_start":146,"line_end":146,"column_start":47,"column_end":63},"value":"","parent":null,"children":[{"krate":0,"index":3121},{"krate":0,"index":3122},{"krate":0,"index":3123},{"krate":0,"index":3124}],"docs":"","sig":null,"attributes":[]},{"id":24,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/chebyshev.rs","byte_start":445026,"byte_end":445036,"line_start":43,"line_end":43,"column_start":6,"column_end":16},"value":"","parent":null,"children":[{"krate":0,"index":3134},{"krate":0,"index":3135},{"krate":0,"index":3137},{"krate":0,"index":3138},{"krate":0,"index":3139},{"krate":0,"index":3141},{"krate":0,"index":3143},{"krate":0,"index":3144},{"krate":0,"index":3145},{"krate":0,"index":3146},{"krate":0,"index":3147},{"krate":0,"index":3148}],"docs":"","sig":null,"attributes":[]},{"id":25,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/chebyshev.rs","byte_start":449943,"byte_end":449953,"line_start":160,"line_end":160,"column_start":15,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":3150}],"docs":"","sig":null,"attributes":[]},{"id":26,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/chebyshev.rs","byte_start":450118,"byte_end":450128,"line_start":167,"line_end":167,"column_start":41,"column_end":51},"value":"","parent":null,"children":[{"krate":0,"index":3152},{"krate":0,"index":3153},{"krate":0,"index":3154},{"krate":0,"index":3155}],"docs":"","sig":null,"attributes":[]},{"id":27,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/combination.rs","byte_start":451523,"byte_end":451534,"line_start":32,"line_end":32,"column_start":6,"column_end":17},"value":"","parent":null,"children":[{"krate":0,"index":3168},{"krate":0,"index":3169},{"krate":0,"index":3170},{"krate":0,"index":3171},{"krate":0,"index":3172},{"krate":0,"index":3173},{"krate":0,"index":3174},{"krate":0,"index":3175},{"krate":0,"index":3176},{"krate":0,"index":3178},{"krate":0,"index":3180},{"krate":0,"index":3181},{"krate":0,"index":3182}],"docs":"","sig":null,"attributes":[]},{"id":28,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/combination.rs","byte_start":456468,"byte_end":456479,"line_start":151,"line_end":151,"column_start":15,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":3184}],"docs":"","sig":null,"attributes":[]},{"id":29,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/combination.rs","byte_start":456651,"byte_end":456662,"line_start":158,"line_end":158,"column_start":41,"column_end":52},"value":"","parent":null,"children":[{"krate":0,"index":3186},{"krate":0,"index":3187},{"krate":0,"index":3188},{"krate":0,"index":3189}],"docs":"","sig":null,"attributes":[]},{"id":30,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/combination.rs","byte_start":457186,"byte_end":457197,"line_start":181,"line_end":181,"column_start":16,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":3191}],"docs":"","sig":null,"attributes":[]},{"id":31,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":458117,"byte_end":458127,"line_start":30,"line_end":30,"column_start":6,"column_end":16},"value":"","parent":null,"children":[{"krate":0,"index":3208},{"krate":0,"index":3209},{"krate":0,"index":3210},{"krate":0,"index":3211},{"krate":0,"index":3212},{"krate":0,"index":3213},{"krate":0,"index":3214},{"krate":0,"index":3215},{"krate":0,"index":3216},{"krate":0,"index":3217},{"krate":0,"index":3218},{"krate":0,"index":3219},{"krate":0,"index":3220},{"krate":0,"index":3221},{"krate":0,"index":3222},{"krate":0,"index":3223},{"krate":0,"index":3224},{"krate":0,"index":3225},{"krate":0,"index":3226},{"krate":0,"index":3227},{"krate":0,"index":3228},{"krate":0,"index":3229},{"krate":0,"index":3230},{"krate":0,"index":3231},{"krate":0,"index":3232},{"krate":0,"index":3233},{"krate":0,"index":3234},{"krate":0,"index":3235},{"krate":0,"index":3236},{"krate":0,"index":3237},{"krate":0,"index":3238},{"krate":0,"index":3239},{"krate":0,"index":3240},{"krate":0,"index":3241},{"krate":0,"index":3242},{"krate":0,"index":3243},{"krate":0,"index":3244},{"krate":0,"index":3245},{"krate":0,"index":3246},{"krate":0,"index":3247},{"krate":0,"index":3248},{"krate":0,"index":3249},{"krate":0,"index":3250},{"krate":0,"index":3251},{"krate":0,"index":3252},{"krate":0,"index":3253},{"krate":0,"index":3254},{"krate":0,"index":3255},{"krate":0,"index":3256},{"krate":0,"index":3257},{"krate":0,"index":3258},{"krate":0,"index":3259},{"krate":0,"index":3260},{"krate":0,"index":3261},{"krate":0,"index":3262},{"krate":0,"index":3263},{"krate":0,"index":3264},{"krate":0,"index":3265},{"krate":0,"index":3266}],"docs":"","sig":null,"attributes":[]},{"id":32,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":472938,"byte_end":472948,"line_start":382,"line_end":382,"column_start":16,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":3268}],"docs":"","sig":null,"attributes":[]},{"id":33,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":473085,"byte_end":473095,"line_start":388,"line_end":388,"column_start":16,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":3270}],"docs":"","sig":null,"attributes":[]},{"id":34,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":473235,"byte_end":473245,"line_start":396,"line_end":396,"column_start":18,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":3272}],"docs":"","sig":null,"attributes":[]},{"id":35,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":473383,"byte_end":473393,"line_start":404,"line_end":404,"column_start":33,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":3274},{"krate":0,"index":3275}],"docs":"","sig":null,"attributes":[]},{"id":36,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":473632,"byte_end":473642,"line_start":414,"line_end":414,"column_start":39,"column_end":49},"value":"","parent":null,"children":[{"krate":0,"index":3277},{"krate":0,"index":3278}],"docs":"","sig":null,"attributes":[]},{"id":37,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":473981,"byte_end":473992,"line_start":428,"line_end":428,"column_start":32,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":3280},{"krate":0,"index":3281}],"docs":"","sig":null,"attributes":[]},{"id":38,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":474307,"byte_end":474318,"line_start":442,"line_end":442,"column_start":32,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":3283},{"krate":0,"index":3284}],"docs":"","sig":null,"attributes":[]},{"id":39,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":474605,"byte_end":474615,"line_start":458,"line_end":458,"column_start":6,"column_end":16},"value":"","parent":null,"children":[{"krate":0,"index":3286},{"krate":0,"index":3287},{"krate":0,"index":3288},{"krate":0,"index":3289},{"krate":0,"index":3290},{"krate":0,"index":3291},{"krate":0,"index":3292},{"krate":0,"index":3293},{"krate":0,"index":3294},{"krate":0,"index":3295},{"krate":0,"index":3296},{"krate":0,"index":3297},{"krate":0,"index":3298},{"krate":0,"index":3299},{"krate":0,"index":3300},{"krate":0,"index":3301},{"krate":0,"index":3302},{"krate":0,"index":3303},{"krate":0,"index":3304},{"krate":0,"index":3305},{"krate":0,"index":3306},{"krate":0,"index":3307},{"krate":0,"index":3308},{"krate":0,"index":3309},{"krate":0,"index":3310},{"krate":0,"index":3311},{"krate":0,"index":3312},{"krate":0,"index":3313},{"krate":0,"index":3314},{"krate":0,"index":3315},{"krate":0,"index":3316},{"krate":0,"index":3317},{"krate":0,"index":3318},{"krate":0,"index":3319},{"krate":0,"index":3320},{"krate":0,"index":3321},{"krate":0,"index":3322},{"krate":0,"index":3323},{"krate":0,"index":3324},{"krate":0,"index":3325},{"krate":0,"index":3326},{"krate":0,"index":3327},{"krate":0,"index":3328},{"krate":0,"index":3329},{"krate":0,"index":3330},{"krate":0,"index":3331},{"krate":0,"index":3332},{"krate":0,"index":3333},{"krate":0,"index":3334},{"krate":0,"index":3335},{"krate":0,"index":3336},{"krate":0,"index":3337},{"krate":0,"index":3338},{"krate":0,"index":3339},{"krate":0,"index":3340},{"krate":0,"index":3341},{"krate":0,"index":3342},{"krate":0,"index":3343},{"krate":0,"index":3344}],"docs":"","sig":null,"attributes":[]},{"id":40,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":489571,"byte_end":489581,"line_start":807,"line_end":807,"column_start":16,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":3346}],"docs":"","sig":null,"attributes":[]},{"id":41,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":489718,"byte_end":489728,"line_start":813,"line_end":813,"column_start":16,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":3348}],"docs":"","sig":null,"attributes":[]},{"id":42,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":489868,"byte_end":489878,"line_start":821,"line_end":821,"column_start":18,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":3350}],"docs":"","sig":null,"attributes":[]},{"id":43,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":490016,"byte_end":490026,"line_start":829,"line_end":829,"column_start":33,"column_end":43},"value":"","parent":null,"children":[{"krate":0,"index":3352},{"krate":0,"index":3353}],"docs":"","sig":null,"attributes":[]},{"id":44,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":490354,"byte_end":490364,"line_start":843,"line_end":843,"column_start":39,"column_end":49},"value":"","parent":null,"children":[{"krate":0,"index":3355},{"krate":0,"index":3356}],"docs":"","sig":null,"attributes":[]},{"id":45,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/discrete_hankel.rs","byte_start":513178,"byte_end":513192,"line_start":63,"line_end":63,"column_start":6,"column_end":20},"value":"","parent":null,"children":[{"krate":0,"index":3363},{"krate":0,"index":3364},{"krate":0,"index":3365},{"krate":0,"index":3366},{"krate":0,"index":3367},{"krate":0,"index":3368}],"docs":"","sig":null,"attributes":[]},{"id":46,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/discrete_hankel.rs","byte_start":515623,"byte_end":515637,"line_start":126,"line_end":126,"column_start":15,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":3370}],"docs":"","sig":null,"attributes":[]},{"id":47,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/discrete_hankel.rs","byte_start":515793,"byte_end":515807,"line_start":133,"line_end":133,"column_start":33,"column_end":47},"value":"","parent":null,"children":[{"krate":0,"index":3372},{"krate":0,"index":3373},{"krate":0,"index":3374},{"krate":0,"index":3375}],"docs":"","sig":null,"attributes":[]},{"id":48,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":521514,"byte_end":521537,"line_start":106,"line_end":106,"column_start":6,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":3387},{"krate":0,"index":3388}],"docs":"","sig":null,"attributes":[]},{"id":49,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":522569,"byte_end":522592,"line_start":132,"line_end":132,"column_start":15,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":3390}],"docs":"","sig":null,"attributes":[]},{"id":50,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":522772,"byte_end":522795,"line_start":139,"line_end":139,"column_start":50,"column_end":73},"value":"","parent":null,"children":[{"krate":0,"index":3392},{"krate":0,"index":3393},{"krate":0,"index":3394},{"krate":0,"index":3395}],"docs":"","sig":null,"attributes":[]},{"id":51,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":523368,"byte_end":523392,"line_start":161,"line_end":161,"column_start":6,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":3399},{"krate":0,"index":3400}],"docs":"","sig":null,"attributes":[]},{"id":52,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":524900,"byte_end":524924,"line_start":195,"line_end":195,"column_start":15,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":3402}],"docs":"","sig":null,"attributes":[]},{"id":53,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":525106,"byte_end":525130,"line_start":202,"line_end":202,"column_start":51,"column_end":75},"value":"","parent":null,"children":[{"krate":0,"index":3404},{"krate":0,"index":3405},{"krate":0,"index":3406},{"krate":0,"index":3407}],"docs":"","sig":null,"attributes":[]},{"id":54,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":525710,"byte_end":525733,"line_start":224,"line_end":224,"column_start":6,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":3411},{"krate":0,"index":3412}],"docs":"","sig":null,"attributes":[]},{"id":55,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":526946,"byte_end":526969,"line_start":251,"line_end":251,"column_start":15,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":3414}],"docs":"","sig":null,"attributes":[]},{"id":56,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":527149,"byte_end":527172,"line_start":258,"line_end":258,"column_start":50,"column_end":73},"value":"","parent":null,"children":[{"krate":0,"index":3416},{"krate":0,"index":3417},{"krate":0,"index":3418},{"krate":0,"index":3419}],"docs":"","sig":null,"attributes":[]},{"id":57,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":527745,"byte_end":527769,"line_start":280,"line_end":280,"column_start":6,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":3423},{"krate":0,"index":3424}],"docs":"","sig":null,"attributes":[]},{"id":58,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":529481,"byte_end":529505,"line_start":316,"line_end":316,"column_start":15,"column_end":39},"value":"","parent":null,"children":[{"krate":0,"index":3426}],"docs":"","sig":null,"attributes":[]},{"id":59,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":529687,"byte_end":529711,"line_start":323,"line_end":323,"column_start":51,"column_end":75},"value":"","parent":null,"children":[{"krate":0,"index":3428},{"krate":0,"index":3429},{"krate":0,"index":3430},{"krate":0,"index":3431}],"docs":"","sig":null,"attributes":[]},{"id":60,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":530292,"byte_end":530313,"line_start":345,"line_end":345,"column_start":6,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":3435},{"krate":0,"index":3436},{"krate":0,"index":3437},{"krate":0,"index":3438},{"krate":0,"index":3439}],"docs":"","sig":null,"attributes":[]},{"id":61,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":534155,"byte_end":534176,"line_start":423,"line_end":423,"column_start":15,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":3441}],"docs":"","sig":null,"attributes":[]},{"id":62,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":534362,"byte_end":534383,"line_start":430,"line_end":430,"column_start":53,"column_end":74},"value":"","parent":null,"children":[{"krate":0,"index":3443},{"krate":0,"index":3444},{"krate":0,"index":3445},{"krate":0,"index":3446}],"docs":"","sig":null,"attributes":[]},{"id":63,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":534959,"byte_end":534981,"line_start":452,"line_end":452,"column_start":6,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":3450},{"krate":0,"index":3451},{"krate":0,"index":3452},{"krate":0,"index":3453}],"docs":"","sig":null,"attributes":[]},{"id":64,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":537827,"byte_end":537849,"line_start":511,"line_end":511,"column_start":15,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":3455}],"docs":"","sig":null,"attributes":[]},{"id":65,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":538037,"byte_end":538059,"line_start":518,"line_end":518,"column_start":54,"column_end":76},"value":"","parent":null,"children":[{"krate":0,"index":3457},{"krate":0,"index":3458},{"krate":0,"index":3459},{"krate":0,"index":3460}],"docs":"","sig":null,"attributes":[]},{"id":66,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":538642,"byte_end":538663,"line_start":540,"line_end":540,"column_start":6,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":3464},{"krate":0,"index":3465}],"docs":"","sig":null,"attributes":[]},{"id":67,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":539844,"byte_end":539865,"line_start":570,"line_end":570,"column_start":15,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":3467}],"docs":"","sig":null,"attributes":[]},{"id":68,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":540051,"byte_end":540072,"line_start":577,"line_end":577,"column_start":53,"column_end":74},"value":"","parent":null,"children":[{"krate":0,"index":3469},{"krate":0,"index":3470},{"krate":0,"index":3471},{"krate":0,"index":3472}],"docs":"","sig":null,"attributes":[]},{"id":69,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":540648,"byte_end":540670,"line_start":599,"line_end":599,"column_start":6,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":3476},{"krate":0,"index":3477}],"docs":"","sig":null,"attributes":[]},{"id":70,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":542070,"byte_end":542092,"line_start":632,"line_end":632,"column_start":15,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":3479}],"docs":"","sig":null,"attributes":[]},{"id":71,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":542280,"byte_end":542302,"line_start":639,"line_end":639,"column_start":54,"column_end":76},"value":"","parent":null,"children":[{"krate":0,"index":3481},{"krate":0,"index":3482},{"krate":0,"index":3483},{"krate":0,"index":3484}],"docs":"","sig":null,"attributes":[]},{"id":72,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":542885,"byte_end":542906,"line_start":661,"line_end":661,"column_start":6,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":3488},{"krate":0,"index":3489}],"docs":"","sig":null,"attributes":[]},{"id":73,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":544107,"byte_end":544128,"line_start":691,"line_end":691,"column_start":15,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":3491}],"docs":"","sig":null,"attributes":[]},{"id":74,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":544314,"byte_end":544335,"line_start":698,"line_end":698,"column_start":53,"column_end":74},"value":"","parent":null,"children":[{"krate":0,"index":3493},{"krate":0,"index":3494},{"krate":0,"index":3495},{"krate":0,"index":3496}],"docs":"","sig":null,"attributes":[]},{"id":75,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":544911,"byte_end":544933,"line_start":720,"line_end":720,"column_start":6,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":3500},{"krate":0,"index":3501}],"docs":"","sig":null,"attributes":[]},{"id":76,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":546262,"byte_end":546284,"line_start":752,"line_end":752,"column_start":15,"column_end":37},"value":"","parent":null,"children":[{"krate":0,"index":3503}],"docs":"","sig":null,"attributes":[]},{"id":77,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":546472,"byte_end":546494,"line_start":759,"line_end":759,"column_start":54,"column_end":76},"value":"","parent":null,"children":[{"krate":0,"index":3505},{"krate":0,"index":3506},{"krate":0,"index":3507},{"krate":0,"index":3508}],"docs":"","sig":null,"attributes":[]},{"id":78,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":547069,"byte_end":547086,"line_start":781,"line_end":781,"column_start":6,"column_end":23},"value":"","parent":null,"children":[{"krate":0,"index":3512},{"krate":0,"index":3513},{"krate":0,"index":3514},{"krate":0,"index":3515}],"docs":"","sig":null,"attributes":[]},{"id":79,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":550984,"byte_end":551001,"line_start":860,"line_end":860,"column_start":15,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":3517}],"docs":"","sig":null,"attributes":[]},{"id":80,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":551179,"byte_end":551196,"line_start":867,"line_end":867,"column_start":49,"column_end":66},"value":"","parent":null,"children":[{"krate":0,"index":3519},{"krate":0,"index":3520},{"krate":0,"index":3521},{"krate":0,"index":3522}],"docs":"","sig":null,"attributes":[]},{"id":81,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":551728,"byte_end":551746,"line_start":889,"line_end":889,"column_start":6,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":3526},{"krate":0,"index":3527},{"krate":0,"index":3528}],"docs":"","sig":null,"attributes":[]},{"id":82,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":554674,"byte_end":554692,"line_start":951,"line_end":951,"column_start":15,"column_end":33},"value":"","parent":null,"children":[{"krate":0,"index":3530}],"docs":"","sig":null,"attributes":[]},{"id":83,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":554872,"byte_end":554890,"line_start":958,"line_end":958,"column_start":50,"column_end":68},"value":"","parent":null,"children":[{"krate":0,"index":3532},{"krate":0,"index":3533},{"krate":0,"index":3534},{"krate":0,"index":3535}],"docs":"","sig":null,"attributes":[]},{"id":84,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/fast_fourier_transforms.rs","byte_start":561812,"byte_end":561831,"line_start":13,"line_end":13,"column_start":6,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":3543},{"krate":0,"index":3544}],"docs":"","sig":null,"attributes":[]},{"id":85,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/fast_fourier_transforms.rs","byte_start":563351,"byte_end":563370,"line_start":42,"line_end":42,"column_start":15,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":3547}],"docs":"","sig":null,"attributes":[]},{"id":86,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/fast_fourier_transforms.rs","byte_start":563562,"byte_end":563581,"line_start":49,"line_end":49,"column_start":51,"column_end":70},"value":"","parent":null,"children":[{"krate":0,"index":3549},{"krate":0,"index":3550},{"krate":0,"index":3551},{"krate":0,"index":3552}],"docs":"","sig":null,"attributes":[]},{"id":87,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/fast_fourier_transforms.rs","byte_start":564258,"byte_end":564277,"line_start":76,"line_end":76,"column_start":6,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":3556}],"docs":"","sig":null,"attributes":[]},{"id":88,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/fast_fourier_transforms.rs","byte_start":564661,"byte_end":564680,"line_start":91,"line_end":91,"column_start":15,"column_end":34},"value":"","parent":null,"children":[{"krate":0,"index":3558}],"docs":"","sig":null,"attributes":[]},{"id":89,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/fast_fourier_transforms.rs","byte_start":564872,"byte_end":564891,"line_start":98,"line_end":98,"column_start":51,"column_end":70},"value":"","parent":null,"children":[{"krate":0,"index":3560},{"krate":0,"index":3561},{"krate":0,"index":3562},{"krate":0,"index":3563}],"docs":"","sig":null,"attributes":[]},{"id":90,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":567005,"byte_end":567014,"line_start":35,"line_end":35,"column_start":6,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":3571},{"krate":0,"index":3572},{"krate":0,"index":3573},{"krate":0,"index":3574},{"krate":0,"index":3575},{"krate":0,"index":3576},{"krate":0,"index":3577},{"krate":0,"index":3578},{"krate":0,"index":3579},{"krate":0,"index":3580},{"krate":0,"index":3581},{"krate":0,"index":3582},{"krate":0,"index":3583},{"krate":0,"index":3584},{"krate":0,"index":3585},{"krate":0,"index":3586},{"krate":0,"index":3587},{"krate":0,"index":3588},{"krate":0,"index":3589},{"krate":0,"index":3590},{"krate":0,"index":3591},{"krate":0,"index":3592},{"krate":0,"index":3593},{"krate":0,"index":3594},{"krate":0,"index":3595},{"krate":0,"index":3596},{"krate":0,"index":3597},{"krate":0,"index":3598},{"krate":0,"index":3599}],"docs":"","sig":null,"attributes":[]},{"id":91,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":579310,"byte_end":579319,"line_start":269,"line_end":269,"column_start":15,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":3601}],"docs":"","sig":null,"attributes":[]},{"id":92,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":579487,"byte_end":579496,"line_start":276,"line_end":276,"column_start":39,"column_end":48},"value":"","parent":null,"children":[{"krate":0,"index":3603},{"krate":0,"index":3604},{"krate":0,"index":3605},{"krate":0,"index":3606}],"docs":"","sig":null,"attributes":[]},{"id":93,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":580706,"byte_end":580718,"line_start":306,"line_end":306,"column_start":6,"column_end":18},"value":"","parent":null,"children":[{"krate":0,"index":3610},{"krate":0,"index":3611},{"krate":0,"index":3612}],"docs":"","sig":null,"attributes":[]},{"id":94,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":582257,"byte_end":582269,"line_start":338,"line_end":338,"column_start":15,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":3614}],"docs":"","sig":null,"attributes":[]},{"id":95,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":582445,"byte_end":582457,"line_start":345,"line_end":345,"column_start":43,"column_end":55},"value":"","parent":null,"children":[{"krate":0,"index":3616},{"krate":0,"index":3617},{"krate":0,"index":3618},{"krate":0,"index":3619}],"docs":"","sig":null,"attributes":[]},{"id":96,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":583458,"byte_end":583469,"line_start":373,"line_end":373,"column_start":6,"column_end":17},"value":"","parent":null,"children":[{"krate":0,"index":3623},{"krate":0,"index":3624},{"krate":0,"index":3625},{"krate":0,"index":3626},{"krate":0,"index":3627},{"krate":0,"index":3628},{"krate":0,"index":3629},{"krate":0,"index":3630},{"krate":0,"index":3631},{"krate":0,"index":3632},{"krate":0,"index":3633},{"krate":0,"index":3634},{"krate":0,"index":3635},{"krate":0,"index":3636},{"krate":0,"index":3637},{"krate":0,"index":3638},{"krate":0,"index":3639},{"krate":0,"index":3640},{"krate":0,"index":3641},{"krate":0,"index":3642},{"krate":0,"index":3643},{"krate":0,"index":3644},{"krate":0,"index":3645},{"krate":0,"index":3646},{"krate":0,"index":3647},{"krate":0,"index":3648},{"krate":0,"index":3649},{"krate":0,"index":3650},{"krate":0,"index":3651},{"krate":0,"index":3652},{"krate":0,"index":3653},{"krate":0,"index":3654},{"krate":0,"index":3655},{"krate":0,"index":3656},{"krate":0,"index":3657}],"docs":"","sig":null,"attributes":[]},{"id":97,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":597369,"byte_end":597380,"line_start":615,"line_end":615,"column_start":15,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":3659}],"docs":"","sig":null,"attributes":[]},{"id":98,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":597552,"byte_end":597563,"line_start":622,"line_end":622,"column_start":41,"column_end":52},"value":"","parent":null,"children":[{"krate":0,"index":3661},{"krate":0,"index":3662},{"krate":0,"index":3663},{"krate":0,"index":3664}],"docs":"","sig":null,"attributes":[]},{"id":99,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":598704,"byte_end":598718,"line_start":654,"line_end":654,"column_start":6,"column_end":20},"value":"","parent":null,"children":[{"krate":0,"index":3668},{"krate":0,"index":3669},{"krate":0,"index":3670}],"docs":"","sig":null,"attributes":[]},{"id":100,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":600164,"byte_end":600178,"line_start":684,"line_end":684,"column_start":15,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":3672}],"docs":"","sig":null,"attributes":[]},{"id":101,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":600358,"byte_end":600372,"line_start":691,"line_end":691,"column_start":45,"column_end":59},"value":"","parent":null,"children":[{"krate":0,"index":3674},{"krate":0,"index":3675},{"krate":0,"index":3676},{"krate":0,"index":3677}],"docs":"","sig":null,"attributes":[]},{"id":102,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":689595,"byte_end":689615,"line_start":1357,"line_end":1357,"column_start":6,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":3711},{"krate":0,"index":3712},{"krate":0,"index":3714},{"krate":0,"index":3716},{"krate":0,"index":3718},{"krate":0,"index":3720},{"krate":0,"index":3722},{"krate":0,"index":3724},{"krate":0,"index":3726},{"krate":0,"index":3727},{"krate":0,"index":3728},{"krate":0,"index":3729},{"krate":0,"index":3730},{"krate":0,"index":3731},{"krate":0,"index":3732},{"krate":0,"index":3733},{"krate":0,"index":3734},{"krate":0,"index":3735}],"docs":"","sig":null,"attributes":[]},{"id":103,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":713730,"byte_end":713750,"line_start":2006,"line_end":2006,"column_start":15,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":3737}],"docs":"","sig":null,"attributes":[]},{"id":104,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":713942,"byte_end":713962,"line_start":2013,"line_end":2013,"column_start":51,"column_end":71},"value":"","parent":null,"children":[{"krate":0,"index":3739},{"krate":0,"index":3740},{"krate":0,"index":3741},{"krate":0,"index":3742}],"docs":"","sig":null,"attributes":[]},{"id":105,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":714773,"byte_end":714793,"line_start":2039,"line_end":2039,"column_start":6,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":3746},{"krate":0,"index":3747},{"krate":0,"index":3748}],"docs":"","sig":null,"attributes":[]},{"id":106,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":723442,"byte_end":723462,"line_start":2261,"line_end":2261,"column_start":15,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":3751}],"docs":"","sig":null,"attributes":[]},{"id":107,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":723656,"byte_end":723676,"line_start":2268,"line_end":2268,"column_start":52,"column_end":72},"value":"","parent":null,"children":[{"krate":0,"index":3753},{"krate":0,"index":3754},{"krate":0,"index":3755},{"krate":0,"index":3756}],"docs":"","sig":null,"attributes":[]},{"id":108,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":724517,"byte_end":724537,"line_start":2294,"line_end":2294,"column_start":6,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":3760},{"krate":0,"index":3761},{"krate":0,"index":3762},{"krate":0,"index":3763}],"docs":"","sig":null,"attributes":[]},{"id":109,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":739430,"byte_end":739450,"line_start":2689,"line_end":2689,"column_start":15,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":3766}],"docs":"","sig":null,"attributes":[]},{"id":110,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":739644,"byte_end":739664,"line_start":2696,"line_end":2696,"column_start":52,"column_end":72},"value":"","parent":null,"children":[{"krate":0,"index":3768},{"krate":0,"index":3769},{"krate":0,"index":3770},{"krate":0,"index":3771}],"docs":"","sig":null,"attributes":[]},{"id":111,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":741050,"byte_end":741064,"line_start":2728,"line_end":2728,"column_start":6,"column_end":20},"value":"","parent":null,"children":[{"krate":0,"index":3775},{"krate":0,"index":3776}],"docs":"","sig":null,"attributes":[]},{"id":112,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":763869,"byte_end":763883,"line_start":3237,"line_end":3237,"column_start":15,"column_end":29},"value":"","parent":null,"children":[{"krate":0,"index":3787}],"docs":"","sig":null,"attributes":[]},{"id":113,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":764087,"byte_end":764101,"line_start":3244,"line_end":3244,"column_start":57,"column_end":71},"value":"","parent":null,"children":[{"krate":0,"index":3789},{"krate":0,"index":3790},{"krate":0,"index":3791},{"krate":0,"index":3792}],"docs":"","sig":null,"attributes":[]},{"id":114,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":765148,"byte_end":765160,"line_start":3272,"line_end":3272,"column_start":6,"column_end":18},"value":"","parent":null,"children":[{"krate":0,"index":3796},{"krate":0,"index":3797},{"krate":0,"index":3798}],"docs":"","sig":null,"attributes":[]},{"id":115,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":767349,"byte_end":767361,"line_start":3328,"line_end":3328,"column_start":15,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":3801}],"docs":"","sig":null,"attributes":[]},{"id":116,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":767561,"byte_end":767573,"line_start":3335,"line_end":3335,"column_start":55,"column_end":67},"value":"","parent":null,"children":[{"krate":0,"index":3803},{"krate":0,"index":3804},{"krate":0,"index":3805},{"krate":0,"index":3806}],"docs":"","sig":null,"attributes":[]},{"id":117,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":817406,"byte_end":817417,"line_start":54,"line_end":54,"column_start":6,"column_end":17},"value":"","parent":null,"children":[{"krate":0,"index":3897},{"krate":0,"index":3898},{"krate":0,"index":3899}],"docs":"","sig":null,"attributes":[]},{"id":118,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":818635,"byte_end":818641,"line_start":84,"line_end":84,"column_start":6,"column_end":12},"value":"","parent":null,"children":[{"krate":0,"index":3903},{"krate":0,"index":3904},{"krate":0,"index":3905},{"krate":0,"index":3906}],"docs":"","sig":null,"attributes":[]},{"id":119,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":820599,"byte_end":820605,"line_start":135,"line_end":135,"column_start":15,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":3908}],"docs":"","sig":null,"attributes":[]},{"id":120,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":820777,"byte_end":820783,"line_start":142,"line_end":142,"column_start":36,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":3910},{"krate":0,"index":3911},{"krate":0,"index":3912},{"krate":0,"index":3913}],"docs":"","sig":null,"attributes":[]},{"id":121,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":821290,"byte_end":821300,"line_start":167,"line_end":167,"column_start":6,"column_end":16},"value":"","parent":null,"children":[{"krate":0,"index":3915},{"krate":0,"index":3916},{"krate":0,"index":3917},{"krate":0,"index":3918},{"krate":0,"index":3919},{"krate":0,"index":3920},{"krate":0,"index":3921}],"docs":"","sig":null,"attributes":[]},{"id":122,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":823656,"byte_end":823666,"line_start":211,"line_end":211,"column_start":41,"column_end":51},"value":"","parent":null,"children":[{"krate":0,"index":3923},{"krate":0,"index":3924},{"krate":0,"index":3925},{"krate":0,"index":3926}],"docs":"","sig":null,"attributes":[]},{"id":123,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":824210,"byte_end":824216,"line_start":236,"line_end":236,"column_start":6,"column_end":12},"value":"","parent":null,"children":[{"krate":0,"index":3930},{"krate":0,"index":3931},{"krate":0,"index":3932},{"krate":0,"index":3933},{"krate":0,"index":3934},{"krate":0,"index":3935},{"krate":0,"index":3936},{"krate":0,"index":3937},{"krate":0,"index":3938},{"krate":0,"index":3939},{"krate":0,"index":3940},{"krate":0,"index":3941}],"docs":"","sig":null,"attributes":[]},{"id":124,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":826464,"byte_end":826470,"line_start":302,"line_end":302,"column_start":15,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":3943}],"docs":"","sig":null,"attributes":[]},{"id":125,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":826642,"byte_end":826648,"line_start":309,"line_end":309,"column_start":36,"column_end":42},"value":"","parent":null,"children":[{"krate":0,"index":3945},{"krate":0,"index":3946},{"krate":0,"index":3947},{"krate":0,"index":3948}],"docs":"","sig":null,"attributes":[]},{"id":126,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mathieu.rs","byte_start":828410,"byte_end":828426,"line_start":29,"line_end":29,"column_start":6,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":3956},{"krate":0,"index":3957},{"krate":0,"index":3958},{"krate":0,"index":3959},{"krate":0,"index":3960},{"krate":0,"index":3961},{"krate":0,"index":3962},{"krate":0,"index":3963},{"krate":0,"index":3964},{"krate":0,"index":3965},{"krate":0,"index":3966},{"krate":0,"index":3967},{"krate":0,"index":3968}],"docs":"","sig":null,"attributes":[]},{"id":127,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mathieu.rs","byte_start":834735,"byte_end":834751,"line_start":139,"line_end":139,"column_start":15,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":3970}],"docs":"","sig":null,"attributes":[]},{"id":128,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mathieu.rs","byte_start":834937,"byte_end":834953,"line_start":146,"line_end":146,"column_start":50,"column_end":66},"value":"","parent":null,"children":[{"krate":0,"index":3972},{"krate":0,"index":3973},{"krate":0,"index":3974},{"krate":0,"index":3975}],"docs":"","sig":null,"attributes":[]},{"id":129,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":838164,"byte_end":838174,"line_start":63,"line_end":63,"column_start":6,"column_end":16},"value":"","parent":null,"children":[{"krate":0,"index":3989},{"krate":0,"index":3990},{"krate":0,"index":3991},{"krate":0,"index":3992},{"krate":0,"index":3993},{"krate":0,"index":3994}],"docs":"","sig":null,"attributes":[]},{"id":130,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":844848,"byte_end":844857,"line_start":189,"line_end":189,"column_start":6,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":3999},{"krate":0,"index":4000},{"krate":0,"index":4001},{"krate":0,"index":4002},{"krate":0,"index":4003},{"krate":0,"index":4004},{"krate":0,"index":4005},{"krate":0,"index":4006},{"krate":0,"index":4007},{"krate":0,"index":4008},{"krate":0,"index":4009},{"krate":0,"index":4010},{"krate":0,"index":4011},{"krate":0,"index":4012},{"krate":0,"index":4013},{"krate":0,"index":4014},{"krate":0,"index":4015},{"krate":0,"index":4016},{"krate":0,"index":4017},{"krate":0,"index":4018},{"krate":0,"index":4019},{"krate":0,"index":4020},{"krate":0,"index":4021},{"krate":0,"index":4022},{"krate":0,"index":4023},{"krate":0,"index":4024},{"krate":0,"index":4025},{"krate":0,"index":4026},{"krate":0,"index":4027},{"krate":0,"index":4028},{"krate":0,"index":4029},{"krate":0,"index":4030},{"krate":0,"index":4031},{"krate":0,"index":4032},{"krate":0,"index":4033},{"krate":0,"index":4034},{"krate":0,"index":4035},{"krate":0,"index":4036}],"docs":"","sig":null,"attributes":[]},{"id":131,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":857423,"byte_end":857432,"line_start":489,"line_end":489,"column_start":15,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":4038}],"docs":"","sig":null,"attributes":[]},{"id":132,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":857623,"byte_end":857632,"line_start":498,"line_end":498,"column_start":16,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":4040}],"docs":"","sig":null,"attributes":[]},{"id":133,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":858300,"byte_end":858309,"line_start":520,"line_end":520,"column_start":36,"column_end":45},"value":"","parent":null,"children":[{"krate":0,"index":4042},{"krate":0,"index":4043},{"krate":0,"index":4044},{"krate":0,"index":4045}],"docs":"","sig":null,"attributes":[]},{"id":134,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":858865,"byte_end":858874,"line_start":549,"line_end":549,"column_start":6,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":4050},{"krate":0,"index":4051},{"krate":0,"index":4052},{"krate":0,"index":4053},{"krate":0,"index":4054},{"krate":0,"index":4055},{"krate":0,"index":4056},{"krate":0,"index":4057},{"krate":0,"index":4058},{"krate":0,"index":4059},{"krate":0,"index":4060},{"krate":0,"index":4061},{"krate":0,"index":4062},{"krate":0,"index":4063},{"krate":0,"index":4064},{"krate":0,"index":4065},{"krate":0,"index":4066},{"krate":0,"index":4067},{"krate":0,"index":4068},{"krate":0,"index":4069},{"krate":0,"index":4070},{"krate":0,"index":4071},{"krate":0,"index":4072},{"krate":0,"index":4073},{"krate":0,"index":4074},{"krate":0,"index":4075},{"krate":0,"index":4076},{"krate":0,"index":4077},{"krate":0,"index":4078},{"krate":0,"index":4079},{"krate":0,"index":4080},{"krate":0,"index":4081},{"krate":0,"index":4082},{"krate":0,"index":4083},{"krate":0,"index":4084},{"krate":0,"index":4085}],"docs":"","sig":null,"attributes":[]},{"id":135,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":871398,"byte_end":871407,"line_start":835,"line_end":835,"column_start":15,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":4087}],"docs":"","sig":null,"attributes":[]},{"id":136,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":871604,"byte_end":871613,"line_start":844,"line_end":844,"column_start":16,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":4089}],"docs":"","sig":null,"attributes":[]},{"id":137,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":872287,"byte_end":872296,"line_start":866,"line_end":866,"column_start":42,"column_end":51},"value":"","parent":null,"children":[{"krate":0,"index":4091},{"krate":0,"index":4092},{"krate":0,"index":4093},{"krate":0,"index":4094}],"docs":"","sig":null,"attributes":[]},{"id":138,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":873113,"byte_end":873129,"line_start":16,"line_end":16,"column_start":6,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":4111},{"krate":0,"index":4112},{"krate":0,"index":4113},{"krate":0,"index":4114},{"krate":0,"index":4115},{"krate":0,"index":4116},{"krate":0,"index":4117},{"krate":0,"index":4118},{"krate":0,"index":4119},{"krate":0,"index":4120},{"krate":0,"index":4121},{"krate":0,"index":4122},{"krate":0,"index":4123},{"krate":0,"index":4124},{"krate":0,"index":4125},{"krate":0,"index":4126},{"krate":0,"index":4127},{"krate":0,"index":4128},{"krate":0,"index":4129},{"krate":0,"index":4130},{"krate":0,"index":4131},{"krate":0,"index":4132},{"krate":0,"index":4133},{"krate":0,"index":4134},{"krate":0,"index":4135},{"krate":0,"index":4136},{"krate":0,"index":4137},{"krate":0,"index":4138},{"krate":0,"index":4139},{"krate":0,"index":4140}],"docs":"","sig":null,"attributes":[]},{"id":139,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":883823,"byte_end":883839,"line_start":255,"line_end":255,"column_start":15,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":4142}],"docs":"","sig":null,"attributes":[]},{"id":140,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":883993,"byte_end":884009,"line_start":262,"line_end":262,"column_start":16,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":4144}],"docs":"","sig":null,"attributes":[]},{"id":141,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":884689,"byte_end":884705,"line_start":284,"line_end":284,"column_start":44,"column_end":60},"value":"","parent":null,"children":[{"krate":0,"index":4146},{"krate":0,"index":4147},{"krate":0,"index":4148},{"krate":0,"index":4149}],"docs":"","sig":null,"attributes":[]},{"id":142,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":885237,"byte_end":885253,"line_start":308,"line_end":308,"column_start":6,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":4153},{"krate":0,"index":4154},{"krate":0,"index":4155},{"krate":0,"index":4156},{"krate":0,"index":4157},{"krate":0,"index":4158},{"krate":0,"index":4159},{"krate":0,"index":4160},{"krate":0,"index":4161},{"krate":0,"index":4162},{"krate":0,"index":4163},{"krate":0,"index":4164},{"krate":0,"index":4165},{"krate":0,"index":4166},{"krate":0,"index":4167},{"krate":0,"index":4168},{"krate":0,"index":4169},{"krate":0,"index":4170},{"krate":0,"index":4171},{"krate":0,"index":4172},{"krate":0,"index":4173},{"krate":0,"index":4174},{"krate":0,"index":4175},{"krate":0,"index":4176},{"krate":0,"index":4177},{"krate":0,"index":4178},{"krate":0,"index":4179},{"krate":0,"index":4180},{"krate":0,"index":4181},{"krate":0,"index":4182}],"docs":"","sig":null,"attributes":[]},{"id":143,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":896191,"byte_end":896207,"line_start":552,"line_end":552,"column_start":15,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":4184}],"docs":"","sig":null,"attributes":[]},{"id":144,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":896367,"byte_end":896383,"line_start":559,"line_end":559,"column_start":16,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":4186}],"docs":"","sig":null,"attributes":[]},{"id":145,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":897069,"byte_end":897085,"line_start":581,"line_end":581,"column_start":50,"column_end":66},"value":"","parent":null,"children":[{"krate":0,"index":4188},{"krate":0,"index":4189},{"krate":0,"index":4190},{"krate":0,"index":4191}],"docs":"","sig":null,"attributes":[]},{"id":146,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/minimizer.rs","byte_start":903643,"byte_end":903652,"line_start":120,"line_end":120,"column_start":9,"column_end":18},"value":"","parent":null,"children":[{"krate":0,"index":4219},{"krate":0,"index":4220},{"krate":0,"index":4221},{"krate":0,"index":4222},{"krate":0,"index":4223},{"krate":0,"index":4224},{"krate":0,"index":4225},{"krate":0,"index":4226},{"krate":0,"index":4227},{"krate":0,"index":4228},{"krate":0,"index":4229}],"docs":"","sig":null,"attributes":[]},{"id":147,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/minimizer.rs","byte_start":909612,"byte_end":909621,"line_start":269,"line_end":269,"column_start":18,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":4232}],"docs":"","sig":null,"attributes":[]},{"id":148,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/minimizer.rs","byte_start":910198,"byte_end":910211,"line_start":285,"line_end":285,"column_start":9,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":4241},{"krate":0,"index":4242},{"krate":0,"index":4243}],"docs":"","sig":null,"attributes":[]},{"id":149,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/minimizer.rs","byte_start":912867,"byte_end":912880,"line_start":331,"line_end":331,"column_start":19,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":4246}],"docs":"","sig":null,"attributes":[]},{"id":150,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":932229,"byte_end":932244,"line_start":97,"line_end":97,"column_start":6,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":4289},{"krate":0,"index":4290},{"krate":0,"index":4291}],"docs":"","sig":null,"attributes":[]},{"id":151,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":935395,"byte_end":935410,"line_start":163,"line_end":163,"column_start":15,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":4294}],"docs":"","sig":null,"attributes":[]},{"id":152,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":935588,"byte_end":935603,"line_start":170,"line_end":170,"column_start":47,"column_end":62},"value":"","parent":null,"children":[{"krate":0,"index":4296},{"krate":0,"index":4297},{"krate":0,"index":4298},{"krate":0,"index":4299}],"docs":"","sig":null,"attributes":[]},{"id":153,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":937973,"byte_end":937988,"line_start":215,"line_end":215,"column_start":6,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":4303},{"krate":0,"index":4304},{"krate":0,"index":4305},{"krate":0,"index":4307},{"krate":0,"index":4308}],"docs":"","sig":null,"attributes":[]},{"id":154,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":941975,"byte_end":941990,"line_start":304,"line_end":304,"column_start":15,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":4310}],"docs":"","sig":null,"attributes":[]},{"id":155,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":942168,"byte_end":942183,"line_start":311,"line_end":311,"column_start":47,"column_end":62},"value":"","parent":null,"children":[{"krate":0,"index":4312},{"krate":0,"index":4313},{"krate":0,"index":4314},{"krate":0,"index":4315}],"docs":"","sig":null,"attributes":[]},{"id":156,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":948725,"byte_end":948740,"line_start":419,"line_end":419,"column_start":6,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":4325},{"krate":0,"index":4326},{"krate":0,"index":4327},{"krate":0,"index":4329},{"krate":0,"index":4330},{"krate":0,"index":4331},{"krate":0,"index":4332}],"docs":"","sig":null,"attributes":[]},{"id":157,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":953663,"byte_end":953674,"line_start":525,"line_end":525,"column_start":10,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":4339}],"docs":"","sig":null,"attributes":[]},{"id":158,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":956807,"byte_end":956818,"line_start":589,"line_end":589,"column_start":38,"column_end":49},"value":"","parent":null,"children":[{"krate":0,"index":4342}],"docs":"","sig":null,"attributes":[]},{"id":159,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":957680,"byte_end":957694,"line_start":617,"line_end":617,"column_start":6,"column_end":20},"value":"","parent":null,"children":[{"krate":0,"index":4344},{"krate":0,"index":4345}],"docs":"","sig":null,"attributes":[]},{"id":160,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":958081,"byte_end":958096,"line_start":635,"line_end":635,"column_start":15,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":4347}],"docs":"","sig":null,"attributes":[]},{"id":161,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":958274,"byte_end":958289,"line_start":642,"line_end":642,"column_start":47,"column_end":62},"value":"","parent":null,"children":[{"krate":0,"index":4349},{"krate":0,"index":4350},{"krate":0,"index":4351},{"krate":0,"index":4352}],"docs":"","sig":null,"attributes":[]},{"id":162,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":970892,"byte_end":970911,"line_start":224,"line_end":224,"column_start":51,"column_end":70},"value":"","parent":null,"children":[{"krate":0,"index":4361},{"krate":0,"index":4362},{"krate":0,"index":4363},{"krate":0,"index":4364}],"docs":"","sig":null,"attributes":[]},{"id":163,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":971475,"byte_end":971490,"line_start":248,"line_end":248,"column_start":6,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":4368},{"krate":0,"index":4369},{"krate":0,"index":4370},{"krate":0,"index":4371},{"krate":0,"index":4372}],"docs":"","sig":null,"attributes":[]},{"id":164,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":972951,"byte_end":972966,"line_start":290,"line_end":290,"column_start":15,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":4374}],"docs":"","sig":null,"attributes":[]},{"id":165,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":973148,"byte_end":973163,"line_start":297,"line_end":297,"column_start":46,"column_end":61},"value":"","parent":null,"children":[{"krate":0,"index":4376},{"krate":0,"index":4377},{"krate":0,"index":4378},{"krate":0,"index":4379}],"docs":"","sig":null,"attributes":[]},{"id":166,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":974022,"byte_end":974039,"line_start":332,"line_end":332,"column_start":6,"column_end":23},"value":"","parent":null,"children":[{"krate":0,"index":4388},{"krate":0,"index":4389},{"krate":0,"index":4390},{"krate":0,"index":4391},{"krate":0,"index":4392},{"krate":0,"index":4393},{"krate":0,"index":4394},{"krate":0,"index":4395},{"krate":0,"index":4396},{"krate":0,"index":4397}],"docs":"","sig":null,"attributes":[]},{"id":167,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":977524,"byte_end":977541,"line_start":426,"line_end":426,"column_start":15,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":4399}],"docs":"","sig":null,"attributes":[]},{"id":168,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":977858,"byte_end":977879,"line_start":440,"line_end":440,"column_start":6,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":4403},{"krate":0,"index":4404}],"docs":"","sig":null,"attributes":[]},{"id":169,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":978540,"byte_end":978559,"line_start":463,"line_end":463,"column_start":6,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":4413},{"krate":0,"index":4414}],"docs":"","sig":null,"attributes":[]},{"id":170,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multiset.rs","byte_start":981260,"byte_end":981268,"line_start":25,"line_end":25,"column_start":6,"column_end":14},"value":"","parent":null,"children":[{"krate":0,"index":4428},{"krate":0,"index":4429},{"krate":0,"index":4430},{"krate":0,"index":4431},{"krate":0,"index":4432},{"krate":0,"index":4433},{"krate":0,"index":4434},{"krate":0,"index":4435},{"krate":0,"index":4436},{"krate":0,"index":4438},{"krate":0,"index":4439},{"krate":0,"index":4440},{"krate":0,"index":4441}],"docs":"","sig":null,"attributes":[]},{"id":171,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multiset.rs","byte_start":986275,"byte_end":986283,"line_start":143,"line_end":143,"column_start":15,"column_end":23},"value":"","parent":null,"children":[{"krate":0,"index":4443}],"docs":"","sig":null,"attributes":[]},{"id":172,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multiset.rs","byte_start":986449,"byte_end":986457,"line_start":150,"line_end":150,"column_start":38,"column_end":46},"value":"","parent":null,"children":[{"krate":0,"index":4445},{"krate":0,"index":4446},{"krate":0,"index":4447},{"krate":0,"index":4448}],"docs":"","sig":null,"attributes":[]},{"id":173,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/n_tuples.rs","byte_start":988983,"byte_end":988990,"line_start":43,"line_end":43,"column_start":9,"column_end":16},"value":"","parent":null,"children":[{"krate":0,"index":4464},{"krate":0,"index":4465},{"krate":0,"index":4466},{"krate":0,"index":4467},{"krate":0,"index":4468},{"krate":0,"index":4469}],"docs":"","sig":null,"attributes":[]},{"id":174,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/n_tuples.rs","byte_start":992299,"byte_end":992306,"line_start":123,"line_end":123,"column_start":18,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":4474}],"docs":"","sig":null,"attributes":[]},{"id":175,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/n_tuples.rs","byte_start":992475,"byte_end":992482,"line_start":130,"line_end":130,"column_start":39,"column_end":46},"value":"","parent":null,"children":[{"krate":0,"index":4477},{"krate":0,"index":4478},{"krate":0,"index":4479},{"krate":0,"index":4480}],"docs":"","sig":null,"attributes":[]},{"id":176,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":996737,"byte_end":996749,"line_start":80,"line_end":80,"column_start":10,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":4494},{"krate":0,"index":4495},{"krate":0,"index":4496}],"docs":"","sig":null,"attributes":[]},{"id":177,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":999379,"byte_end":999389,"line_start":153,"line_end":153,"column_start":6,"column_end":16},"value":"","parent":null,"children":[{"krate":0,"index":4502},{"krate":0,"index":4503},{"krate":0,"index":4504},{"krate":0,"index":4505},{"krate":0,"index":4506},{"krate":0,"index":4507}],"docs":"","sig":null,"attributes":[]},{"id":178,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1003839,"byte_end":1003849,"line_start":228,"line_end":228,"column_start":15,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":4509}],"docs":"","sig":null,"attributes":[]},{"id":179,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1004021,"byte_end":1004031,"line_start":235,"line_end":235,"column_start":41,"column_end":51},"value":"","parent":null,"children":[{"krate":0,"index":4511},{"krate":0,"index":4512},{"krate":0,"index":4513},{"krate":0,"index":4514}],"docs":"","sig":null,"attributes":[]},{"id":180,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1004520,"byte_end":1004534,"line_start":260,"line_end":260,"column_start":6,"column_end":20},"value":"","parent":null,"children":[{"krate":0,"index":4516},{"krate":0,"index":4517},{"krate":0,"index":4518},{"krate":0,"index":4519},{"krate":0,"index":4520},{"krate":0,"index":4521},{"krate":0,"index":4522},{"krate":0,"index":4523},{"krate":0,"index":4524},{"krate":0,"index":4525},{"krate":0,"index":4526}],"docs":"","sig":null,"attributes":[]},{"id":181,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1008677,"byte_end":1008691,"line_start":371,"line_end":371,"column_start":46,"column_end":60},"value":"","parent":null,"children":[{"krate":0,"index":4528},{"krate":0,"index":4529},{"krate":0,"index":4530},{"krate":0,"index":4531}],"docs":"","sig":null,"attributes":[]},{"id":182,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1009262,"byte_end":1009275,"line_start":395,"line_end":395,"column_start":6,"column_end":19},"value":"","parent":null,"children":[{"krate":0,"index":4535},{"krate":0,"index":4536},{"krate":0,"index":4537},{"krate":0,"index":4538},{"krate":0,"index":4539},{"krate":0,"index":4540},{"krate":0,"index":4541},{"krate":0,"index":4542},{"krate":0,"index":4543},{"krate":0,"index":4544}],"docs":"","sig":null,"attributes":[]},{"id":183,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1016343,"byte_end":1016356,"line_start":538,"line_end":538,"column_start":15,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":4546}],"docs":"","sig":null,"attributes":[]},{"id":184,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1016534,"byte_end":1016547,"line_start":545,"line_end":545,"column_start":44,"column_end":57},"value":"","parent":null,"children":[{"krate":0,"index":4548},{"krate":0,"index":4549},{"krate":0,"index":4550},{"krate":0,"index":4551}],"docs":"","sig":null,"attributes":[]},{"id":185,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1017069,"byte_end":1017086,"line_start":570,"line_end":570,"column_start":6,"column_end":23},"value":"","parent":null,"children":[{"krate":0,"index":4553},{"krate":0,"index":4554}],"docs":"","sig":null,"attributes":[]},{"id":186,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1017489,"byte_end":1017506,"line_start":588,"line_end":588,"column_start":49,"column_end":66},"value":"","parent":null,"children":[{"krate":0,"index":4556},{"krate":0,"index":4557},{"krate":0,"index":4558},{"krate":0,"index":4559}],"docs":"","sig":null,"attributes":[]},{"id":187,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1018108,"byte_end":1018120,"line_start":612,"line_end":612,"column_start":6,"column_end":18},"value":"","parent":null,"children":[{"krate":0,"index":4563},{"krate":0,"index":4564},{"krate":0,"index":4565},{"krate":0,"index":4566},{"krate":0,"index":4567}],"docs":"","sig":null,"attributes":[]},{"id":188,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1022494,"byte_end":1022506,"line_start":681,"line_end":681,"column_start":15,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":4569}],"docs":"","sig":null,"attributes":[]},{"id":189,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1022682,"byte_end":1022694,"line_start":688,"line_end":688,"column_start":43,"column_end":55},"value":"","parent":null,"children":[{"krate":0,"index":4571},{"krate":0,"index":4572},{"krate":0,"index":4573},{"krate":0,"index":4574}],"docs":"","sig":null,"attributes":[]},{"id":190,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1023497,"byte_end":1023509,"line_start":718,"line_end":718,"column_start":10,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":4582},{"krate":0,"index":4583},{"krate":0,"index":4584},{"krate":0,"index":4585},{"krate":0,"index":4586},{"krate":0,"index":4587},{"krate":0,"index":4588},{"krate":0,"index":4589},{"krate":0,"index":4590},{"krate":0,"index":4591},{"krate":0,"index":4592}],"docs":"","sig":null,"attributes":[]},{"id":191,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1030521,"byte_end":1030533,"line_start":843,"line_end":843,"column_start":19,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":4595}],"docs":"","sig":null,"attributes":[]},{"id":192,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":1033455,"byte_end":1033466,"line_start":42,"line_end":42,"column_start":6,"column_end":17},"value":"","parent":null,"children":[{"krate":0,"index":4610},{"krate":0,"index":4611},{"krate":0,"index":4612},{"krate":0,"index":4613},{"krate":0,"index":4614},{"krate":0,"index":4615},{"krate":0,"index":4616},{"krate":0,"index":4617},{"krate":0,"index":4619},{"krate":0,"index":4620},{"krate":0,"index":4621},{"krate":0,"index":4622},{"krate":0,"index":4623},{"krate":0,"index":4624},{"krate":0,"index":4625},{"krate":0,"index":4626},{"krate":0,"index":4627},{"krate":0,"index":4628},{"krate":0,"index":4629},{"krate":0,"index":4630},{"krate":0,"index":4631},{"krate":0,"index":4632},{"krate":0,"index":4633}],"docs":"","sig":null,"attributes":[]},{"id":193,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":1041366,"byte_end":1041377,"line_start":203,"line_end":203,"column_start":15,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":4635}],"docs":"","sig":null,"attributes":[]},{"id":194,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":1041549,"byte_end":1041560,"line_start":210,"line_end":210,"column_start":41,"column_end":52},"value":"","parent":null,"children":[{"krate":0,"index":4637},{"krate":0,"index":4638},{"krate":0,"index":4639},{"krate":0,"index":4640}],"docs":"","sig":null,"attributes":[]},{"id":195,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":1042084,"byte_end":1042095,"line_start":233,"line_end":233,"column_start":16,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":4642}],"docs":"","sig":null,"attributes":[]},{"id":196,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/polynomial.rs","byte_start":1042930,"byte_end":1042941,"line_start":19,"line_end":19,"column_start":6,"column_end":17},"value":"","parent":null,"children":[{"krate":0,"index":4649},{"krate":0,"index":4650}],"docs":"","sig":null,"attributes":[]},{"id":197,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/polynomial.rs","byte_start":1044894,"byte_end":1044905,"line_start":53,"line_end":53,"column_start":15,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":4652}],"docs":"","sig":null,"attributes":[]},{"id":198,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/polynomial.rs","byte_start":1045099,"byte_end":1045110,"line_start":60,"line_end":60,"column_start":52,"column_end":63},"value":"","parent":null,"children":[{"krate":0,"index":4654},{"krate":0,"index":4655},{"krate":0,"index":4656},{"krate":0,"index":4657}],"docs":"","sig":null,"attributes":[]},{"id":199,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/qrng.rs","byte_start":1046675,"byte_end":1046679,"line_start":31,"line_end":31,"column_start":6,"column_end":10},"value":"","parent":null,"children":[{"krate":0,"index":4667},{"krate":0,"index":4668},{"krate":0,"index":4669},{"krate":0,"index":4670},{"krate":0,"index":4671},{"krate":0,"index":4672},{"krate":0,"index":4674}],"docs":"","sig":null,"attributes":[]},{"id":200,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/qrng.rs","byte_start":1049195,"byte_end":1049199,"line_start":93,"line_end":93,"column_start":16,"column_end":20},"value":"","parent":null,"children":[{"krate":0,"index":4676}],"docs":"","sig":null,"attributes":[]},{"id":201,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/qrng.rs","byte_start":1049433,"byte_end":1049437,"line_start":100,"line_end":100,"column_start":15,"column_end":19},"value":"","parent":null,"children":[{"krate":0,"index":4678}],"docs":"","sig":null,"attributes":[]},{"id":202,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/qrng.rs","byte_start":1049595,"byte_end":1049599,"line_start":107,"line_end":107,"column_start":34,"column_end":38},"value":"","parent":null,"children":[{"krate":0,"index":4680},{"krate":0,"index":4681},{"krate":0,"index":4682},{"krate":0,"index":4683}],"docs":"","sig":null,"attributes":[]},{"id":203,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/qrng.rs","byte_start":1050092,"byte_end":1050100,"line_start":133,"line_end":133,"column_start":6,"column_end":14},"value":"","parent":null,"children":[{"krate":0,"index":4685},{"krate":0,"index":4686},{"krate":0,"index":4687},{"krate":0,"index":4688}],"docs":"","sig":null,"attributes":[]},{"id":204,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/qrng.rs","byte_start":1051362,"byte_end":1051370,"line_start":173,"line_end":173,"column_start":39,"column_end":47},"value":"","parent":null,"children":[{"krate":0,"index":4690},{"krate":0,"index":4691},{"krate":0,"index":4692},{"krate":0,"index":4693}],"docs":"","sig":null,"attributes":[]},{"id":205,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ran_discrete.rs","byte_start":1054249,"byte_end":1054260,"line_start":29,"line_end":29,"column_start":6,"column_end":17},"value":"","parent":null,"children":[{"krate":0,"index":4700},{"krate":0,"index":4701},{"krate":0,"index":4702}],"docs":"","sig":null,"attributes":[]},{"id":206,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ran_discrete.rs","byte_start":1055734,"byte_end":1055745,"line_start":57,"line_end":57,"column_start":15,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":4704}],"docs":"","sig":null,"attributes":[]},{"id":207,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ran_discrete.rs","byte_start":1055925,"byte_end":1055936,"line_start":64,"line_end":64,"column_start":44,"column_end":55},"value":"","parent":null,"children":[{"krate":0,"index":4706},{"krate":0,"index":4707},{"krate":0,"index":4708},{"krate":0,"index":4709}],"docs":"","sig":null,"attributes":[]},{"id":208,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/result.rs","byte_start":1056882,"byte_end":1056888,"line_start":17,"line_end":17,"column_start":18,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":4713}],"docs":"","sig":null,"attributes":[]},{"id":209,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/result.rs","byte_start":1056956,"byte_end":1056962,"line_start":23,"line_end":23,"column_start":6,"column_end":12},"value":"","parent":null,"children":[{"krate":0,"index":4715}],"docs":"","sig":null,"attributes":[]},{"id":210,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/result.rs","byte_start":1057641,"byte_end":1057650,"line_start":44,"line_end":44,"column_start":18,"column_end":27},"value":"","parent":null,"children":[{"krate":0,"index":4717}],"docs":"","sig":null,"attributes":[]},{"id":211,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/result.rs","byte_start":1057724,"byte_end":1057733,"line_start":50,"line_end":50,"column_start":6,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":4719}],"docs":"","sig":null,"attributes":[]},{"id":212,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1063984,"byte_end":1063987,"line_start":81,"line_end":81,"column_start":6,"column_end":9},"value":"","parent":null,"children":[{"krate":0,"index":4727},{"krate":0,"index":4728},{"krate":0,"index":4729},{"krate":0,"index":4730},{"krate":0,"index":4731},{"krate":0,"index":4732},{"krate":0,"index":4733},{"krate":0,"index":4734},{"krate":0,"index":4735},{"krate":0,"index":4736},{"krate":0,"index":4739},{"krate":0,"index":4740},{"krate":0,"index":4741}],"docs":"","sig":null,"attributes":[]},{"id":213,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1071291,"byte_end":1071294,"line_start":206,"line_end":206,"column_start":16,"column_end":19},"value":"","parent":null,"children":[{"krate":0,"index":4743}],"docs":"","sig":null,"attributes":[]},{"id":214,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1071523,"byte_end":1071526,"line_start":213,"line_end":213,"column_start":15,"column_end":18},"value":"","parent":null,"children":[{"krate":0,"index":4745}],"docs":"","sig":null,"attributes":[]},{"id":215,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1071682,"byte_end":1071685,"line_start":220,"line_end":220,"column_start":33,"column_end":36},"value":"","parent":null,"children":[{"krate":0,"index":4747},{"krate":0,"index":4748},{"krate":0,"index":4749},{"krate":0,"index":4750}],"docs":"","sig":null,"attributes":[]},{"id":216,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1072104,"byte_end":1072111,"line_start":245,"line_end":245,"column_start":6,"column_end":13},"value":"","parent":null,"children":[{"krate":0,"index":4752},{"krate":0,"index":4753},{"krate":0,"index":4754},{"krate":0,"index":4755},{"krate":0,"index":4756},{"krate":0,"index":4757}],"docs":"","sig":null,"attributes":[]},{"id":217,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1075205,"byte_end":1075212,"line_start":337,"line_end":337,"column_start":38,"column_end":45},"value":"","parent":null,"children":[{"krate":0,"index":4759},{"krate":0,"index":4760},{"krate":0,"index":4761},{"krate":0,"index":4762}],"docs":"","sig":null,"attributes":[]},{"id":218,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1112836,"byte_end":1112851,"line_start":58,"line_end":58,"column_start":47,"column_end":62},"value":"","parent":null,"children":[{"krate":0,"index":4818},{"krate":0,"index":4819},{"krate":0,"index":4820},{"krate":0,"index":4821}],"docs":"","sig":null,"attributes":[]},{"id":219,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1113287,"byte_end":1113302,"line_start":76,"line_end":76,"column_start":6,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":4823},{"krate":0,"index":4824},{"krate":0,"index":4825}],"docs":"","sig":null,"attributes":[]},{"id":220,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1116289,"byte_end":1116300,"line_start":132,"line_end":132,"column_start":6,"column_end":17},"value":"","parent":null,"children":[{"krate":0,"index":4830},{"krate":0,"index":4831},{"krate":0,"index":4832},{"krate":0,"index":4833},{"krate":0,"index":4834},{"krate":0,"index":4835},{"krate":0,"index":4836}],"docs":"","sig":null,"attributes":[]},{"id":221,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1118845,"byte_end":1118856,"line_start":194,"line_end":194,"column_start":15,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":4838}],"docs":"","sig":null,"attributes":[]},{"id":222,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1119633,"byte_end":1119650,"line_start":215,"line_end":215,"column_start":49,"column_end":66},"value":"","parent":null,"children":[{"krate":0,"index":4842},{"krate":0,"index":4843},{"krate":0,"index":4844},{"krate":0,"index":4845}],"docs":"","sig":null,"attributes":[]},{"id":223,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1120104,"byte_end":1120121,"line_start":233,"line_end":233,"column_start":6,"column_end":23},"value":"","parent":null,"children":[{"krate":0,"index":4847},{"krate":0,"index":4848},{"krate":0,"index":4849}],"docs":"","sig":null,"attributes":[]},{"id":224,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1121279,"byte_end":1121292,"line_start":261,"line_end":261,"column_start":6,"column_end":19},"value":"","parent":null,"children":[{"krate":0,"index":4854},{"krate":0,"index":4855},{"krate":0,"index":4856},{"krate":0,"index":4857},{"krate":0,"index":4858}],"docs":"","sig":null,"attributes":[]},{"id":225,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1123488,"byte_end":1123501,"line_start":314,"line_end":314,"column_start":15,"column_end":28},"value":"","parent":null,"children":[{"krate":0,"index":4860}],"docs":"","sig":null,"attributes":[]},{"id":226,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/series_acceleration.rs","byte_start":1127002,"byte_end":1127017,"line_start":60,"line_end":60,"column_start":6,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":4867},{"krate":0,"index":4868},{"krate":0,"index":4869},{"krate":0,"index":4870},{"krate":0,"index":4871}],"docs":"","sig":null,"attributes":[]},{"id":227,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/series_acceleration.rs","byte_start":1128614,"byte_end":1128629,"line_start":98,"line_end":98,"column_start":15,"column_end":30},"value":"","parent":null,"children":[{"krate":0,"index":4873}],"docs":"","sig":null,"attributes":[]},{"id":228,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/series_acceleration.rs","byte_start":1128811,"byte_end":1128826,"line_start":105,"line_end":105,"column_start":51,"column_end":66},"value":"","parent":null,"children":[{"krate":0,"index":4875},{"krate":0,"index":4876},{"krate":0,"index":4877},{"krate":0,"index":4878}],"docs":"","sig":null,"attributes":[]},{"id":229,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/series_acceleration.rs","byte_start":1129670,"byte_end":1129690,"line_start":132,"line_end":132,"column_start":6,"column_end":26},"value":"","parent":null,"children":[{"krate":0,"index":4882},{"krate":0,"index":4883},{"krate":0,"index":4884},{"krate":0,"index":4885},{"krate":0,"index":4886}],"docs":"","sig":null,"attributes":[]},{"id":230,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/series_acceleration.rs","byte_start":1131395,"byte_end":1131415,"line_start":171,"line_end":171,"column_start":15,"column_end":35},"value":"","parent":null,"children":[{"krate":0,"index":4888}],"docs":"","sig":null,"attributes":[]},{"id":231,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/series_acceleration.rs","byte_start":1131607,"byte_end":1131627,"line_start":178,"line_end":178,"column_start":56,"column_end":76},"value":"","parent":null,"children":[{"krate":0,"index":4890},{"krate":0,"index":4891},{"krate":0,"index":4892},{"krate":0,"index":4893}],"docs":"","sig":null,"attributes":[]},{"id":232,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/siman.rs","byte_start":1134704,"byte_end":1134716,"line_start":60,"line_end":60,"column_start":9,"column_end":21},"value":"","parent":null,"children":[{"krate":0,"index":4915},{"krate":0,"index":4916},{"krate":0,"index":4917}],"docs":"","sig":null,"attributes":[]},{"id":233,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/siman.rs","byte_start":1149457,"byte_end":1149475,"line_start":479,"line_end":479,"column_start":6,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":4927}],"docs":"","sig":null,"attributes":[]},{"id":234,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1152081,"byte_end":1152091,"line_start":42,"line_end":42,"column_start":6,"column_end":16},"value":"","parent":null,"children":[{"krate":0,"index":4938},{"krate":0,"index":4939},{"krate":0,"index":4940},{"krate":0,"index":4941},{"krate":0,"index":4942}],"docs":"","sig":null,"attributes":[]},{"id":235,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1157722,"byte_end":1157731,"line_start":156,"line_end":156,"column_start":6,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":4947},{"krate":0,"index":4948},{"krate":0,"index":4949},{"krate":0,"index":4950},{"krate":0,"index":4951},{"krate":0,"index":4952},{"krate":0,"index":4953},{"krate":0,"index":4954},{"krate":0,"index":4955},{"krate":0,"index":4956},{"krate":0,"index":4957},{"krate":0,"index":4958},{"krate":0,"index":4959},{"krate":0,"index":4960},{"krate":0,"index":4961},{"krate":0,"index":4962},{"krate":0,"index":4963},{"krate":0,"index":4964},{"krate":0,"index":4965},{"krate":0,"index":4966},{"krate":0,"index":4967},{"krate":0,"index":4968},{"krate":0,"index":4969},{"krate":0,"index":4970},{"krate":0,"index":4971},{"krate":0,"index":4972},{"krate":0,"index":4973},{"krate":0,"index":4974},{"krate":0,"index":4975},{"krate":0,"index":4976},{"krate":0,"index":4977}],"docs":"","sig":null,"attributes":[]},{"id":236,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1167184,"byte_end":1167193,"line_start":399,"line_end":399,"column_start":15,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":4979}],"docs":"","sig":null,"attributes":[]},{"id":237,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1167390,"byte_end":1167399,"line_start":408,"line_end":408,"column_start":16,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":4981}],"docs":"","sig":null,"attributes":[]},{"id":238,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1167867,"byte_end":1167876,"line_start":425,"line_end":425,"column_start":42,"column_end":51},"value":"","parent":null,"children":[{"krate":0,"index":4983},{"krate":0,"index":4984},{"krate":0,"index":4985},{"krate":0,"index":4986}],"docs":"","sig":null,"attributes":[]},{"id":239,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1168450,"byte_end":1168459,"line_start":454,"line_end":454,"column_start":6,"column_end":15},"value":"","parent":null,"children":[{"krate":0,"index":4991},{"krate":0,"index":4992},{"krate":0,"index":4993},{"krate":0,"index":4994},{"krate":0,"index":4995},{"krate":0,"index":4996},{"krate":0,"index":4997},{"krate":0,"index":4998},{"krate":0,"index":4999},{"krate":0,"index":5000},{"krate":0,"index":5001},{"krate":0,"index":5002},{"krate":0,"index":5003},{"krate":0,"index":5004},{"krate":0,"index":5005},{"krate":0,"index":5006},{"krate":0,"index":5007},{"krate":0,"index":5008},{"krate":0,"index":5009},{"krate":0,"index":5010},{"krate":0,"index":5011},{"krate":0,"index":5012},{"krate":0,"index":5013},{"krate":0,"index":5014},{"krate":0,"index":5015},{"krate":0,"index":5016},{"krate":0,"index":5017},{"krate":0,"index":5018},{"krate":0,"index":5019},{"krate":0,"index":5020},{"krate":0,"index":5021}],"docs":"","sig":null,"attributes":[]},{"id":240,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1177736,"byte_end":1177745,"line_start":697,"line_end":697,"column_start":15,"column_end":24},"value":"","parent":null,"children":[{"krate":0,"index":5023}],"docs":"","sig":null,"attributes":[]},{"id":241,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1177936,"byte_end":1177945,"line_start":706,"line_end":706,"column_start":16,"column_end":25},"value":"","parent":null,"children":[{"krate":0,"index":5025}],"docs":"","sig":null,"attributes":[]},{"id":242,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1178407,"byte_end":1178416,"line_start":723,"line_end":723,"column_start":36,"column_end":45},"value":"","parent":null,"children":[{"krate":0,"index":5027},{"krate":0,"index":5028},{"krate":0,"index":5029},{"krate":0,"index":5030}],"docs":"","sig":null,"attributes":[]},{"id":243,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1179160,"byte_end":1179176,"line_start":15,"line_end":15,"column_start":6,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":5044},{"krate":0,"index":5045},{"krate":0,"index":5046},{"krate":0,"index":5047},{"krate":0,"index":5048},{"krate":0,"index":5049},{"krate":0,"index":5050},{"krate":0,"index":5051},{"krate":0,"index":5052},{"krate":0,"index":5053},{"krate":0,"index":5054},{"krate":0,"index":5055},{"krate":0,"index":5056},{"krate":0,"index":5057},{"krate":0,"index":5058},{"krate":0,"index":5059},{"krate":0,"index":5060},{"krate":0,"index":5061},{"krate":0,"index":5062},{"krate":0,"index":5063},{"krate":0,"index":5064},{"krate":0,"index":5065},{"krate":0,"index":5066},{"krate":0,"index":5067},{"krate":0,"index":5068},{"krate":0,"index":5069}],"docs":"","sig":null,"attributes":[]},{"id":244,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1187357,"byte_end":1187373,"line_start":224,"line_end":224,"column_start":15,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":5071}],"docs":"","sig":null,"attributes":[]},{"id":245,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1187527,"byte_end":1187543,"line_start":231,"line_end":231,"column_start":16,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":5073}],"docs":"","sig":null,"attributes":[]},{"id":246,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1188017,"byte_end":1188033,"line_start":248,"line_end":248,"column_start":44,"column_end":60},"value":"","parent":null,"children":[{"krate":0,"index":5075},{"krate":0,"index":5076},{"krate":0,"index":5077},{"krate":0,"index":5078}],"docs":"","sig":null,"attributes":[]},{"id":247,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1188565,"byte_end":1188581,"line_start":272,"line_end":272,"column_start":6,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":5082},{"krate":0,"index":5083},{"krate":0,"index":5084},{"krate":0,"index":5085},{"krate":0,"index":5086},{"krate":0,"index":5087},{"krate":0,"index":5088},{"krate":0,"index":5089},{"krate":0,"index":5090},{"krate":0,"index":5091},{"krate":0,"index":5092},{"krate":0,"index":5093},{"krate":0,"index":5094},{"krate":0,"index":5095},{"krate":0,"index":5096},{"krate":0,"index":5097},{"krate":0,"index":5098},{"krate":0,"index":5099},{"krate":0,"index":5100},{"krate":0,"index":5101},{"krate":0,"index":5102},{"krate":0,"index":5103},{"krate":0,"index":5104},{"krate":0,"index":5105},{"krate":0,"index":5106},{"krate":0,"index":5107}],"docs":"","sig":null,"attributes":[]},{"id":248,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1196918,"byte_end":1196934,"line_start":482,"line_end":482,"column_start":15,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":5109}],"docs":"","sig":null,"attributes":[]},{"id":249,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1197094,"byte_end":1197110,"line_start":489,"line_end":489,"column_start":16,"column_end":32},"value":"","parent":null,"children":[{"krate":0,"index":5111}],"docs":"","sig":null,"attributes":[]},{"id":250,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1197590,"byte_end":1197606,"line_start":506,"line_end":506,"column_start":50,"column_end":66},"value":"","parent":null,"children":[{"krate":0,"index":5113},{"krate":0,"index":5114},{"krate":0,"index":5115},{"krate":0,"index":5116}],"docs":"","sig":null,"attributes":[]},{"id":251,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/wavelet_transforms.rs","byte_start":1201259,"byte_end":1201266,"line_start":62,"line_end":62,"column_start":6,"column_end":13},"value":"","parent":null,"children":[{"krate":0,"index":5122},{"krate":0,"index":5123}],"docs":"","sig":null,"attributes":[]},{"id":252,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/wavelet_transforms.rs","byte_start":1202179,"byte_end":1202186,"line_start":89,"line_end":89,"column_start":15,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":5125}],"docs":"","sig":null,"attributes":[]},{"id":253,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/wavelet_transforms.rs","byte_start":1202350,"byte_end":1202357,"line_start":96,"line_end":96,"column_start":37,"column_end":44},"value":"","parent":null,"children":[{"krate":0,"index":5127},{"krate":0,"index":5128},{"krate":0,"index":5129},{"krate":0,"index":5130}],"docs":"","sig":null,"attributes":[]},{"id":254,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/wavelet_transforms.rs","byte_start":1203043,"byte_end":1203054,"line_start":123,"line_end":123,"column_start":6,"column_end":17},"value":"","parent":null,"children":[{"krate":0,"index":5132},{"krate":0,"index":5133},{"krate":0,"index":5134},{"krate":0,"index":5135},{"krate":0,"index":5136},{"krate":0,"index":5137}],"docs":"","sig":null,"attributes":[]},{"id":255,"kind":"Inherent","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/wavelet_transforms.rs","byte_start":1205140,"byte_end":1205156,"line_start":189,"line_end":189,"column_start":6,"column_end":22},"value":"","parent":null,"children":[{"krate":0,"index":5141}],"docs":"","sig":null,"attributes":[]},{"id":256,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/wavelet_transforms.rs","byte_start":1205874,"byte_end":1205890,"line_start":207,"line_end":207,"column_start":15,"column_end":31},"value":"","parent":null,"children":[{"krate":0,"index":5143}],"docs":"","sig":null,"attributes":[]},{"id":257,"kind":"Direct","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/wavelet_transforms.rs","byte_start":1206074,"byte_end":1206090,"line_start":214,"line_end":214,"column_start":47,"column_end":63},"value":"","parent":null,"children":[{"krate":0,"index":5145},{"krate":0,"index":5146},{"krate":0,"index":5147},{"krate":0,"index":5148}],"docs":"","sig":null,"attributes":[]}],"refs":[{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3458,"byte_end":3465,"line_start":170,"line_end":170,"column_start":9,"column_end":16},"ref_id":{"krate":0,"index":2713}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":367915,"byte_end":367924,"line_start":56,"line_end":56,"column_start":9,"column_end":18},"ref_id":{"krate":0,"index":2714}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":367934,"byte_end":367938,"line_start":57,"line_end":57,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":2719}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":367948,"byte_end":367956,"line_start":58,"line_end":58,"column_start":9,"column_end":17},"ref_id":{"krate":0,"index":2728}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":367966,"byte_end":367984,"line_start":59,"line_end":59,"column_start":9,"column_end":27},"ref_id":{"krate":0,"index":2735}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":367994,"byte_end":368000,"line_start":60,"line_end":60,"column_start":9,"column_end":15},"ref_id":{"krate":0,"index":2740}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":368010,"byte_end":368021,"line_start":61,"line_end":61,"column_start":9,"column_end":20},"ref_id":{"krate":0,"index":2749}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":368031,"byte_end":368040,"line_start":62,"line_end":62,"column_start":9,"column_end":18},"ref_id":{"krate":0,"index":2758}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":368050,"byte_end":368061,"line_start":63,"line_end":63,"column_start":9,"column_end":20},"ref_id":{"krate":0,"index":2764}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":368071,"byte_end":368088,"line_start":64,"line_end":64,"column_start":9,"column_end":26},"ref_id":{"krate":0,"index":2773}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":368098,"byte_end":368112,"line_start":65,"line_end":65,"column_start":9,"column_end":23},"ref_id":{"krate":0,"index":2780}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":368122,"byte_end":368126,"line_start":66,"line_end":66,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":2789}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":368136,"byte_end":368141,"line_start":67,"line_end":67,"column_start":9,"column_end":14},"ref_id":{"krate":0,"index":2798}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":368151,"byte_end":368159,"line_start":68,"line_end":68,"column_start":9,"column_end":17},"ref_id":{"krate":0,"index":2808}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":368169,"byte_end":368182,"line_start":69,"line_end":69,"column_start":9,"column_end":22},"ref_id":{"krate":0,"index":2826}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":368192,"byte_end":368201,"line_start":70,"line_end":70,"column_start":9,"column_end":18},"ref_id":{"krate":0,"index":2833}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":368211,"byte_end":368217,"line_start":71,"line_end":71,"column_start":9,"column_end":15},"ref_id":{"krate":0,"index":2840}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":368227,"byte_end":368241,"line_start":72,"line_end":72,"column_start":9,"column_end":23},"ref_id":{"krate":0,"index":2859}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":368251,"byte_end":368257,"line_start":73,"line_end":73,"column_start":9,"column_end":15},"ref_id":{"krate":0,"index":2866}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":368267,"byte_end":368274,"line_start":74,"line_end":74,"column_start":9,"column_end":16},"ref_id":{"krate":0,"index":2871}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":368284,"byte_end":368294,"line_start":75,"line_end":75,"column_start":9,"column_end":19},"ref_id":{"krate":0,"index":2880}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":368304,"byte_end":368313,"line_start":76,"line_end":76,"column_start":9,"column_end":18},"ref_id":{"krate":0,"index":2884}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":368323,"byte_end":368334,"line_start":77,"line_end":77,"column_start":9,"column_end":20},"ref_id":{"krate":0,"index":2888}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":368344,"byte_end":368352,"line_start":78,"line_end":78,"column_start":9,"column_end":17},"ref_id":{"krate":0,"index":2893}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":368362,"byte_end":368371,"line_start":79,"line_end":79,"column_start":9,"column_end":18},"ref_id":{"krate":0,"index":2902}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":368381,"byte_end":368392,"line_start":80,"line_end":80,"column_start":9,"column_end":20},"ref_id":{"krate":0,"index":2911}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":368402,"byte_end":368419,"line_start":81,"line_end":81,"column_start":9,"column_end":26},"ref_id":{"krate":0,"index":2917}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":368429,"byte_end":368435,"line_start":82,"line_end":82,"column_start":9,"column_end":15},"ref_id":{"krate":0,"index":2924}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":368445,"byte_end":368451,"line_start":83,"line_end":83,"column_start":9,"column_end":15},"ref_id":{"krate":0,"index":2933}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":368461,"byte_end":368468,"line_start":84,"line_end":84,"column_start":9,"column_end":16},"ref_id":{"krate":0,"index":2940}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":368478,"byte_end":368486,"line_start":85,"line_end":85,"column_start":9,"column_end":17},"ref_id":{"krate":0,"index":2947}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":368496,"byte_end":368509,"line_start":86,"line_end":86,"column_start":9,"column_end":22},"ref_id":{"krate":0,"index":2956}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":368519,"byte_end":368537,"line_start":87,"line_end":87,"column_start":9,"column_end":27},"ref_id":{"krate":0,"index":2961}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":368547,"byte_end":368563,"line_start":88,"line_end":88,"column_start":9,"column_end":25},"ref_id":{"krate":0,"index":2972}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":368573,"byte_end":368587,"line_start":89,"line_end":89,"column_start":9,"column_end":23},"ref_id":{"krate":0,"index":2979}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/randist/mod.rs","byte_start":368597,"byte_end":368604,"line_start":90,"line_end":90,"column_start":9,"column_end":16},"ref_id":{"krate":0,"index":2988}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3475,"byte_end":3480,"line_start":171,"line_end":171,"column_start":9,"column_end":14},"ref_id":{"krate":0,"index":2997}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":433003,"byte_end":433015,"line_start":51,"line_end":51,"column_start":9,"column_end":21},"ref_id":{"krate":0,"index":3104}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":433025,"byte_end":433034,"line_start":52,"line_end":52,"column_start":9,"column_end":18},"ref_id":{"krate":0,"index":3125}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":433044,"byte_end":433055,"line_start":53,"line_end":53,"column_start":9,"column_end":20},"ref_id":{"krate":0,"index":3156}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":433065,"byte_end":433072,"line_start":54,"line_end":54,"column_start":9,"column_end":16},"ref_id":{"krate":0,"index":3192}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":433082,"byte_end":433097,"line_start":55,"line_end":55,"column_start":9,"column_end":24},"ref_id":{"krate":0,"index":3357}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":433107,"byte_end":433132,"line_start":56,"line_end":56,"column_start":9,"column_end":34},"ref_id":{"krate":0,"index":3376}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":433142,"byte_end":433165,"line_start":57,"line_end":57,"column_start":9,"column_end":32},"ref_id":{"krate":0,"index":3536}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":433175,"byte_end":433185,"line_start":58,"line_end":58,"column_start":9,"column_end":19},"ref_id":{"krate":0,"index":3564}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":433195,"byte_end":433206,"line_start":59,"line_end":59,"column_start":9,"column_end":20},"ref_id":{"krate":0,"index":3678}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":433216,"byte_end":433229,"line_start":60,"line_end":60,"column_start":9,"column_end":22},"ref_id":{"krate":0,"index":3893}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":433239,"byte_end":433246,"line_start":61,"line_end":61,"column_start":9,"column_end":16},"ref_id":{"krate":0,"index":3949}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":433256,"byte_end":433262,"line_start":62,"line_end":62,"column_start":9,"column_end":15},"ref_id":{"krate":0,"index":3976}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":433272,"byte_end":433286,"line_start":63,"line_end":63,"column_start":9,"column_end":23},"ref_id":{"krate":0,"index":4095}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":433296,"byte_end":433305,"line_start":64,"line_end":64,"column_start":9,"column_end":18},"ref_id":{"krate":0,"index":4192}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":433315,"byte_end":433326,"line_start":65,"line_end":65,"column_start":9,"column_end":20},"ref_id":{"krate":0,"index":4277}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":433336,"byte_end":433351,"line_start":66,"line_end":66,"column_start":9,"column_end":24},"ref_id":{"krate":0,"index":4354}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":433361,"byte_end":433369,"line_start":67,"line_end":67,"column_start":9,"column_end":17},"ref_id":{"krate":0,"index":4418}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":433379,"byte_end":433387,"line_start":68,"line_end":68,"column_start":9,"column_end":17},"ref_id":{"krate":0,"index":4449}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":433397,"byte_end":433428,"line_start":69,"line_end":69,"column_start":9,"column_end":40},"ref_id":{"krate":0,"index":4481}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":433438,"byte_end":433449,"line_start":70,"line_end":70,"column_start":9,"column_end":20},"ref_id":{"krate":0,"index":4596}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":433459,"byte_end":433469,"line_start":71,"line_end":71,"column_start":9,"column_end":19},"ref_id":{"krate":0,"index":4643}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":433479,"byte_end":433483,"line_start":72,"line_end":72,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":4658}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":433493,"byte_end":433505,"line_start":73,"line_end":73,"column_start":9,"column_end":21},"ref_id":{"krate":0,"index":4694}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":433515,"byte_end":433521,"line_start":74,"line_end":74,"column_start":9,"column_end":15},"ref_id":{"krate":0,"index":4710}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":433531,"byte_end":433534,"line_start":75,"line_end":75,"column_start":9,"column_end":12},"ref_id":{"krate":0,"index":4720}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":433544,"byte_end":433549,"line_start":76,"line_end":76,"column_start":9,"column_end":14},"ref_id":{"krate":0,"index":4813}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":433559,"byte_end":433578,"line_start":77,"line_end":77,"column_start":9,"column_end":28},"ref_id":{"krate":0,"index":4861}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":433588,"byte_end":433593,"line_start":78,"line_end":78,"column_start":9,"column_end":14},"ref_id":{"krate":0,"index":4894}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":433603,"byte_end":433609,"line_start":79,"line_end":79,"column_start":9,"column_end":15},"ref_id":{"krate":0,"index":4928}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":433619,"byte_end":433633,"line_start":80,"line_end":80,"column_start":9,"column_end":23},"ref_id":{"krate":0,"index":5031}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mod.rs","byte_start":433643,"byte_end":433661,"line_start":81,"line_end":81,"column_start":9,"column_end":27},"ref_id":{"krate":0,"index":5117}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3491,"byte_end":3495,"line_start":173,"line_end":173,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":5149}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3505,"byte_end":3511,"line_start":174,"line_end":174,"column_start":9,"column_end":15},"ref_id":{"krate":0,"index":5177}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3521,"byte_end":3525,"line_start":175,"line_end":175,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":5281}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3535,"byte_end":3540,"line_start":176,"line_end":176,"column_start":9,"column_end":14},"ref_id":{"krate":0,"index":5394}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3550,"byte_end":3557,"line_start":177,"line_end":177,"column_start":9,"column_end":16},"ref_id":{"krate":0,"index":5624}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3567,"byte_end":3574,"line_start":178,"line_end":178,"column_start":9,"column_end":16},"ref_id":{"krate":0,"index":5630}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3584,"byte_end":3605,"line_start":179,"line_end":179,"column_start":9,"column_end":30},"ref_id":{"krate":0,"index":5645}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3615,"byte_end":3621,"line_start":180,"line_end":180,"column_start":9,"column_end":15},"ref_id":{"krate":0,"index":5654}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3631,"byte_end":3636,"line_start":181,"line_end":181,"column_start":9,"column_end":14},"ref_id":{"krate":0,"index":5659}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3646,"byte_end":3657,"line_start":182,"line_end":182,"column_start":9,"column_end":20},"ref_id":{"krate":0,"index":5674}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3667,"byte_end":3672,"line_start":183,"line_end":183,"column_start":9,"column_end":14},"ref_id":{"krate":0,"index":5680}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3682,"byte_end":3692,"line_start":184,"line_end":184,"column_start":9,"column_end":19},"ref_id":{"krate":0,"index":5694}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3702,"byte_end":3723,"line_start":185,"line_end":185,"column_start":9,"column_end":30},"ref_id":{"krate":0,"index":5716}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3733,"byte_end":3741,"line_start":186,"line_end":186,"column_start":9,"column_end":17},"ref_id":{"krate":0,"index":5721}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3751,"byte_end":3756,"line_start":187,"line_end":187,"column_start":9,"column_end":14},"ref_id":{"krate":0,"index":5757}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3766,"byte_end":3777,"line_start":188,"line_end":188,"column_start":9,"column_end":20},"ref_id":{"krate":0,"index":5782}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3787,"byte_end":3808,"line_start":189,"line_end":189,"column_start":9,"column_end":30},"ref_id":{"krate":0,"index":5804}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3818,"byte_end":3829,"line_start":190,"line_end":190,"column_start":9,"column_end":20},"ref_id":{"krate":0,"index":5828}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3839,"byte_end":3842,"line_start":191,"line_end":191,"column_start":9,"column_end":12},"ref_id":{"krate":0,"index":5855}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3852,"byte_end":3855,"line_start":192,"line_end":192,"column_start":9,"column_end":12},"ref_id":{"krate":0,"index":5884}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3865,"byte_end":3875,"line_start":193,"line_end":193,"column_start":9,"column_end":19},"ref_id":{"krate":0,"index":5892}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3885,"byte_end":3895,"line_start":194,"line_end":194,"column_start":9,"column_end":19},"ref_id":{"krate":0,"index":5960}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3905,"byte_end":3919,"line_start":195,"line_end":195,"column_start":9,"column_end":23},"ref_id":{"krate":0,"index":5973}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3929,"byte_end":3940,"line_start":196,"line_end":196,"column_start":9,"column_end":20},"ref_id":{"krate":0,"index":5999}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3950,"byte_end":3963,"line_start":197,"line_end":197,"column_start":9,"column_end":22},"ref_id":{"krate":0,"index":6085}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":3973,"byte_end":3990,"line_start":198,"line_end":198,"column_start":9,"column_end":26},"ref_id":{"krate":0,"index":6097}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":4000,"byte_end":4008,"line_start":199,"line_end":199,"column_start":9,"column_end":17},"ref_id":{"krate":0,"index":6100}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":4018,"byte_end":4027,"line_start":200,"line_end":200,"column_start":9,"column_end":18},"ref_id":{"krate":0,"index":6112}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":4037,"byte_end":4045,"line_start":201,"line_end":201,"column_start":9,"column_end":17},"ref_id":{"krate":0,"index":6120}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":4055,"byte_end":4069,"line_start":202,"line_end":202,"column_start":9,"column_end":23},"ref_id":{"krate":0,"index":6180}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":4079,"byte_end":4088,"line_start":203,"line_end":203,"column_start":9,"column_end":18},"ref_id":{"krate":0,"index":6265}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":4098,"byte_end":4107,"line_start":204,"line_end":204,"column_start":9,"column_end":18},"ref_id":{"krate":0,"index":6278}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":4117,"byte_end":4125,"line_start":205,"line_end":205,"column_start":9,"column_end":17},"ref_id":{"krate":0,"index":6282}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":4135,"byte_end":4160,"line_start":206,"line_end":206,"column_start":9,"column_end":34},"ref_id":{"krate":0,"index":6287}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":4170,"byte_end":4187,"line_start":207,"line_end":207,"column_start":9,"column_end":26},"ref_id":{"krate":0,"index":6300}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":4197,"byte_end":4208,"line_start":208,"line_end":208,"column_start":9,"column_end":20},"ref_id":{"krate":0,"index":6417}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":4218,"byte_end":4221,"line_start":209,"line_end":209,"column_start":9,"column_end":12},"ref_id":{"krate":0,"index":6446}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":4231,"byte_end":4236,"line_start":210,"line_end":210,"column_start":9,"column_end":14},"ref_id":{"krate":0,"index":6469}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":4246,"byte_end":4249,"line_start":211,"line_end":211,"column_start":9,"column_end":12},"ref_id":{"krate":0,"index":6475}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":4259,"byte_end":4264,"line_start":212,"line_end":212,"column_start":9,"column_end":14},"ref_id":{"krate":0,"index":6500}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":4274,"byte_end":4278,"line_start":213,"line_end":213,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":6505}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":4288,"byte_end":4298,"line_start":214,"line_end":214,"column_start":9,"column_end":19},"ref_id":{"krate":0,"index":6539}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":4308,"byte_end":4319,"line_start":215,"line_end":215,"column_start":9,"column_end":20},"ref_id":{"krate":0,"index":6585}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":4329,"byte_end":4338,"line_start":216,"line_end":216,"column_start":9,"column_end":18},"ref_id":{"krate":0,"index":6593}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":4348,"byte_end":4361,"line_start":217,"line_end":217,"column_start":9,"column_end":22},"ref_id":{"krate":0,"index":6605}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":4371,"byte_end":4375,"line_start":218,"line_end":218,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":6656}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":4385,"byte_end":4403,"line_start":219,"line_end":219,"column_start":9,"column_end":27},"ref_id":{"krate":0,"index":6658}},{"kind":"Mod","span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/lib.rs","byte_start":4413,"byte_end":4417,"line_start":220,"line_end":220,"column_start":9,"column_end":13},"ref_id":{"krate":0,"index":6680}}],"macro_refs":[],"relations":[{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":351791,"byte_end":351800,"line_start":16,"line_end":16,"column_start":38,"column_end":47},"kind":{"Impl":{"id":0}},"from":{"krate":0,"index":2649},"to":{"krate":2,"index":2258}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":353902,"byte_end":353907,"line_start":99,"line_end":99,"column_start":28,"column_end":33},"kind":{"Impl":{"id":1}},"from":{"krate":0,"index":6768},"to":{"krate":2,"index":2255}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":355276,"byte_end":355281,"line_start":142,"line_end":142,"column_start":28,"column_end":33},"kind":{"Impl":{"id":2}},"from":{"krate":0,"index":6768},"to":{"krate":2,"index":2258}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":356951,"byte_end":356960,"line_start":197,"line_end":197,"column_start":28,"column_end":37},"kind":{"Impl":{"id":3}},"from":{"krate":0,"index":6857},"to":{"krate":2,"index":2255}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":357211,"byte_end":357220,"line_start":208,"line_end":208,"column_start":28,"column_end":37},"kind":{"Impl":{"id":4}},"from":{"krate":0,"index":6857},"to":{"krate":2,"index":2258}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":357818,"byte_end":357830,"line_start":233,"line_end":233,"column_start":28,"column_end":40},"kind":{"Impl":{"id":5}},"from":{"krate":0,"index":6876},"to":{"krate":2,"index":2255}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":358017,"byte_end":358029,"line_start":242,"line_end":242,"column_start":28,"column_end":40},"kind":{"Impl":{"id":6}},"from":{"krate":0,"index":6876},"to":{"krate":2,"index":2258}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":358791,"byte_end":358806,"line_start":269,"line_end":269,"column_start":28,"column_end":43},"kind":{"Impl":{"id":7}},"from":{"krate":0,"index":6891},"to":{"krate":2,"index":2255}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":359169,"byte_end":359184,"line_start":282,"line_end":282,"column_start":28,"column_end":43},"kind":{"Impl":{"id":8}},"from":{"krate":0,"index":6891},"to":{"krate":2,"index":2258}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":359763,"byte_end":359778,"line_start":303,"line_end":303,"column_start":28,"column_end":43},"kind":{"Impl":{"id":9}},"from":{"krate":0,"index":6914},"to":{"krate":2,"index":2255}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":359965,"byte_end":359980,"line_start":312,"line_end":312,"column_start":28,"column_end":43},"kind":{"Impl":{"id":10}},"from":{"krate":0,"index":6914},"to":{"krate":2,"index":2258}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":360798,"byte_end":360807,"line_start":336,"line_end":336,"column_start":28,"column_end":37},"kind":{"Impl":{"id":11}},"from":{"krate":0,"index":6929},"to":{"krate":2,"index":2255}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":361037,"byte_end":361046,"line_start":346,"line_end":346,"column_start":28,"column_end":37},"kind":{"Impl":{"id":12}},"from":{"krate":0,"index":6929},"to":{"krate":2,"index":2258}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":361603,"byte_end":361608,"line_start":368,"line_end":368,"column_start":28,"column_end":33},"kind":{"Impl":{"id":13}},"from":{"krate":0,"index":6946},"to":{"krate":2,"index":2255}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":361801,"byte_end":361806,"line_start":378,"line_end":378,"column_start":28,"column_end":33},"kind":{"Impl":{"id":14}},"from":{"krate":0,"index":6946},"to":{"krate":2,"index":2258}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":362159,"byte_end":362175,"line_start":395,"line_end":395,"column_start":28,"column_end":44},"kind":{"Impl":{"id":15}},"from":{"krate":0,"index":6963},"to":{"krate":2,"index":2255}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":362370,"byte_end":362386,"line_start":404,"line_end":404,"column_start":28,"column_end":44},"kind":{"Impl":{"id":16}},"from":{"krate":0,"index":6963},"to":{"krate":2,"index":2258}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":362790,"byte_end":362804,"line_start":422,"line_end":422,"column_start":28,"column_end":42},"kind":{"Impl":{"id":17}},"from":{"krate":0,"index":6978},"to":{"krate":2,"index":2255}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/enums.rs","byte_start":363081,"byte_end":363095,"line_start":433,"line_end":433,"column_start":28,"column_end":42},"kind":{"Impl":{"id":18}},"from":{"krate":0,"index":6978},"to":{"krate":2,"index":2258}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/utilities.rs","byte_start":363762,"byte_end":363770,"line_start":22,"line_end":22,"column_start":6,"column_end":14},"kind":{"Impl":{"id":19}},"from":{"krate":0,"index":2698},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/utilities.rs","byte_start":364583,"byte_end":364591,"line_start":53,"line_end":53,"column_start":27,"column_end":35},"kind":{"Impl":{"id":20}},"from":{"krate":0,"index":2698},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/basis_spline.rs","byte_start":435735,"byte_end":435751,"line_start":61,"line_end":61,"column_start":6,"column_end":22},"kind":{"Impl":{"id":21}},"from":{"krate":0,"index":3108},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/basis_spline.rs","byte_start":439540,"byte_end":439556,"line_start":139,"line_end":139,"column_start":15,"column_end":31},"kind":{"Impl":{"id":22}},"from":{"krate":0,"index":3108},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/basis_spline.rs","byte_start":439730,"byte_end":439746,"line_start":146,"line_end":146,"column_start":47,"column_end":63},"kind":{"Impl":{"id":23}},"from":{"krate":0,"index":3108},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/chebyshev.rs","byte_start":445026,"byte_end":445036,"line_start":43,"line_end":43,"column_start":6,"column_end":16},"kind":{"Impl":{"id":24}},"from":{"krate":0,"index":3130},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/chebyshev.rs","byte_start":449943,"byte_end":449953,"line_start":160,"line_end":160,"column_start":15,"column_end":25},"kind":{"Impl":{"id":25}},"from":{"krate":0,"index":3130},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/chebyshev.rs","byte_start":450118,"byte_end":450128,"line_start":167,"line_end":167,"column_start":41,"column_end":51},"kind":{"Impl":{"id":26}},"from":{"krate":0,"index":3130},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/combination.rs","byte_start":451523,"byte_end":451534,"line_start":32,"line_end":32,"column_start":6,"column_end":17},"kind":{"Impl":{"id":27}},"from":{"krate":0,"index":3164},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/combination.rs","byte_start":456468,"byte_end":456479,"line_start":151,"line_end":151,"column_start":15,"column_end":26},"kind":{"Impl":{"id":28}},"from":{"krate":0,"index":3164},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/combination.rs","byte_start":456651,"byte_end":456662,"line_start":158,"line_end":158,"column_start":41,"column_end":52},"kind":{"Impl":{"id":29}},"from":{"krate":0,"index":3164},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/combination.rs","byte_start":457186,"byte_end":457197,"line_start":181,"line_end":181,"column_start":16,"column_end":27},"kind":{"Impl":{"id":30}},"from":{"krate":0,"index":3164},"to":{"krate":2,"index":7636}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":458117,"byte_end":458127,"line_start":30,"line_end":30,"column_start":6,"column_end":16},"kind":{"Impl":{"id":31}},"from":{"krate":0,"index":6997},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":472938,"byte_end":472948,"line_start":382,"line_end":382,"column_start":16,"column_end":26},"kind":{"Impl":{"id":32}},"from":{"krate":0,"index":6997},"to":{"krate":2,"index":7636}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":473085,"byte_end":473095,"line_start":388,"line_end":388,"column_start":16,"column_end":26},"kind":{"Impl":{"id":33}},"from":{"krate":0,"index":6997},"to":{"krate":2,"index":2181}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":473235,"byte_end":473245,"line_start":396,"line_end":396,"column_start":18,"column_end":28},"kind":{"Impl":{"id":34}},"from":{"krate":0,"index":6997},"to":{"krate":2,"index":2206}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":473383,"byte_end":473393,"line_start":404,"line_end":404,"column_start":33,"column_end":43},"kind":{"Impl":{"id":35}},"from":{"krate":0,"index":6997},"to":{"krate":0,"index":3199}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":473632,"byte_end":473642,"line_start":414,"line_end":414,"column_start":39,"column_end":49},"kind":{"Impl":{"id":36}},"from":{"krate":0,"index":6997},"to":{"krate":0,"index":3199}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":473981,"byte_end":473992,"line_start":428,"line_end":428,"column_start":32,"column_end":43},"kind":{"Impl":{"id":37}},"from":{"krate":0,"index":2356},"to":{"krate":0,"index":3203}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":474307,"byte_end":474318,"line_start":442,"line_end":442,"column_start":32,"column_end":43},"kind":{"Impl":{"id":38}},"from":{"krate":0,"index":2356},"to":{"krate":0,"index":3203}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":474605,"byte_end":474615,"line_start":458,"line_end":458,"column_start":6,"column_end":16},"kind":{"Impl":{"id":39}},"from":{"krate":0,"index":7005},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":489571,"byte_end":489581,"line_start":807,"line_end":807,"column_start":16,"column_end":26},"kind":{"Impl":{"id":40}},"from":{"krate":0,"index":7005},"to":{"krate":2,"index":7636}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":489718,"byte_end":489728,"line_start":813,"line_end":813,"column_start":16,"column_end":26},"kind":{"Impl":{"id":41}},"from":{"krate":0,"index":7005},"to":{"krate":2,"index":2181}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":489868,"byte_end":489878,"line_start":821,"line_end":821,"column_start":18,"column_end":28},"kind":{"Impl":{"id":42}},"from":{"krate":0,"index":7005},"to":{"krate":2,"index":2206}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":490016,"byte_end":490026,"line_start":829,"line_end":829,"column_start":33,"column_end":43},"kind":{"Impl":{"id":43}},"from":{"krate":0,"index":7005},"to":{"krate":0,"index":3199}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/complex.rs","byte_start":490354,"byte_end":490364,"line_start":843,"line_end":843,"column_start":39,"column_end":49},"kind":{"Impl":{"id":44}},"from":{"krate":0,"index":7005},"to":{"krate":0,"index":3199}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/discrete_hankel.rs","byte_start":513178,"byte_end":513192,"line_start":63,"line_end":63,"column_start":6,"column_end":20},"kind":{"Impl":{"id":45}},"from":{"krate":0,"index":3360},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/discrete_hankel.rs","byte_start":515623,"byte_end":515637,"line_start":126,"line_end":126,"column_start":15,"column_end":29},"kind":{"Impl":{"id":46}},"from":{"krate":0,"index":3360},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/discrete_hankel.rs","byte_start":515793,"byte_end":515807,"line_start":133,"line_end":133,"column_start":33,"column_end":47},"kind":{"Impl":{"id":47}},"from":{"krate":0,"index":3360},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":521514,"byte_end":521537,"line_start":106,"line_end":106,"column_start":6,"column_end":29},"kind":{"Impl":{"id":48}},"from":{"krate":0,"index":3384},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":522569,"byte_end":522592,"line_start":132,"line_end":132,"column_start":15,"column_end":38},"kind":{"Impl":{"id":49}},"from":{"krate":0,"index":3384},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":522772,"byte_end":522795,"line_start":139,"line_end":139,"column_start":50,"column_end":73},"kind":{"Impl":{"id":50}},"from":{"krate":0,"index":3384},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":523368,"byte_end":523392,"line_start":161,"line_end":161,"column_start":6,"column_end":30},"kind":{"Impl":{"id":51}},"from":{"krate":0,"index":3396},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":524900,"byte_end":524924,"line_start":195,"line_end":195,"column_start":15,"column_end":39},"kind":{"Impl":{"id":52}},"from":{"krate":0,"index":3396},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":525106,"byte_end":525130,"line_start":202,"line_end":202,"column_start":51,"column_end":75},"kind":{"Impl":{"id":53}},"from":{"krate":0,"index":3396},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":525710,"byte_end":525733,"line_start":224,"line_end":224,"column_start":6,"column_end":29},"kind":{"Impl":{"id":54}},"from":{"krate":0,"index":3408},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":526946,"byte_end":526969,"line_start":251,"line_end":251,"column_start":15,"column_end":38},"kind":{"Impl":{"id":55}},"from":{"krate":0,"index":3408},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":527149,"byte_end":527172,"line_start":258,"line_end":258,"column_start":50,"column_end":73},"kind":{"Impl":{"id":56}},"from":{"krate":0,"index":3408},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":527745,"byte_end":527769,"line_start":280,"line_end":280,"column_start":6,"column_end":30},"kind":{"Impl":{"id":57}},"from":{"krate":0,"index":3420},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":529481,"byte_end":529505,"line_start":316,"line_end":316,"column_start":15,"column_end":39},"kind":{"Impl":{"id":58}},"from":{"krate":0,"index":3420},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":529687,"byte_end":529711,"line_start":323,"line_end":323,"column_start":51,"column_end":75},"kind":{"Impl":{"id":59}},"from":{"krate":0,"index":3420},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":530292,"byte_end":530313,"line_start":345,"line_end":345,"column_start":6,"column_end":27},"kind":{"Impl":{"id":60}},"from":{"krate":0,"index":3432},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":534155,"byte_end":534176,"line_start":423,"line_end":423,"column_start":15,"column_end":36},"kind":{"Impl":{"id":61}},"from":{"krate":0,"index":3432},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":534362,"byte_end":534383,"line_start":430,"line_end":430,"column_start":53,"column_end":74},"kind":{"Impl":{"id":62}},"from":{"krate":0,"index":3432},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":534959,"byte_end":534981,"line_start":452,"line_end":452,"column_start":6,"column_end":28},"kind":{"Impl":{"id":63}},"from":{"krate":0,"index":3447},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":537827,"byte_end":537849,"line_start":511,"line_end":511,"column_start":15,"column_end":37},"kind":{"Impl":{"id":64}},"from":{"krate":0,"index":3447},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":538037,"byte_end":538059,"line_start":518,"line_end":518,"column_start":54,"column_end":76},"kind":{"Impl":{"id":65}},"from":{"krate":0,"index":3447},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":538642,"byte_end":538663,"line_start":540,"line_end":540,"column_start":6,"column_end":27},"kind":{"Impl":{"id":66}},"from":{"krate":0,"index":3461},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":539844,"byte_end":539865,"line_start":570,"line_end":570,"column_start":15,"column_end":36},"kind":{"Impl":{"id":67}},"from":{"krate":0,"index":3461},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":540051,"byte_end":540072,"line_start":577,"line_end":577,"column_start":53,"column_end":74},"kind":{"Impl":{"id":68}},"from":{"krate":0,"index":3461},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":540648,"byte_end":540670,"line_start":599,"line_end":599,"column_start":6,"column_end":28},"kind":{"Impl":{"id":69}},"from":{"krate":0,"index":3473},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":542070,"byte_end":542092,"line_start":632,"line_end":632,"column_start":15,"column_end":37},"kind":{"Impl":{"id":70}},"from":{"krate":0,"index":3473},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":542280,"byte_end":542302,"line_start":639,"line_end":639,"column_start":54,"column_end":76},"kind":{"Impl":{"id":71}},"from":{"krate":0,"index":3473},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":542885,"byte_end":542906,"line_start":661,"line_end":661,"column_start":6,"column_end":27},"kind":{"Impl":{"id":72}},"from":{"krate":0,"index":3485},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":544107,"byte_end":544128,"line_start":691,"line_end":691,"column_start":15,"column_end":36},"kind":{"Impl":{"id":73}},"from":{"krate":0,"index":3485},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":544314,"byte_end":544335,"line_start":698,"line_end":698,"column_start":53,"column_end":74},"kind":{"Impl":{"id":74}},"from":{"krate":0,"index":3485},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":544911,"byte_end":544933,"line_start":720,"line_end":720,"column_start":6,"column_end":28},"kind":{"Impl":{"id":75}},"from":{"krate":0,"index":3497},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":546262,"byte_end":546284,"line_start":752,"line_end":752,"column_start":15,"column_end":37},"kind":{"Impl":{"id":76}},"from":{"krate":0,"index":3497},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":546472,"byte_end":546494,"line_start":759,"line_end":759,"column_start":54,"column_end":76},"kind":{"Impl":{"id":77}},"from":{"krate":0,"index":3497},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":547069,"byte_end":547086,"line_start":781,"line_end":781,"column_start":6,"column_end":23},"kind":{"Impl":{"id":78}},"from":{"krate":0,"index":3509},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":550984,"byte_end":551001,"line_start":860,"line_end":860,"column_start":15,"column_end":32},"kind":{"Impl":{"id":79}},"from":{"krate":0,"index":3509},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":551179,"byte_end":551196,"line_start":867,"line_end":867,"column_start":49,"column_end":66},"kind":{"Impl":{"id":80}},"from":{"krate":0,"index":3509},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":551728,"byte_end":551746,"line_start":889,"line_end":889,"column_start":6,"column_end":24},"kind":{"Impl":{"id":81}},"from":{"krate":0,"index":3523},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":554674,"byte_end":554692,"line_start":951,"line_end":951,"column_start":15,"column_end":33},"kind":{"Impl":{"id":82}},"from":{"krate":0,"index":3523},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/eigen_symmetric_workspace.rs","byte_start":554872,"byte_end":554890,"line_start":958,"line_end":958,"column_start":50,"column_end":68},"kind":{"Impl":{"id":83}},"from":{"krate":0,"index":3523},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/fast_fourier_transforms.rs","byte_start":561812,"byte_end":561831,"line_start":13,"line_end":13,"column_start":6,"column_end":25},"kind":{"Impl":{"id":84}},"from":{"krate":0,"index":3539},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/fast_fourier_transforms.rs","byte_start":563351,"byte_end":563370,"line_start":42,"line_end":42,"column_start":15,"column_end":34},"kind":{"Impl":{"id":85}},"from":{"krate":0,"index":3539},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/fast_fourier_transforms.rs","byte_start":563562,"byte_end":563581,"line_start":49,"line_end":49,"column_start":51,"column_end":70},"kind":{"Impl":{"id":86}},"from":{"krate":0,"index":3539},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/fast_fourier_transforms.rs","byte_start":564258,"byte_end":564277,"line_start":76,"line_end":76,"column_start":6,"column_end":25},"kind":{"Impl":{"id":87}},"from":{"krate":0,"index":3553},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/fast_fourier_transforms.rs","byte_start":564661,"byte_end":564680,"line_start":91,"line_end":91,"column_start":15,"column_end":34},"kind":{"Impl":{"id":88}},"from":{"krate":0,"index":3553},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/fast_fourier_transforms.rs","byte_start":564872,"byte_end":564891,"line_start":98,"line_end":98,"column_start":51,"column_end":70},"kind":{"Impl":{"id":89}},"from":{"krate":0,"index":3553},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":567005,"byte_end":567014,"line_start":35,"line_end":35,"column_start":6,"column_end":15},"kind":{"Impl":{"id":90}},"from":{"krate":0,"index":3568},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":579310,"byte_end":579319,"line_start":269,"line_end":269,"column_start":15,"column_end":24},"kind":{"Impl":{"id":91}},"from":{"krate":0,"index":3568},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":579487,"byte_end":579496,"line_start":276,"line_end":276,"column_start":39,"column_end":48},"kind":{"Impl":{"id":92}},"from":{"krate":0,"index":3568},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":580706,"byte_end":580718,"line_start":306,"line_end":306,"column_start":6,"column_end":18},"kind":{"Impl":{"id":93}},"from":{"krate":0,"index":3607},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":582257,"byte_end":582269,"line_start":338,"line_end":338,"column_start":15,"column_end":27},"kind":{"Impl":{"id":94}},"from":{"krate":0,"index":3607},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":582445,"byte_end":582457,"line_start":345,"line_end":345,"column_start":43,"column_end":55},"kind":{"Impl":{"id":95}},"from":{"krate":0,"index":3607},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":583458,"byte_end":583469,"line_start":373,"line_end":373,"column_start":6,"column_end":17},"kind":{"Impl":{"id":96}},"from":{"krate":0,"index":3620},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":597369,"byte_end":597380,"line_start":615,"line_end":615,"column_start":15,"column_end":26},"kind":{"Impl":{"id":97}},"from":{"krate":0,"index":3620},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":597552,"byte_end":597563,"line_start":622,"line_end":622,"column_start":41,"column_end":52},"kind":{"Impl":{"id":98}},"from":{"krate":0,"index":3620},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":598704,"byte_end":598718,"line_start":654,"line_end":654,"column_start":6,"column_end":20},"kind":{"Impl":{"id":99}},"from":{"krate":0,"index":3665},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":600164,"byte_end":600178,"line_start":684,"line_end":684,"column_start":15,"column_end":29},"kind":{"Impl":{"id":100}},"from":{"krate":0,"index":3665},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/histograms.rs","byte_start":600358,"byte_end":600372,"line_start":691,"line_end":691,"column_start":45,"column_end":59},"kind":{"Impl":{"id":101}},"from":{"krate":0,"index":3665},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":689595,"byte_end":689615,"line_start":1357,"line_end":1357,"column_start":6,"column_end":26},"kind":{"Impl":{"id":102}},"from":{"krate":0,"index":3702},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":713730,"byte_end":713750,"line_start":2006,"line_end":2006,"column_start":15,"column_end":35},"kind":{"Impl":{"id":103}},"from":{"krate":0,"index":3702},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":713942,"byte_end":713962,"line_start":2013,"line_end":2013,"column_start":51,"column_end":71},"kind":{"Impl":{"id":104}},"from":{"krate":0,"index":3702},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":714773,"byte_end":714793,"line_start":2039,"line_end":2039,"column_start":6,"column_end":26},"kind":{"Impl":{"id":105}},"from":{"krate":0,"index":3743},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":723442,"byte_end":723462,"line_start":2261,"line_end":2261,"column_start":15,"column_end":35},"kind":{"Impl":{"id":106}},"from":{"krate":0,"index":3743},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":723656,"byte_end":723676,"line_start":2268,"line_end":2268,"column_start":52,"column_end":72},"kind":{"Impl":{"id":107}},"from":{"krate":0,"index":3743},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":724517,"byte_end":724537,"line_start":2294,"line_end":2294,"column_start":6,"column_end":26},"kind":{"Impl":{"id":108}},"from":{"krate":0,"index":3757},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":739430,"byte_end":739450,"line_start":2689,"line_end":2689,"column_start":15,"column_end":35},"kind":{"Impl":{"id":109}},"from":{"krate":0,"index":3757},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":739644,"byte_end":739664,"line_start":2696,"line_end":2696,"column_start":52,"column_end":72},"kind":{"Impl":{"id":110}},"from":{"krate":0,"index":3757},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":741050,"byte_end":741064,"line_start":2728,"line_end":2728,"column_start":6,"column_end":20},"kind":{"Impl":{"id":111}},"from":{"krate":0,"index":3772},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":763869,"byte_end":763883,"line_start":3237,"line_end":3237,"column_start":15,"column_end":29},"kind":{"Impl":{"id":112}},"from":{"krate":0,"index":3772},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":764087,"byte_end":764101,"line_start":3244,"line_end":3244,"column_start":57,"column_end":71},"kind":{"Impl":{"id":113}},"from":{"krate":0,"index":3772},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":765148,"byte_end":765160,"line_start":3272,"line_end":3272,"column_start":6,"column_end":18},"kind":{"Impl":{"id":114}},"from":{"krate":0,"index":3793},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":767349,"byte_end":767361,"line_start":3328,"line_end":3328,"column_start":15,"column_end":27},"kind":{"Impl":{"id":115}},"from":{"krate":0,"index":3793},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/integration.rs","byte_start":767561,"byte_end":767573,"line_start":3335,"line_end":3335,"column_start":55,"column_end":67},"kind":{"Impl":{"id":116}},"from":{"krate":0,"index":3793},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":817406,"byte_end":817417,"line_start":54,"line_end":54,"column_start":6,"column_end":17},"kind":{"Impl":{"id":117}},"from":{"krate":0,"index":7013},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":818635,"byte_end":818641,"line_start":84,"line_end":84,"column_start":6,"column_end":12},"kind":{"Impl":{"id":118}},"from":{"krate":0,"index":3900},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":820599,"byte_end":820605,"line_start":135,"line_end":135,"column_start":15,"column_end":21},"kind":{"Impl":{"id":119}},"from":{"krate":0,"index":3900},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":820777,"byte_end":820783,"line_start":142,"line_end":142,"column_start":36,"column_end":42},"kind":{"Impl":{"id":120}},"from":{"krate":0,"index":3900},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":821290,"byte_end":821300,"line_start":167,"line_end":167,"column_start":6,"column_end":16},"kind":{"Impl":{"id":121}},"from":{"krate":0,"index":7020},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":823656,"byte_end":823666,"line_start":211,"line_end":211,"column_start":41,"column_end":51},"kind":{"Impl":{"id":122}},"from":{"krate":0,"index":7020},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":824210,"byte_end":824216,"line_start":236,"line_end":236,"column_start":6,"column_end":12},"kind":{"Impl":{"id":123}},"from":{"krate":0,"index":3927},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":826464,"byte_end":826470,"line_start":302,"line_end":302,"column_start":15,"column_end":21},"kind":{"Impl":{"id":124}},"from":{"krate":0,"index":3927},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/interpolation.rs","byte_start":826642,"byte_end":826648,"line_start":309,"line_end":309,"column_start":36,"column_end":42},"kind":{"Impl":{"id":125}},"from":{"krate":0,"index":3927},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mathieu.rs","byte_start":828410,"byte_end":828426,"line_start":29,"line_end":29,"column_start":6,"column_end":22},"kind":{"Impl":{"id":126}},"from":{"krate":0,"index":3953},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mathieu.rs","byte_start":834735,"byte_end":834751,"line_start":139,"line_end":139,"column_start":15,"column_end":31},"kind":{"Impl":{"id":127}},"from":{"krate":0,"index":3953},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/mathieu.rs","byte_start":834937,"byte_end":834953,"line_start":146,"line_end":146,"column_start":50,"column_end":66},"kind":{"Impl":{"id":128}},"from":{"krate":0,"index":3953},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":838164,"byte_end":838174,"line_start":63,"line_end":63,"column_start":6,"column_end":16},"kind":{"Impl":{"id":129}},"from":{"krate":0,"index":3986},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":844848,"byte_end":844857,"line_start":189,"line_end":189,"column_start":6,"column_end":15},"kind":{"Impl":{"id":130}},"from":{"krate":0,"index":3995},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":857423,"byte_end":857432,"line_start":489,"line_end":489,"column_start":15,"column_end":24},"kind":{"Impl":{"id":131}},"from":{"krate":0,"index":3995},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":857623,"byte_end":857632,"line_start":498,"line_end":498,"column_start":16,"column_end":25},"kind":{"Impl":{"id":132}},"from":{"krate":0,"index":3995},"to":{"krate":2,"index":7636}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":858300,"byte_end":858309,"line_start":520,"line_end":520,"column_start":36,"column_end":45},"kind":{"Impl":{"id":133}},"from":{"krate":0,"index":3995},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":858865,"byte_end":858874,"line_start":549,"line_end":549,"column_start":6,"column_end":15},"kind":{"Impl":{"id":134}},"from":{"krate":0,"index":4046},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":871398,"byte_end":871407,"line_start":835,"line_end":835,"column_start":15,"column_end":24},"kind":{"Impl":{"id":135}},"from":{"krate":0,"index":4046},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":871604,"byte_end":871613,"line_start":844,"line_end":844,"column_start":16,"column_end":25},"kind":{"Impl":{"id":136}},"from":{"krate":0,"index":4046},"to":{"krate":2,"index":7636}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix.rs","byte_start":872287,"byte_end":872296,"line_start":866,"line_end":866,"column_start":42,"column_end":51},"kind":{"Impl":{"id":137}},"from":{"krate":0,"index":4046},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":873113,"byte_end":873129,"line_start":16,"line_end":16,"column_start":6,"column_end":22},"kind":{"Impl":{"id":138}},"from":{"krate":0,"index":4108},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":883823,"byte_end":883839,"line_start":255,"line_end":255,"column_start":15,"column_end":31},"kind":{"Impl":{"id":139}},"from":{"krate":0,"index":4108},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":883993,"byte_end":884009,"line_start":262,"line_end":262,"column_start":16,"column_end":32},"kind":{"Impl":{"id":140}},"from":{"krate":0,"index":4108},"to":{"krate":2,"index":7636}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":884689,"byte_end":884705,"line_start":284,"line_end":284,"column_start":44,"column_end":60},"kind":{"Impl":{"id":141}},"from":{"krate":0,"index":4108},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":885237,"byte_end":885253,"line_start":308,"line_end":308,"column_start":6,"column_end":22},"kind":{"Impl":{"id":142}},"from":{"krate":0,"index":4150},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":896191,"byte_end":896207,"line_start":552,"line_end":552,"column_start":15,"column_end":31},"kind":{"Impl":{"id":143}},"from":{"krate":0,"index":4150},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":896367,"byte_end":896383,"line_start":559,"line_end":559,"column_start":16,"column_end":32},"kind":{"Impl":{"id":144}},"from":{"krate":0,"index":4150},"to":{"krate":2,"index":7636}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/matrix_complex.rs","byte_start":897069,"byte_end":897085,"line_start":581,"line_end":581,"column_start":50,"column_end":66},"kind":{"Impl":{"id":145}},"from":{"krate":0,"index":4150},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/minimizer.rs","byte_start":903643,"byte_end":903652,"line_start":120,"line_end":120,"column_start":9,"column_end":18},"kind":{"Impl":{"id":146}},"from":{"krate":0,"index":4205},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/minimizer.rs","byte_start":909612,"byte_end":909621,"line_start":269,"line_end":269,"column_start":18,"column_end":27},"kind":{"Impl":{"id":147}},"from":{"krate":0,"index":4205},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/minimizer.rs","byte_start":910198,"byte_end":910211,"line_start":285,"line_end":285,"column_start":9,"column_end":22},"kind":{"Impl":{"id":148}},"from":{"krate":0,"index":4233},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/minimizer.rs","byte_start":912867,"byte_end":912880,"line_start":331,"line_end":331,"column_start":19,"column_end":32},"kind":{"Impl":{"id":149}},"from":{"krate":0,"index":4233},"to":{"krate":2,"index":2181}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":932229,"byte_end":932244,"line_start":97,"line_end":97,"column_start":6,"column_end":21},"kind":{"Impl":{"id":150}},"from":{"krate":0,"index":4286},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":935395,"byte_end":935410,"line_start":163,"line_end":163,"column_start":15,"column_end":30},"kind":{"Impl":{"id":151}},"from":{"krate":0,"index":4286},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":935588,"byte_end":935603,"line_start":170,"line_end":170,"column_start":47,"column_end":62},"kind":{"Impl":{"id":152}},"from":{"krate":0,"index":4286},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":937973,"byte_end":937988,"line_start":215,"line_end":215,"column_start":6,"column_end":21},"kind":{"Impl":{"id":153}},"from":{"krate":0,"index":4300},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":941975,"byte_end":941990,"line_start":304,"line_end":304,"column_start":15,"column_end":30},"kind":{"Impl":{"id":154}},"from":{"krate":0,"index":4300},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":942168,"byte_end":942183,"line_start":311,"line_end":311,"column_start":47,"column_end":62},"kind":{"Impl":{"id":155}},"from":{"krate":0,"index":4300},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":948725,"byte_end":948740,"line_start":419,"line_end":419,"column_start":6,"column_end":21},"kind":{"Impl":{"id":156}},"from":{"krate":0,"index":4322},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":953663,"byte_end":953674,"line_start":525,"line_end":525,"column_start":10,"column_end":21},"kind":{"Impl":{"id":157}},"from":{"krate":0,"index":4333},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":956807,"byte_end":956818,"line_start":589,"line_end":589,"column_start":38,"column_end":49},"kind":{"Impl":{"id":158}},"from":{"krate":0,"index":4333},"to":{"krate":2,"index":2206}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":957680,"byte_end":957694,"line_start":617,"line_end":617,"column_start":6,"column_end":20},"kind":{"Impl":{"id":159}},"from":{"krate":0,"index":7025},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":958081,"byte_end":958096,"line_start":635,"line_end":635,"column_start":15,"column_end":30},"kind":{"Impl":{"id":160}},"from":{"krate":0,"index":4322},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/monte_carlo.rs","byte_start":958274,"byte_end":958289,"line_start":642,"line_end":642,"column_start":47,"column_end":62},"kind":{"Impl":{"id":161}},"from":{"krate":0,"index":4322},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":970892,"byte_end":970911,"line_start":224,"line_end":224,"column_start":51,"column_end":70},"kind":{"Impl":{"id":162}},"from":{"krate":0,"index":4358},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":971475,"byte_end":971490,"line_start":248,"line_end":248,"column_start":6,"column_end":21},"kind":{"Impl":{"id":163}},"from":{"krate":0,"index":4365},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":972951,"byte_end":972966,"line_start":290,"line_end":290,"column_start":15,"column_end":30},"kind":{"Impl":{"id":164}},"from":{"krate":0,"index":4365},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":973148,"byte_end":973163,"line_start":297,"line_end":297,"column_start":46,"column_end":61},"kind":{"Impl":{"id":165}},"from":{"krate":0,"index":4365},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":974022,"byte_end":974039,"line_start":332,"line_end":332,"column_start":6,"column_end":23},"kind":{"Impl":{"id":166}},"from":{"krate":0,"index":4385},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":977524,"byte_end":977541,"line_start":426,"line_end":426,"column_start":15,"column_end":32},"kind":{"Impl":{"id":167}},"from":{"krate":0,"index":4385},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":977858,"byte_end":977879,"line_start":440,"line_end":440,"column_start":6,"column_end":27},"kind":{"Impl":{"id":168}},"from":{"krate":0,"index":4400},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multifit_solver.rs","byte_start":978540,"byte_end":978559,"line_start":463,"line_end":463,"column_start":6,"column_end":25},"kind":{"Impl":{"id":169}},"from":{"krate":0,"index":4405},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multiset.rs","byte_start":981260,"byte_end":981268,"line_start":25,"line_end":25,"column_start":6,"column_end":14},"kind":{"Impl":{"id":170}},"from":{"krate":0,"index":4424},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multiset.rs","byte_start":986275,"byte_end":986283,"line_start":143,"line_end":143,"column_start":15,"column_end":23},"kind":{"Impl":{"id":171}},"from":{"krate":0,"index":4424},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/multiset.rs","byte_start":986449,"byte_end":986457,"line_start":150,"line_end":150,"column_start":38,"column_end":46},"kind":{"Impl":{"id":172}},"from":{"krate":0,"index":4424},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/n_tuples.rs","byte_start":988983,"byte_end":988990,"line_start":43,"line_end":43,"column_start":9,"column_end":16},"kind":{"Impl":{"id":173}},"from":{"krate":0,"index":4458},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/n_tuples.rs","byte_start":992299,"byte_end":992306,"line_start":123,"line_end":123,"column_start":18,"column_end":25},"kind":{"Impl":{"id":174}},"from":{"krate":0,"index":4458},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/n_tuples.rs","byte_start":992475,"byte_end":992482,"line_start":130,"line_end":130,"column_start":39,"column_end":46},"kind":{"Impl":{"id":175}},"from":{"krate":0,"index":4458},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":996737,"byte_end":996749,"line_start":80,"line_end":80,"column_start":10,"column_end":22},"kind":{"Impl":{"id":176}},"from":{"krate":0,"index":4487},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":999379,"byte_end":999389,"line_start":153,"line_end":153,"column_start":6,"column_end":16},"kind":{"Impl":{"id":177}},"from":{"krate":0,"index":4499},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1003839,"byte_end":1003849,"line_start":228,"line_end":228,"column_start":15,"column_end":25},"kind":{"Impl":{"id":178}},"from":{"krate":0,"index":4499},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1004021,"byte_end":1004031,"line_start":235,"line_end":235,"column_start":41,"column_end":51},"kind":{"Impl":{"id":179}},"from":{"krate":0,"index":4499},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1004520,"byte_end":1004534,"line_start":260,"line_end":260,"column_start":6,"column_end":20},"kind":{"Impl":{"id":180}},"from":{"krate":0,"index":7037},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1008677,"byte_end":1008691,"line_start":371,"line_end":371,"column_start":46,"column_end":60},"kind":{"Impl":{"id":181}},"from":{"krate":0,"index":7037},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1009262,"byte_end":1009275,"line_start":395,"line_end":395,"column_start":6,"column_end":19},"kind":{"Impl":{"id":182}},"from":{"krate":0,"index":4532},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1016343,"byte_end":1016356,"line_start":538,"line_end":538,"column_start":15,"column_end":28},"kind":{"Impl":{"id":183}},"from":{"krate":0,"index":4532},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1016534,"byte_end":1016547,"line_start":545,"line_end":545,"column_start":44,"column_end":57},"kind":{"Impl":{"id":184}},"from":{"krate":0,"index":4532},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1017069,"byte_end":1017086,"line_start":570,"line_end":570,"column_start":6,"column_end":23},"kind":{"Impl":{"id":185}},"from":{"krate":0,"index":7042},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1017489,"byte_end":1017506,"line_start":588,"line_end":588,"column_start":49,"column_end":66},"kind":{"Impl":{"id":186}},"from":{"krate":0,"index":7042},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1018108,"byte_end":1018120,"line_start":612,"line_end":612,"column_start":6,"column_end":18},"kind":{"Impl":{"id":187}},"from":{"krate":0,"index":4560},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1022494,"byte_end":1022506,"line_start":681,"line_end":681,"column_start":15,"column_end":27},"kind":{"Impl":{"id":188}},"from":{"krate":0,"index":4560},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1022682,"byte_end":1022694,"line_start":688,"line_end":688,"column_start":43,"column_end":55},"kind":{"Impl":{"id":189}},"from":{"krate":0,"index":4560},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1023497,"byte_end":1023509,"line_start":718,"line_end":718,"column_start":10,"column_end":22},"kind":{"Impl":{"id":190}},"from":{"krate":0,"index":4575},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ordinary_differential_equations.rs","byte_start":1030521,"byte_end":1030533,"line_start":843,"line_end":843,"column_start":19,"column_end":31},"kind":{"Impl":{"id":191}},"from":{"krate":0,"index":4575},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":1033455,"byte_end":1033466,"line_start":42,"line_end":42,"column_start":6,"column_end":17},"kind":{"Impl":{"id":192}},"from":{"krate":0,"index":4606},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":1041366,"byte_end":1041377,"line_start":203,"line_end":203,"column_start":15,"column_end":26},"kind":{"Impl":{"id":193}},"from":{"krate":0,"index":4606},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":1041549,"byte_end":1041560,"line_start":210,"line_end":210,"column_start":41,"column_end":52},"kind":{"Impl":{"id":194}},"from":{"krate":0,"index":4606},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/permutation.rs","byte_start":1042084,"byte_end":1042095,"line_start":233,"line_end":233,"column_start":16,"column_end":27},"kind":{"Impl":{"id":195}},"from":{"krate":0,"index":4606},"to":{"krate":2,"index":7636}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/polynomial.rs","byte_start":1042930,"byte_end":1042941,"line_start":19,"line_end":19,"column_start":6,"column_end":17},"kind":{"Impl":{"id":196}},"from":{"krate":0,"index":4646},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/polynomial.rs","byte_start":1044894,"byte_end":1044905,"line_start":53,"line_end":53,"column_start":15,"column_end":26},"kind":{"Impl":{"id":197}},"from":{"krate":0,"index":4646},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/polynomial.rs","byte_start":1045099,"byte_end":1045110,"line_start":60,"line_end":60,"column_start":52,"column_end":63},"kind":{"Impl":{"id":198}},"from":{"krate":0,"index":4646},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/qrng.rs","byte_start":1046675,"byte_end":1046679,"line_start":31,"line_end":31,"column_start":6,"column_end":10},"kind":{"Impl":{"id":199}},"from":{"krate":0,"index":4663},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/qrng.rs","byte_start":1049195,"byte_end":1049199,"line_start":93,"line_end":93,"column_start":16,"column_end":20},"kind":{"Impl":{"id":200}},"from":{"krate":0,"index":4663},"to":{"krate":2,"index":2181}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/qrng.rs","byte_start":1049433,"byte_end":1049437,"line_start":100,"line_end":100,"column_start":15,"column_end":19},"kind":{"Impl":{"id":201}},"from":{"krate":0,"index":4663},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/qrng.rs","byte_start":1049595,"byte_end":1049599,"line_start":107,"line_end":107,"column_start":34,"column_end":38},"kind":{"Impl":{"id":202}},"from":{"krate":0,"index":4663},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/qrng.rs","byte_start":1050092,"byte_end":1050100,"line_start":133,"line_end":133,"column_start":6,"column_end":14},"kind":{"Impl":{"id":203}},"from":{"krate":0,"index":7047},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/qrng.rs","byte_start":1051362,"byte_end":1051370,"line_start":173,"line_end":173,"column_start":39,"column_end":47},"kind":{"Impl":{"id":204}},"from":{"krate":0,"index":7047},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ran_discrete.rs","byte_start":1054249,"byte_end":1054260,"line_start":29,"line_end":29,"column_start":6,"column_end":17},"kind":{"Impl":{"id":205}},"from":{"krate":0,"index":4697},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ran_discrete.rs","byte_start":1055734,"byte_end":1055745,"line_start":57,"line_end":57,"column_start":15,"column_end":26},"kind":{"Impl":{"id":206}},"from":{"krate":0,"index":4697},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/ran_discrete.rs","byte_start":1055925,"byte_end":1055936,"line_start":64,"line_end":64,"column_start":44,"column_end":55},"kind":{"Impl":{"id":207}},"from":{"krate":0,"index":4697},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/result.rs","byte_start":1056882,"byte_end":1056888,"line_start":17,"line_end":17,"column_start":18,"column_end":24},"kind":{"Impl":{"id":208}},"from":{"krate":0,"index":7052},"to":{"krate":2,"index":2206}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/result.rs","byte_start":1056956,"byte_end":1056962,"line_start":23,"line_end":23,"column_start":6,"column_end":12},"kind":{"Impl":{"id":209}},"from":{"krate":0,"index":7052},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/result.rs","byte_start":1057641,"byte_end":1057650,"line_start":44,"line_end":44,"column_start":18,"column_end":27},"kind":{"Impl":{"id":210}},"from":{"krate":0,"index":7058},"to":{"krate":2,"index":2206}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/result.rs","byte_start":1057724,"byte_end":1057733,"line_start":50,"line_end":50,"column_start":6,"column_end":15},"kind":{"Impl":{"id":211}},"from":{"krate":0,"index":7058},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1063984,"byte_end":1063987,"line_start":81,"line_end":81,"column_start":6,"column_end":9},"kind":{"Impl":{"id":212}},"from":{"krate":0,"index":4724},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1071291,"byte_end":1071294,"line_start":206,"line_end":206,"column_start":16,"column_end":19},"kind":{"Impl":{"id":213}},"from":{"krate":0,"index":4724},"to":{"krate":2,"index":2181}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1071523,"byte_end":1071526,"line_start":213,"line_end":213,"column_start":15,"column_end":18},"kind":{"Impl":{"id":214}},"from":{"krate":0,"index":4724},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1071682,"byte_end":1071685,"line_start":220,"line_end":220,"column_start":33,"column_end":36},"kind":{"Impl":{"id":215}},"from":{"krate":0,"index":4724},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1072104,"byte_end":1072111,"line_start":245,"line_end":245,"column_start":6,"column_end":13},"kind":{"Impl":{"id":216}},"from":{"krate":0,"index":7065},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/rng.rs","byte_start":1075205,"byte_end":1075212,"line_start":337,"line_end":337,"column_start":38,"column_end":45},"kind":{"Impl":{"id":217}},"from":{"krate":0,"index":7065},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1112836,"byte_end":1112851,"line_start":58,"line_end":58,"column_start":47,"column_end":62},"kind":{"Impl":{"id":218}},"from":{"krate":0,"index":4815},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1113287,"byte_end":1113302,"line_start":76,"line_end":76,"column_start":6,"column_end":21},"kind":{"Impl":{"id":219}},"from":{"krate":0,"index":4815},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1116289,"byte_end":1116300,"line_start":132,"line_end":132,"column_start":6,"column_end":17},"kind":{"Impl":{"id":220}},"from":{"krate":0,"index":4827},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1118845,"byte_end":1118856,"line_start":194,"line_end":194,"column_start":15,"column_end":26},"kind":{"Impl":{"id":221}},"from":{"krate":0,"index":4827},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1119633,"byte_end":1119650,"line_start":215,"line_end":215,"column_start":49,"column_end":66},"kind":{"Impl":{"id":222}},"from":{"krate":0,"index":4839},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1120104,"byte_end":1120121,"line_start":233,"line_end":233,"column_start":6,"column_end":23},"kind":{"Impl":{"id":223}},"from":{"krate":0,"index":4839},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1121279,"byte_end":1121292,"line_start":261,"line_end":261,"column_start":6,"column_end":19},"kind":{"Impl":{"id":224}},"from":{"krate":0,"index":4851},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/roots.rs","byte_start":1123488,"byte_end":1123501,"line_start":314,"line_end":314,"column_start":15,"column_end":28},"kind":{"Impl":{"id":225}},"from":{"krate":0,"index":4851},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/series_acceleration.rs","byte_start":1127002,"byte_end":1127017,"line_start":60,"line_end":60,"column_start":6,"column_end":21},"kind":{"Impl":{"id":226}},"from":{"krate":0,"index":4864},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/series_acceleration.rs","byte_start":1128614,"byte_end":1128629,"line_start":98,"line_end":98,"column_start":15,"column_end":30},"kind":{"Impl":{"id":227}},"from":{"krate":0,"index":4864},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/series_acceleration.rs","byte_start":1128811,"byte_end":1128826,"line_start":105,"line_end":105,"column_start":51,"column_end":66},"kind":{"Impl":{"id":228}},"from":{"krate":0,"index":4864},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/series_acceleration.rs","byte_start":1129670,"byte_end":1129690,"line_start":132,"line_end":132,"column_start":6,"column_end":26},"kind":{"Impl":{"id":229}},"from":{"krate":0,"index":4879},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/series_acceleration.rs","byte_start":1131395,"byte_end":1131415,"line_start":171,"line_end":171,"column_start":15,"column_end":35},"kind":{"Impl":{"id":230}},"from":{"krate":0,"index":4879},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/series_acceleration.rs","byte_start":1131607,"byte_end":1131627,"line_start":178,"line_end":178,"column_start":56,"column_end":76},"kind":{"Impl":{"id":231}},"from":{"krate":0,"index":4879},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/siman.rs","byte_start":1134704,"byte_end":1134716,"line_start":60,"line_end":60,"column_start":9,"column_end":21},"kind":{"Impl":{"id":232}},"from":{"krate":0,"index":4896},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/siman.rs","byte_start":1149457,"byte_end":1149475,"line_start":479,"line_end":479,"column_start":6,"column_end":24},"kind":{"Impl":{"id":233}},"from":{"krate":0,"index":4918},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1152081,"byte_end":1152091,"line_start":42,"line_end":42,"column_start":6,"column_end":16},"kind":{"Impl":{"id":234}},"from":{"krate":0,"index":4935},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1157722,"byte_end":1157731,"line_start":156,"line_end":156,"column_start":6,"column_end":15},"kind":{"Impl":{"id":235}},"from":{"krate":0,"index":4943},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1167184,"byte_end":1167193,"line_start":399,"line_end":399,"column_start":15,"column_end":24},"kind":{"Impl":{"id":236}},"from":{"krate":0,"index":4943},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1167390,"byte_end":1167399,"line_start":408,"line_end":408,"column_start":16,"column_end":25},"kind":{"Impl":{"id":237}},"from":{"krate":0,"index":4943},"to":{"krate":2,"index":7636}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1167867,"byte_end":1167876,"line_start":425,"line_end":425,"column_start":42,"column_end":51},"kind":{"Impl":{"id":238}},"from":{"krate":0,"index":4943},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1168450,"byte_end":1168459,"line_start":454,"line_end":454,"column_start":6,"column_end":15},"kind":{"Impl":{"id":239}},"from":{"krate":0,"index":4987},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1177736,"byte_end":1177745,"line_start":697,"line_end":697,"column_start":15,"column_end":24},"kind":{"Impl":{"id":240}},"from":{"krate":0,"index":4987},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1177936,"byte_end":1177945,"line_start":706,"line_end":706,"column_start":16,"column_end":25},"kind":{"Impl":{"id":241}},"from":{"krate":0,"index":4987},"to":{"krate":2,"index":7636}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector.rs","byte_start":1178407,"byte_end":1178416,"line_start":723,"line_end":723,"column_start":36,"column_end":45},"kind":{"Impl":{"id":242}},"from":{"krate":0,"index":4987},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1179160,"byte_end":1179176,"line_start":15,"line_end":15,"column_start":6,"column_end":22},"kind":{"Impl":{"id":243}},"from":{"krate":0,"index":5041},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1187357,"byte_end":1187373,"line_start":224,"line_end":224,"column_start":15,"column_end":31},"kind":{"Impl":{"id":244}},"from":{"krate":0,"index":5041},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1187527,"byte_end":1187543,"line_start":231,"line_end":231,"column_start":16,"column_end":32},"kind":{"Impl":{"id":245}},"from":{"krate":0,"index":5041},"to":{"krate":2,"index":7636}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1188017,"byte_end":1188033,"line_start":248,"line_end":248,"column_start":44,"column_end":60},"kind":{"Impl":{"id":246}},"from":{"krate":0,"index":5041},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1188565,"byte_end":1188581,"line_start":272,"line_end":272,"column_start":6,"column_end":22},"kind":{"Impl":{"id":247}},"from":{"krate":0,"index":5079},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1196918,"byte_end":1196934,"line_start":482,"line_end":482,"column_start":15,"column_end":31},"kind":{"Impl":{"id":248}},"from":{"krate":0,"index":5079},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1197094,"byte_end":1197110,"line_start":489,"line_end":489,"column_start":16,"column_end":32},"kind":{"Impl":{"id":249}},"from":{"krate":0,"index":5079},"to":{"krate":2,"index":7636}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/vector_complex.rs","byte_start":1197590,"byte_end":1197606,"line_start":506,"line_end":506,"column_start":50,"column_end":66},"kind":{"Impl":{"id":250}},"from":{"krate":0,"index":5079},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/wavelet_transforms.rs","byte_start":1201259,"byte_end":1201266,"line_start":62,"line_end":62,"column_start":6,"column_end":13},"kind":{"Impl":{"id":251}},"from":{"krate":0,"index":5119},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/wavelet_transforms.rs","byte_start":1202179,"byte_end":1202186,"line_start":89,"line_end":89,"column_start":15,"column_end":22},"kind":{"Impl":{"id":252}},"from":{"krate":0,"index":5119},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/wavelet_transforms.rs","byte_start":1202350,"byte_end":1202357,"line_start":96,"line_end":96,"column_start":37,"column_end":44},"kind":{"Impl":{"id":253}},"from":{"krate":0,"index":5119},"to":{"krate":0,"index":1341}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/wavelet_transforms.rs","byte_start":1203043,"byte_end":1203054,"line_start":123,"line_end":123,"column_start":6,"column_end":17},"kind":{"Impl":{"id":254}},"from":{"krate":0,"index":7070},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/wavelet_transforms.rs","byte_start":1205140,"byte_end":1205156,"line_start":189,"line_end":189,"column_start":6,"column_end":22},"kind":{"Impl":{"id":255}},"from":{"krate":0,"index":5138},"to":{"krate":4294967295,"index":4294967295}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/wavelet_transforms.rs","byte_start":1205874,"byte_end":1205890,"line_start":207,"line_end":207,"column_start":15,"column_end":31},"kind":{"Impl":{"id":256}},"from":{"krate":0,"index":5138},"to":{"krate":2,"index":1726}},{"span":{"file_name":"/Users/wjs/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-1.1.0/src/types/wavelet_transforms.rs","byte_start":1206074,"byte_end":1206090,"line_start":214,"line_end":214,"column_start":47,"column_end":63},"kind":{"Impl":{"id":257}},"from":{"krate":0,"index":5138},"to":{"krate":0,"index":1341}}]}